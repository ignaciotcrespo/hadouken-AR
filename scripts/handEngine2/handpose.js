parcelRequire = function(e, r, t, n) {
    var i, o = "function" == typeof parcelRequire && parcelRequire,
        u = "function" == typeof require && require;

    function f(t, n) {
        if (!r[t]) {
            if (!e[t]) {
                var i = "function" == typeof parcelRequire && parcelRequire;
                if (!n && i) return i(t, !0);
                if (o) return o(t, !0);
                if (u && "string" == typeof t) return u(t);
                var c = new Error("Cannot find module '" + t + "'");
                throw c.code = "MODULE_NOT_FOUND", c
            }
            p.resolve = function(r) {
                return e[t][1][r] || r
            }, p.cache = {};
            var l = r[t] = new f.Module(t);
            e[t][0].call(l.exports, p, l, l.exports, this)
        }
        return r[t].exports;

        function p(e) {
            return f(p.resolve(e))
        }
    }
    f.isParcelRequire = !0, f.Module = function(e) {
        this.id = e, this.bundle = f, this.exports = {}
    }, f.modules = e, f.cache = r, f.parent = o, f.register = function(r, t) {
        e[r] = [function(e, r) {
            r.exports = t
        }, {}]
    };
    for (var c = 0; c < t.length; c++) try {
        f(t[c])
    } catch (e) {
        i || (i = e)
    }
    if (t.length) {
        var l = f(t[t.length - 1]);
        "object" == typeof exports && "undefined" != typeof module ? module.exports = l : "function" == typeof define && define.amd ? define(function() {
            return l
        }) : n && (this[n] = l)
    }
    if (parcelRequire = f, i) throw i;
    return f
}({
    "Fbeg": [function(require, module, exports) {
        var global = arguments[3];
        var t = arguments[3];
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getQueryParams = a, exports.env = o, exports.setEnvironmentGlobal = n, exports.ENV = exports.Environment = void 0;
        const e = "tfjsflags";
        class s {
            constructor(t) {
                this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags()
            }
            setPlatform(t, e) {
                null != this.platform && console.warn(`Platform ${this.platformName} has already been set. ` + `Overwriting the platform with ${e}.`), this.platformName = t, this.platform = e
            }
            registerFlag(t, e, s) {
                if (this.flagRegistry[t] = {
                        evaluationFn: e,
                        setHook: s
                    }, null != this.urlFlags[t]) {
                    const e = this.urlFlags[t];
                    console.warn(`Setting feature override from URL ${t}: ${e}.`), this.set(t, e)
                }
            }
            async getAsync(t) {
                return t in this.flags ? this.flags[t] : (this.flags[t] = await this.evaluateFlag(t), this.flags[t])
            }
            get(t) {
                if (t in this.flags) return this.flags[t];
                const e = this.evaluateFlag(t);
                if (e instanceof Promise) throw new Error(`Flag ${t} cannot be synchronously evaluated. ` + "Please use getAsync() instead.");
                return this.flags[t] = e, this.flags[t]
            }
            getNumber(t) {
                return this.get(t)
            }
            getBool(t) {
                return this.get(t)
            }
            getFlags() {
                return this.flags
            }
            get features() {
                return this.flags
            }
            set(t, e) {
                if (null == this.flagRegistry[t]) throw new Error(`Cannot set flag ${t} as it has not been registered.`);
                this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
            }
            evaluateFlag(t) {
                if (null == this.flagRegistry[t]) throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);
                return this.flagRegistry[t].evaluationFn()
            }
            setFlags(t) {
                this.flags = Object.assign({}, t)
            }
            reset() {
                this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
            }
            populateURLFlags() {
                if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
                const t = a(this.global.location.search);
                if (e in t) {
                    t[e].split(",").forEach(t => {
                        const [e, s] = t.split(":");
                        this.urlFlags[e] = r(e, s)
                    })
                }
            }
        }

        function a(t) {
            const e = {};
            return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (t, ...s) => (l(e, s[0], s[1]), s.join("="))), e
        }

        function l(t, e, s) {
            t[decodeURIComponent(e)] = decodeURIComponent(s || "")
        }

        function r(t, e) {
            if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
            if (`${+e}` === e) return +e;
            throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)
        }

        function o() {
            return i
        }
        exports.Environment = s;
        let i = null;

        function n(t) {
            exports.ENV = i = t
        }
        exports.ENV = i;
    }, {}],
    "g5IB": [function(require, module, exports) {

        var t, e, n = module.exports = {};

        function r() {
            throw new Error("setTimeout has not been defined")
        }

        function o() {
            throw new Error("clearTimeout has not been defined")
        }

        function i(e) {
            if (t === setTimeout) return setTimeout(e, 0);
            if ((t === r || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);
            try {
                return t(e, 0)
            } catch (n) {
                try {
                    return t.call(null, e, 0)
                } catch (n) {
                    return t.call(this, e, 0)
                }
            }
        }

        function u(t) {
            if (e === clearTimeout) return clearTimeout(t);
            if ((e === o || !e) && clearTimeout) return e = clearTimeout, clearTimeout(t);
            try {
                return e(t)
            } catch (n) {
                try {
                    return e.call(null, t)
                } catch (n) {
                    return e.call(this, t)
                }
            }
        }! function() {
            try {
                t = "function" == typeof setTimeout ? setTimeout : r
            } catch (n) {
                t = r
            }
            try {
                e = "function" == typeof clearTimeout ? clearTimeout : o
            } catch (n) {
                e = o
            }
        }();
        var c, s = [],
            l = !1,
            a = -1;

        function f() {
            l && c && (l = !1, c.length ? s = c.concat(s) : a = -1, s.length && h())
        }

        function h() {
            if (!l) {
                var t = i(f);
                l = !0;
                for (var e = s.length; e;) {
                    for (c = s, s = []; ++a < e;) c && c[a].run();
                    a = -1, e = s.length
                }
                c = null, l = !1, u(t)
            }
        }

        function m(t, e) {
            this.fun = t, this.array = e
        }

        function p() {}
        n.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
            s.push(new m(t, e)), 1 !== s.length || l || i(h)
        }, m.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, n.title = "browser", n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function(t) {
            return []
        }, n.binding = function(t) {
            throw new Error("process.binding is not supported")
        }, n.cwd = function() {
            return "/"
        }, n.chdir = function(t) {
            throw new Error("process.chdir is not supported")
        }, n.umask = function() {
            return 0
        };
    }, {}],
    "QcKL": [function(require, module, exports) {
        var global = arguments[3];
        var process = require("process");
        var e = arguments[3],
            t = require("process");
        let o;

        function n() {
            if (null == o) {
                let n;
                if ("undefined" != typeof window) n = window;
                else if (void 0 !== e) n = e;
                else if (void 0 !== t) n = t;
                else {
                    if ("undefined" == typeof self) throw new Error("Could not find a global object");
                    n = self
                }
                o = n
            }
            return o
        }

        function l() {
            const e = n();
            return null == e._tfGlobals && (e._tfGlobals = new Map), e._tfGlobals
        }

        function r(e, t) {
            const o = l();
            if (o.has(e)) return o.get(e); {
                const n = t();
                return o.set(e, n), o.get(e)
            }
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getGlobalNamespace = n, exports.getGlobal = r;
    }, {
        "process": "g5IB"
    }],
    "wJg6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getKernel = o, exports.getGradient = s, exports.getKernelsForBackend = i, exports.registerKernel = a, exports.registerGradient = l, exports.unregisterKernel = c, exports.unregisterGradient = g;
        var e = require("./environment"),
            r = require("./global_util");
        const n = (0, r.getGlobal)("kernelRegistry", () => new Map),
            t = (0, r.getGlobal)("gradRegistry", () => new Map);

        function o(e, r) {
            const t = u(e, r);
            return n.get(t)
        }

        function s(e) {
            return t.get(e)
        }

        function i(e) {
            const r = n.entries(),
                t = [];
            for (;;) {
                const {
                    done: n,
                    value: o
                } = r.next();
                if (n) break;
                const [s, i] = o, [a] = s.split("_");
                a === e && t.push(i)
            }
            return t
        }

        function a(e) {
            const {
                kernelName: r,
                backendName: t
            } = e, o = u(r, t);
            n.has(o) && console.warn(`The kernel '${r}' for backend ` + `'${t}' is already registered`), n.set(o, e)
        }

        function l(r) {
            const {
                kernelName: n
            } = r;
            t.has(n) && (0, e.env)().getBool("DEBUG") && console.warn(`Overriding the gradient for '${n}'`), t.set(n, r)
        }

        function c(e, r) {
            const t = u(e, r);
            if (!n.has(t)) throw new Error(`The kernel '${e}' for backend ` + `'${r}' is not registered`);
            n.delete(t)
        }

        function g(e) {
            if (!t.has(e)) throw new Error(`The gradient '${e}' for backend is not registered`);
            t.delete(e)
        }

        function u(e, r) {
            return `${r}_${e}`
        }
    }, {
        "./environment": "Fbeg",
        "./global_util": "QcKL"
    }],
    "P6nv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.shuffle = r, exports.clamp = n, exports.nearestLargerEven = e, exports.sum = o, exports.randUniform = i, exports.distSquared = s, exports.assert = a, exports.assertShapesMatch = u, exports.assertNonNull = l, exports.flatten = f, exports.sizeFromShape = c, exports.isScalarShape = p, exports.arraysEqual = h, exports.isInt = y, exports.tanh = x, exports.sizeToSquarishShape = m, exports.createShuffledIndices = g, exports.rightPad = w, exports.repeatedTry = d, exports.inferFromImplicitShape = A, exports.parseAxisParam = b, exports.squeezeShape = $, exports.getTypedArrayFromDType = E, exports.getArrayFromDType = v, exports.checkConversionForErrors = S, exports.isValidDtype = F, exports.hasEncodingLoss = T, exports.isTypedArray = U, exports.bytesPerElement = I, exports.bytesFromStringArray = M, exports.isString = N, exports.isBoolean = k, exports.isNumber = z, exports.inferDtype = D, exports.isFunction = q, exports.nearestDivisor = P, exports.computeStrides = C, exports.toTypedArray = B, exports.toNestedArray = G, exports.makeOnesTypedArray = Z, exports.makeZerosTypedArray = _, exports.makeZerosNestedTypedArray = j, exports.now = V, exports.assertNonNegativeIntegerDimensions = H, exports.fetch = J, exports.encodeString = K, exports.decodeString = Q, exports.locToIndex = R, exports.indexToLoc = W;
        var t = require("./environment");

        function r(t) {
            let r = t.length,
                n = 0,
                e = 0;
            for (; r > 0;) e = Math.random() * r | 0, n = t[--r], t[r] = t[e], t[e] = n
        }

        function n(t, r, n) {
            return Math.max(t, Math.min(r, n))
        }

        function e(t) {
            return t % 2 == 0 ? t : t + 1
        }

        function o(t) {
            let r = 0;
            for (let n = 0; n < t.length; n++) r += t[n];
            return r
        }

        function i(t, r) {
            const n = Math.random();
            return r * n + (1 - n) * t
        }

        function s(t, r) {
            let n = 0;
            for (let e = 0; e < t.length; e++) {
                const o = Number(t[e]) - Number(r[e]);
                n += o * o
            }
            return n
        }

        function a(t, r) {
            if (!t) throw new Error("string" == typeof r ? r : r())
        }

        function u(t, r, n = "") {
            a(h(t, r), () => n + ` Shapes ${t} and ${r} must match`)
        }

        function l(t) {
            a(null != t, () => "The input to the tensor constructor must be a non-null value.")
        }

        function f(t, r = [], n = !1) {
            if (null == r && (r = []), Array.isArray(t) || U(t) && !n)
                for (let e = 0; e < t.length; ++e) f(t[e], r, n);
            else r.push(t);
            return r
        }

        function c(t) {
            if (0 === t.length) return 1;
            let r = t[0];
            for (let n = 1; n < t.length; n++) r *= t[n];
            return r
        }

        function p(t) {
            return 0 === t.length
        }

        function h(t, r) {
            if (t === r) return !0;
            if (null == t || null == r) return !1;
            if (t.length !== r.length) return !1;
            for (let n = 0; n < t.length; n++)
                if (t[n] !== r[n]) return !1;
            return !0
        }

        function y(t) {
            return t % 1 == 0
        }

        function x(t) {
            if (null != Math.tanh) return Math.tanh(t);
            if (t === 1 / 0) return 1;
            if (t === -1 / 0) return -1; {
                const r = Math.exp(2 * t);
                return (r - 1) / (r + 1)
            }
        }

        function m(t) {
            const r = Math.ceil(Math.sqrt(t));
            return [r, Math.ceil(t / r)]
        }

        function g(t) {
            const n = new Uint32Array(t);
            for (let r = 0; r < t; ++r) n[r] = r;
            return r(n), n
        }

        function w(t, r) {
            return r <= t.length ? t : t + " ".repeat(r - t.length)
        }

        function d(t, r = (t => 0), n) {
            return new Promise((e, o) => {
                let i = 0;
                const s = () => {
                    if (t()) return void e();
                    const a = r(++i);
                    null != n && i >= n ? o() : setTimeout(s, a)
                };
                s()
            })
        }

        function A(t, r) {
            let n = 1,
                e = -1;
            for (let i = 0; i < t.length; ++i)
                if (t[i] >= 0) n *= t[i];
                else if (-1 === t[i]) {
                if (-1 !== e) throw Error("Shapes can only have 1 implicit size. " + `Found -1 at dim ${e} and dim ${i}`);
                e = i
            } else if (t[i] < 0) throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);
            if (-1 === e) {
                if (r > 0 && r !== n) throw Error(`Size(${r}) must match the product of shape ${t}`);
                return t
            }
            if (0 === n) throw Error(`Cannot infer the missing size in [${t}] when ` + "there are 0 elements");
            if (r % n != 0) throw Error("The implicit shape can't be a fractional number. " + `Got ${r} / ${n}`);
            const o = t.slice();
            return o[e] = r / n, o
        }

        function b(t, r) {
            const n = r.length;
            return a((t = null == t ? r.map((t, r) => r) : [].concat(t)).every(t => t >= -n && t < n), () => `All values in axis param must be in range [-${n}, ${n}) but ` + `got axis ${t}`), a(t.every(t => y(t)), () => "All values in axis param must be integers but " + `got axis ${t}`), t.map(t => t < 0 ? n + t : t)
        }

        function $(t, r) {
            const n = [],
                e = [],
                o = null != r && Array.isArray(r) && 0 === r.length,
                i = null == r || o ? null : b(r, t).sort();
            let s = 0;
            for (let a = 0; a < t.length; ++a) {
                if (null != i) {
                    if (i[s] === a && 1 !== t[a]) throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);
                    (null == i[s] || i[s] > a) && 1 === t[a] && (n.push(t[a]), e.push(a)), i[s] <= a && s++
                }
                1 !== t[a] && (n.push(t[a]), e.push(a))
            }
            return {
                newShape: n,
                keptDims: e
            }
        }

        function E(t, r) {
            let n = null;
            if (null == t || "float32" === t) n = new Float32Array(r);
            else if ("int32" === t) n = new Int32Array(r);
            else {
                if ("bool" !== t) throw new Error(`Unknown data type ${t}`);
                n = new Uint8Array(r)
            }
            return n
        }

        function v(t, r) {
            let n = null;
            if (null == t || "float32" === t) n = new Float32Array(r);
            else if ("int32" === t) n = new Int32Array(r);
            else if ("bool" === t) n = new Uint8Array(r);
            else {
                if ("string" !== t) throw new Error(`Unknown data type ${t}`);
                n = new Array(r)
            }
            return n
        }

        function S(t, r) {
            for (let n = 0; n < t.length; n++) {
                const e = t[n];
                if (isNaN(e) || !isFinite(e)) throw Error(`A tensor of type ${r} being uploaded contains ${e}.`)
            }
        }

        function F(t) {
            return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t
        }

        function T(t, r) {
            return "complex64" !== r && (("float32" !== r || "complex64" === t) && (("int32" !== r || "float32" === t || "complex64" === t) && ("bool" !== r || "bool" !== t)))
        }

        function U(t) {
            return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array
        }

        function I(t) {
            if ("float32" === t || "int32" === t) return 4;
            if ("complex64" === t) return 8;
            if ("bool" === t) return 1;
            throw new Error(`Unknown dtype ${t}`)
        }

        function M(t) {
            if (null == t) return 0;
            let r = 0;
            return t.forEach(t => r += t.length), r
        }

        function N(t) {
            return "string" == typeof t || t instanceof String
        }

        function k(t) {
            return "boolean" == typeof t
        }

        function z(t) {
            return "number" == typeof t
        }

        function D(t) {
            return Array.isArray(t) ? D(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : z(t) ? "float32" : N(t) ? "string" : k(t) ? "bool" : "float32"
        }

        function q(t) {
            return !!(t && t.constructor && t.call && t.apply)
        }

        function P(t, r) {
            for (let n = r; n < t; ++n)
                if (t % n == 0) return n;
            return t
        }

        function C(t) {
            const r = t.length;
            if (r < 2) return [];
            const n = new Array(r - 1);
            n[r - 2] = t[r - 1];
            for (let e = r - 3; e >= 0; --e) n[e] = n[e + 1] * t[e + 1];
            return n
        }

        function B(r, n) {
            if ("string" === n) throw new Error("Cannot convert a string[] to a TypedArray");
            if (Array.isArray(r) && (r = f(r)), (0, t.env)().getBool("DEBUG") && S(r, n), O(r, n)) return r;
            if (null == n || "float32" === n || "complex64" === n) return new Float32Array(r);
            if ("int32" === n) return new Int32Array(r);
            if ("bool" === n) {
                const t = new Uint8Array(r.length);
                for (let n = 0; n < t.length; ++n) 0 !== Math.round(r[n]) && (t[n] = 1);
                return t
            }
            throw new Error(`Unknown data type ${n}`)
        }

        function L(t, r, n) {
            const e = new Array;
            if (1 === r.length) {
                const o = r[0];
                for (let r = 0; r < o; r++) e[r] = n[t + r]
            } else {
                const o = r[0],
                    i = r.slice(1),
                    s = i.reduce((t, r) => t * r);
                for (let r = 0; r < o; r++) e[r] = L(t + r * s, i, n)
            }
            return e
        }

        function G(t, r) {
            if (0 === t.length) return r[0];
            const n = t.reduce((t, r) => t * r);
            if (0 === n) return [];
            if (n !== r.length) throw new Error(`[${t}] does not match the input size ${r.length}.`);
            return L(0, t, r)
        }

        function O(t, r) {
            return t instanceof Float32Array && "float32" === r || t instanceof Int32Array && "int32" === r || t instanceof Uint8Array && "bool" === r
        }

        function Z(t, r) {
            const n = _(t, r);
            for (let e = 0; e < n.length; e++) n[e] = 1;
            return n
        }

        function _(t, r) {
            if (null == r || "float32" === r || "complex64" === r) return new Float32Array(t);
            if ("int32" === r) return new Int32Array(t);
            if ("bool" === r) return new Uint8Array(t);
            throw new Error(`Unknown data type ${r}`)
        }

        function j(t, r) {
            const n = t.reduce((t, r) => t * r, 1);
            if (null == r || "float32" === r) return G(t, new Float32Array(n));
            if ("int32" === r) return G(t, new Int32Array(n));
            if ("bool" === r) return G(t, new Uint8Array(n));
            throw new Error(`Unknown data type ${r}`)
        }

        function V() {
            return (0, t.env)().platform.now()
        }

        function H(t) {
            t.forEach(r => {
                a(Number.isInteger(r) && r >= 0, () => "Tensor must have a shape comprised of positive integers but got " + `shape [${t}].`)
            })
        }

        function J(r, n) {
            return (0, t.env)().platform.fetch(r, n)
        }

        function K(r, n = "utf-8") {
            return n = n || "utf-8", (0, t.env)().platform.encode(r, n)
        }

        function Q(r, n = "utf-8") {
            return n = n || "utf-8", (0, t.env)().platform.decode(r, n)
        }

        function R(t, r, n) {
            if (0 === r) return 0;
            if (1 === r) return t[0];
            let e = t[t.length - 1];
            for (let o = 0; o < t.length - 1; ++o) e += n[o] * t[o];
            return e
        }

        function W(t, r, n) {
            if (0 === r) return [];
            if (1 === r) return [t];
            const e = new Array(r);
            for (let o = 0; o < e.length - 1; ++o) e[o] = Math.floor(t / n[o]), t -= e[o] * n[o];
            return e[e.length - 1] = t, e
        }
    }, {
        "./environment": "Fbeg"
    }],
    "LCLi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.checkComputationForErrors = n, exports.Logger = exports.Profiler = void 0;
        var e = r(require("./util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var o = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var l in e)
                if (Object.prototype.hasOwnProperty.call(e, l)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, l) : null;
                    i && (i.get || i.set) ? Object.defineProperty(o, l, i) : o[l] = e[l]
                } return o.default = e, r && r.set(e, o), o
        }
        class o {
            constructor(e, t) {
                this.backendTimer = e, this.logger = t, null == t && (this.logger = new l)
            }
            profileKernel(e, t, r) {
                let o;
                const l = this.backendTimer.time(() => {
                    o = r()
                });
                return o.map(t => {
                    t.data().then(r => {
                        n(r, t.dtype, e)
                    })
                }), {
                    kernelName: e,
                    outputs: o,
                    inputs: t,
                    timeMs: l.then(e => e.kernelMs),
                    extraInfo: l.then(e => null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : "")
                }
            }
            logKernelProfile(e) {
                const {
                    kernelName: t,
                    outputs: r,
                    timeMs: o,
                    inputs: n,
                    extraInfo: l
                } = e;
                r.forEach(e => {
                    Promise.all([e.data(), o, l]).then(r => {
                        this.logger.logKernelProfile(t, e, r[0], r[1], n, r[2])
                    })
                })
            }
        }

        function n(e, t, r) {
            if ("float32" !== t) return !1;
            for (let o = 0; o < e.length; o++) {
                const t = e[o];
                if (isNaN(t) || !isFinite(t)) return console.warn(`Found ${t} in the result of '${r}'`), !0
            }
            return !1
        }
        exports.Profiler = o;
        class l {
            logKernelProfile(t, r, o, n, l, i) {
                const s = "number" == typeof n ? e.rightPad(`${n}ms`, 9) : n.error,
                    a = e.rightPad(t, 25),
                    c = r.rank,
                    u = r.size,
                    f = e.rightPad(r.shape.toString(), 14);
                let p = "";
                for (const e in l) {
                    const t = l[e].shape || r.shape,
                        o = t.length;
                    p += `${e}: ${o}D ${o>0?t:""} `
                }
                console.log(`%c${a}\t%c${s}\t%c${c}D ${f}\t%c${u}\t%c${p}\t%c${i}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
            }
        }
        exports.Logger = l;
    }, {
        "./util": "P6nv"
    }],
    "ugac": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getFilteredNodesXToY = r, exports.backpropagateGradients = o;
        var t = n(require("./util"));

        function e() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return e = function() {
                return t
            }, t
        }

        function n(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var n = e();
            if (n && n.has(t)) return n.get(t);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in t)
                if (Object.prototype.hasOwnProperty.call(t, i)) {
                    var s = o ? Object.getOwnPropertyDescriptor(t, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i]
                } return r.default = t, n && n.set(t, r), r
        }

        function r(t, e, n) {
            const r = {},
                o = {};
            for (let a = 0; a < e.length; a++) r[e[a].id] = !0;
            for (let a = 0; a < t.length; a++) {
                const n = t[a],
                    i = n.inputs;
                for (const t in i) {
                    const s = i[t];
                    let u = !1;
                    for (let t = 0; t < e.length; t++)
                        if (r[s.id]) {
                            n.outputs.forEach(t => r[t.id] = !0), u = !0, o[n.id] = !0;
                            break
                        } if (u) break
                }
            }
            const i = {};
            i[n.id] = !0;
            const s = {};
            for (let a = t.length - 1; a >= 0; a--) {
                const e = t[a],
                    n = e.inputs;
                for (let t = 0; t < e.outputs.length; t++)
                    if (i[e.outputs[t].id]) {
                        for (const t in n) i[n[t].id] = !0, s[e.id] = !0;
                        break
                    }
            }
            const u = [];
            for (let a = 0; a < t.length; a++) {
                const e = t[a];
                if (o[e.id] && s[e.id]) {
                    const t = {};
                    for (const o in e.inputs) {
                        const n = e.inputs[o];
                        r[n.id] && (t[o] = n)
                    }
                    const n = Object.assign({}, e);
                    n.inputs = t, n.outputs = e.outputs, u.push(n)
                }
            }
            return u
        }

        function o(e, n, r) {
            for (let o = n.length - 1; o >= 0; o--) {
                const i = n[o],
                    s = [];
                if (i.outputs.forEach(t => {
                        const n = e[t.id];
                        null != n ? s.push(n) : s.push(null)
                    }), null == i.gradient) throw new Error("Cannot compute gradient: gradient function not found " + `for ${i.kernelName}.`);
                const u = i.gradient(s);
                for (const n in i.inputs) {
                    if (!(n in u)) throw new Error(`Cannot backprop through input ${n}. ` + `Available gradients found: ${Object.keys(u)}.`);
                    const o = r(() => u[n]());
                    if ("float32" !== o.dtype) throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ` + `${n} must have 'float32' dtype, but has '${o.dtype}'`);
                    const s = i.inputs[n];
                    if (!t.arraysEqual(o.shape, s.shape)) throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ` + `'${n}' has shape '${o.shape}', which does not match ` + `the shape of the input '${s.shape}'`);
                    if (null == e[s.id]) e[s.id] = o;
                    else {
                        const t = e[s.id];
                        e[s.id] = t.add(o), t.dispose()
                    }
                }
            }
        }
    }, {
        "./util": "P6nv"
    }],
    "GKxW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensorToString = o;
        var e = require("./util");
        const t = 20,
            r = 3,
            n = 7;

        function o(t, r, n, o) {
            const l = (0, e.computeStrides)(r),
                i = s(t, r, n, l),
                c = r.length,
                p = u(t, r, n, l, i),
                a = ["Tensor"];
            return o && (a.push(`  dtype: ${n}`), a.push(`  rank: ${c}`), a.push(`  shape: [${r}]`), a.push("  values:")), a.push(p.map(e => "    " + e).join("\n")), a.join("\n")
        }

        function s(t, r, n, o) {
            const s = (0, e.sizeFromShape)(r),
                i = o[o.length - 1],
                u = new Array(i).fill(0),
                p = r.length,
                a = "complex64" === n ? c(t) : t;
            if (p > 1)
                for (let e = 0; e < s / i; e++) {
                    const t = e * i;
                    for (let e = 0; e < i; e++) u[e] = Math.max(u[e], l(a[t + e], 0, n).length)
                }
            return u
        }

        function l(t, r, o) {
            let s;
            return s = Array.isArray(t) ? `${parseFloat(t[0].toFixed(n))} + ` + `${parseFloat(t[1].toFixed(n))}j` : (0, e.isString)(t) ? `'${t}'` : "bool" === o ? i(t) : parseFloat(t.toFixed(n)).toString(), (0, e.rightPad)(s, r)
        }

        function i(e) {
            return 0 === e ? "false" : "true"
        }

        function u(e, n, o, s, p, a = !0) {
            const f = "complex64" === o ? 2 : 1,
                h = n[0],
                m = n.length;
            if (0 === m) {
                if ("complex64" === o) {
                    return [l(c(e)[0], 0, o)]
                }
                return "bool" === o ? [i(e[0])] : [e[0].toString()]
            }
            if (1 === m) {
                if (h > t) {
                    const t = r * f;
                    let n = Array.from(e.slice(0, t)),
                        s = Array.from(e.slice((h - r) * f, h * f));
                    return "complex64" === o && (n = c(n), s = c(s)), ["[" + n.map((e, t) => l(e, p[t], o)).join(", ") + ", ..., " + s.map((e, t) => l(e, p[h - r + t], o)).join(", ") + "]"]
                }
                return ["[" + ("complex64" === o ? c(e) : Array.from(e)).map((e, t) => l(e, p[t], o)).join(", ") + "]"]
            }
            const g = n.slice(1),
                x = s.slice(1),
                d = s[0] * f,
                y = [];
            if (h > t) {
                for (let t = 0; t < r; t++) {
                    const r = t * d,
                        n = r + d;
                    y.push(...u(e.slice(r, n), g, o, x, p, !1))
                }
                y.push("...");
                for (let t = h - r; t < h; t++) {
                    const r = t * d,
                        n = r + d;
                    y.push(...u(e.slice(r, n), g, o, x, p, t === h - 1))
                }
            } else
                for (let t = 0; t < h; t++) {
                    const r = t * d,
                        n = r + d;
                    y.push(...u(e.slice(r, n), g, o, x, p, t === h - 1))
                }
            const j = 2 === m ? "," : "";
            y[0] = "[" + y[0] + j;
            for (let t = 1; t < y.length - 1; t++) y[t] = " " + y[t] + j;
            let F = ",\n";
            for (let t = 2; t < m; t++) F += "\n";
            return y[y.length - 1] = " " + y[y.length - 1] + "]" + (a ? "" : F), y
        }

        function c(e) {
            const t = [];
            for (let r = 0; r < e.length; r += 2) t.push([e[r], e[r + 1]]);
            return t
        }
    }, {
        "./util": "P6nv"
    }],
    "DTHt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.setTensorTracker = h, exports.setOpHandler = d, exports.setDeprecationWarningFn = p, exports.Variable = exports.Tensor = exports.TensorBuffer = void 0;
        var t = require("./tensor_format"),
            e = r(require("./util"));

        function s() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return s = function() {
                return t
            }, t
        }

        function r(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var e = s();
            if (e && e.has(t)) return e.get(t);
            var r = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in t)
                if (Object.prototype.hasOwnProperty.call(t, n)) {
                    var a = i ? Object.getOwnPropertyDescriptor(t, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = t[n]
                } return r.default = t, e && e.set(t, r), r
        }
        class i {
            constructor(t, s, r) {
                if (this.dtype = s, this.shape = t.slice(), this.size = e.sizeFromShape(t), null != r) {
                    const t = r.length;
                    e.assert(t === this.size, () => `Length of values '${t}' does not match the size ` + `inferred by the shape '${this.size}'.`)
                }
                if ("complex64" === s) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
                this.values = r || e.getArrayFromDType(s, this.size), this.strides = (0, e.computeStrides)(t)
            }
            set(t, ...s) {
                0 === s.length && (s = [0]), e.assert(s.length === this.rank, () => `The number of provided coordinates (${s.length}) must ` + `match the rank (${this.rank})`);
                const r = this.locToIndex(s);
                this.values[r] = t
            }
            get(...t) {
                0 === t.length && (t = [0]);
                let e = 0;
                for (const r of t) {
                    if (r < 0 || r >= this.shape[e]) {
                        const e = `Requested out of range element at ${t}. ` + `  Buffer shape=${this.shape}`;
                        throw new Error(e)
                    }
                    e++
                }
                let s = t[t.length - 1];
                for (let r = 0; r < t.length - 1; ++r) s += this.strides[r] * t[r];
                return this.values[s]
            }
            locToIndex(t) {
                if (0 === this.rank) return 0;
                if (1 === this.rank) return t[0];
                let e = t[t.length - 1];
                for (let s = 0; s < t.length - 1; ++s) e += this.strides[s] * t[s];
                return e
            }
            indexToLoc(t) {
                if (0 === this.rank) return [];
                if (1 === this.rank) return [t];
                const e = new Array(this.shape.length);
                for (let s = 0; s < e.length - 1; ++s) e[s] = Math.floor(t / this.strides[s]), t -= e[s] * this.strides[s];
                return e[e.length - 1] = t, e
            }
            get rank() {
                return this.shape.length
            }
            toTensor() {
                return n().makeTensor(this.values, this.shape, this.dtype)
            }
        }
        exports.TensorBuffer = i;
        let n = null,
            a = null,
            o = null;

        function h(t) {
            n = t
        }

        function d(t) {
            a = t
        }

        function p(t) {
            o = t
        }
        class l {
            constructor(t, s, r, i) {
                this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = s || "float32", this.size = e.sizeFromShape(t), this.strides = (0, e.computeStrides)(t), this.dataId = r, this.id = i, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
            }
            get rank() {
                return this.shape.length
            }
            async buffer() {
                const t = await this.data();
                return a.buffer(this.shape, this.dtype, t)
            }
            bufferSync() {
                return a.buffer(this.shape, this.dtype, this.dataSync())
            }
            async array() {
                const t = await this.data();
                return (0, e.toNestedArray)(this.shape, t)
            }
            arraySync() {
                return (0, e.toNestedArray)(this.shape, this.dataSync())
            }
            async data() {
                this.throwIfDisposed();
                const t = n().read(this.dataId);
                if ("string" === this.dtype) {
                    const r = await t;
                    try {
                        return r.map(t => e.decodeString(t))
                    } catch (s) {
                        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                    }
                }
                return t
            }
            dataSync() {
                this.throwIfDisposed();
                const t = n().readSync(this.dataId);
                if ("string" === this.dtype) try {
                    return t.map(t => e.decodeString(t))
                } catch (s) {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
                return t
            }
            async bytes() {
                this.throwIfDisposed();
                const t = await n().read(this.dataId);
                return "string" === this.dtype ? t : new Uint8Array(t.buffer)
            }
            dispose() {
                this.isDisposed || (n().disposeTensor(this), this.isDisposedInternal = !0)
            }
            get isDisposed() {
                return this.isDisposedInternal
            }
            throwIfDisposed() {
                if (this.isDisposed) throw new Error("Tensor is disposed.")
            }
            print(t = !1) {
                return a.print(this, t)
            }
            clone() {
                return this.throwIfDisposed(), a.clone(this)
            }
            toString(e = !1) {
                const s = this.dataSync();
                return (0, t.tensorToString)(s, this.shape, this.dtype, e)
            }
            cast(t) {
                return this.throwIfDisposed(), a.cast(this, t)
            }
            variable(t = !0, e, s) {
                return this.throwIfDisposed(), n().makeVariable(this, t, e, s)
            }
        }
        exports.Tensor = l, Object.defineProperty(l, Symbol.hasInstance, {
            value: t => !!t && null != t.dataId && null != t.shape && null != t.dtype
        });
        class u extends l {
            constructor(t, e, s, r) {
                super(t.shape, t.dtype, t.dataId, r), this.trainable = e, this.name = s
            }
            assign(t) {
                if (t.dtype !== this.dtype) throw new Error(`dtype of the new value (${t.dtype}) and ` + `previous value (${this.dtype}) must match`);
                if (!e.arraysEqual(t.shape, this.shape)) throw new Error(`shape of the new value (${t.shape}) and ` + `previous value (${this.shape}) must match`);
                n().disposeTensor(this), this.dataId = t.dataId, n().incRef(this, null)
            }
            dispose() {
                n().disposeVariable(this), this.isDisposedInternal = !0
            }
        }
        exports.Variable = u, Object.defineProperty(u, Symbol.hasInstance, {
            value: t => t instanceof l && null != t.assign && t.assign instanceof Function
        });
    }, {
        "./tensor_format": "GKxW",
        "./util": "P6nv"
    }],
    "Grh1": [function(require, module, exports) {
        "use strict";
        var o, t, n, e, l;
        Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.upcastType = r, exports.sumOutType = c, exports.Rank = void 0, exports.Rank = o,
            function(o) {
                o.R0 = "R0", o.R1 = "R1", o.R2 = "R2", o.R3 = "R3", o.R4 = "R4", o.R5 = "R5", o.R6 = "R6"
            }(o || (exports.Rank = o = {})),
            function(o) {
                o.float32 = "float32", o.int32 = "int32", o.bool = "int32", o.complex64 = "complex64"
            }(t || (t = {})),
            function(o) {
                o.float32 = "float32", o.int32 = "int32", o.bool = "bool", o.complex64 = "complex64"
            }(n || (n = {})),
            function(o) {
                o.float32 = "float32", o.int32 = "float32", o.bool = "float32", o.complex64 = "complex64"
            }(e || (e = {})),
            function(o) {
                o.float32 = "complex64", o.int32 = "complex64", o.bool = "complex64", o.complex64 = "complex64"
            }(l || (l = {}));
        const i = {
            float32: e,
            int32: t,
            bool: n,
            complex64: l
        };

        function r(o, t) {
            if ("string" === o || "string" === t) {
                if ("string" === o && "string" === t) return "string";
                throw new Error(`Can not upcast ${o} with ${t}`)
            }
            return i[o][t]
        }

        function c(o) {
            return r(o, "int32")
        }
    }, {}],
    "fpST": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.makeTypesMatch = n, exports.assertTypesMatch = s, exports.isTensorInList = o, exports.getTensorsInContainer = i;
        var t = require("./tensor"),
            e = require("./types"),
            r = require("./util");

        function n(t, r) {
            if (t.dtype === r.dtype) return [t, r];
            const n = (0, e.upcastType)(t.dtype, r.dtype);
            return [t.cast(n), r.cast(n)]
        }

        function s(t, e) {
            (0, r.assert)(t.dtype === e.dtype, () => `The dtypes of the first(${t.dtype}) and` + ` second(${e.dtype}) input must match`)
        }

        function o(t, e) {
            return e.some(e => e.id === t.id)
        }

        function i(t) {
            const e = [];
            return u(t, e, new Set), e
        }

        function u(e, r, n) {
            if (null == e) return;
            if (e instanceof t.Tensor) return void r.push(e);
            if (!p(e)) return;
            const s = e;
            for (const t in s) {
                const e = s[t];
                n.has(e) || (n.add(e), u(e, r, n))
            }
        }

        function p(t) {
            return Array.isArray(t) || "object" == typeof t
        }
    }, {
        "./tensor": "DTHt",
        "./types": "Grh1",
        "./util": "P6nv"
    }],
    "Nc3Y": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ENGINE = exports.Engine = void 0;
        var e = require("./environment"),
            t = require("./global_util"),
            s = require("./kernel_registry"),
            n = require("./profiler"),
            r = require("./tape"),
            a = require("./tensor"),
            i = require("./tensor_util"),
            o = h(require("./util"));

        function c() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return c = function() {
                return e
            }, e
        }

        function h(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = c();
            if (t && t.has(e)) return t.get(e);
            var s = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, r) : null;
                    a && (a.get || a.set) ? Object.defineProperty(s, r, a) : s[r] = e[r]
                } return s.default = e, t && t.set(e, s), s
        }
        class d {
            constructor() {
                this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
                    newBytes: 0,
                    newTensors: 0,
                    peakBytes: 0,
                    kernels: [],
                    result: null
                }
            }
            dispose() {
                for (const e in this.registeredVariables) this.registeredVariables[e].dispose()
            }
        }
        class l {
            constructor(e) {
                this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new d
            }
            async ready() {
                if (null != this.pendingBackendInit) return this.pendingBackendInit.then(() => {});
                if (null != this.backendInstance) return;
                const e = this.getSortedBackends();
                for (let t = 0; t < e.length; t++) {
                    const s = e[t];
                    if (await this.initializeBackend(s).success) return void(await this.setBackend(s))
                }
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }
            get backend() {
                if (null != this.pendingBackendInit) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` + "sure to await tf.ready() or await tf.setBackend() before calling other methods");
                if (null == this.backendInstance) {
                    const {
                        name: e,
                        asyncInit: t
                    } = this.initializeBackendsAndReturnBest();
                    if (t) throw new Error(`The highest priority backend '${e}' has not yet been ` + "initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                    this.setBackend(e)
                }
                return this.backendInstance
            }
            backendNames() {
                return Object.keys(this.registryFactory)
            }
            findBackend(e) {
                if (!(e in this.registry)) {
                    if (!(e in this.registryFactory)) return null; {
                        const {
                            asyncInit: t
                        } = this.initializeBackend(e);
                        if (t) return null
                    }
                }
                return this.registry[e]
            }
            findBackendFactory(e) {
                return e in this.registryFactory ? this.registryFactory[e].factory : null
            }
            registerBackend(e, t, s = 1) {
                return e in this.registryFactory ? (console.warn(`${e} backend was already registered. ` + "Reusing existing backend factory."), !1) : (this.registryFactory[e] = {
                    factory: t,
                    priority: s
                }, !0)
            }
            async setBackend(e) {
                if (null == this.registryFactory[e]) throw new Error(`Backend name '${e}' not found in registry`);
                if (this.backendName = e, null == this.registry[e]) {
                    this.backendInstance = null;
                    const {
                        success: t,
                        asyncInit: s
                    } = this.initializeBackend(e);
                    if (!(s ? await t : t)) return !1
                }
                return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new n.Profiler(this.backendInstance), !0
            }
            setupRegisteredKernels() {
                (0, s.getKernelsForBackend)(this.backendName).forEach(e => {
                    null != e.setupFunc && e.setupFunc(this.backendInstance)
                })
            }
            disposeRegisteredKernels(e) {
                (0, s.getKernelsForBackend)(e).forEach(t => {
                    null != t.disposeFunc && t.disposeFunc(this.registry[e])
                })
            }
            initializeBackend(e) {
                const t = this.registryFactory[e];
                if (null == t) throw new Error(`Cannot initialize backend ${e}, no registration found.`);
                try {
                    const n = t.factory();
                    if (Promise.resolve(n) === n) {
                        const t = ++this.pendingBackendInitId,
                            s = n.then(s => !(t < this.pendingBackendInitId) && (this.registry[e] = s, this.pendingBackendInit = null, !0)).catch(s => !(t < this.pendingBackendInitId) && (this.pendingBackendInit = null, console.warn(`Initialization of backend ${e} failed`), console.warn(s.stack || s.message), !1));
                        return this.pendingBackendInit = s, {
                            success: s,
                            asyncInit: !0
                        }
                    }
                    return this.registry[e] = n, {
                        success: !0,
                        asyncInit: !1
                    }
                } catch (s) {
                    return console.warn(`Initialization of backend ${e} failed`), console.warn(s.stack || s.message), {
                        success: !1,
                        asyncInit: !1
                    }
                }
            }
            removeBackend(e) {
                if (!(e in this.registryFactory)) throw new Error(`${e} backend not found in registry`);
                this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
            }
            getSortedBackends() {
                if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
                return Object.keys(this.registryFactory).sort((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority)
            }
            initializeBackendsAndReturnBest() {
                const e = this.getSortedBackends();
                for (let t = 0; t < e.length; t++) {
                    const s = e[t],
                        {
                            success: n,
                            asyncInit: r
                        } = this.initializeBackend(s);
                    if (r || n) return {
                        name: s,
                        asyncInit: r
                    }
                }
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }
            moveData(e, t) {
                const s = this.state.tensorInfo.get(t),
                    n = s.backend,
                    r = this.readSync(t);
                n.disposeData(t), s.backend = e, e.move(t, r, s.shape, s.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
            }
            tidy(e, t) {
                let s, n = null;
                if (null == t) {
                    if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
                    t = e
                } else {
                    if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
                    if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
                    n = e
                }
                return this.scopedRun(() => this.startScope(n), () => this.endScope(s), () => ((s = t()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), s))
            }
            scopedRun(e, t, s) {
                e();
                try {
                    const e = s();
                    return t(), e
                } catch (n) {
                    throw t(), n
                }
            }
            nextTensorId() {
                return l.nextTensorId++
            }
            nextVariableId() {
                return l.nextVariableId++
            }
            clone(e) {
                const t = this.makeTensorFromDataId(e.dataId, e.shape, e.dtype),
                    s = {
                        x: e
                    };
                return this.addTapeNode(this.state.activeScope.name, s, [t], e => ({
                    x: () => e.toFloat()
                }), [], {}), t
            }
            runKernel(e, t, s, n, r) {
                return this.runKernelFunc(null, t, null, e, s, n, r)
            }
            shouldCheckForMemLeaks() {
                return this.ENV.getBool("IS_TEST")
            }
            checkKernelForMemLeak(e, t, s) {
                const n = this.backend.numDataIds();
                let r = 0;
                s.forEach(e => {
                    r += "complex64" === e.dtype ? 3 : 1
                });
                const a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
                    i = n - t - r - a;
                if (i > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak ` + `(${i} data ids) after running '${e}'`)
            }
            runKernelFunc(e, t, n, r, a, i, o) {
                let c, h = [];
                const d = this.isTapeOn();
                null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");
                const l = this.state.numBytes,
                    u = this.state.numTensors;
                let p;
                this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
                const f = (0, s.getKernel)(r, this.backendName);
                let y;
                if (null != f) p = (() => {
                    const e = this.backend.numDataIds();
                    y = f.kernelFunc({
                        inputs: t,
                        attrs: a,
                        backend: this.backend
                    });
                    const s = Array.isArray(y) ? y : [y];
                    this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(r, e, s);
                    const n = s.map(({
                        dataId: e,
                        shape: t,
                        dtype: s
                    }) => this.makeTensorFromDataId(e, t, s));
                    if (d) {
                        let e = this.getTensorsForGradient(r, t, n);
                        if (null == e) {
                            null == o && (o = []);
                            const t = n.filter((e, t) => o[t]);
                            e = (i || []).slice().concat(t)
                        }
                        h = this.saveTensorsForBackwardMode(e)
                    }
                    return n
                });
                else {
                    const t = e => {
                        d && (h = e.map(e => this.keep(this.clone(e))))
                    };
                    p = (() => {
                        const s = this.backend.numDataIds();
                        y = this.tidy(() => e(this.backend, t));
                        const n = Array.isArray(y) ? y : [y];
                        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(r, s, n), n
                    })
                }
                return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
                    if (this.ENV.getBool("DEBUG")) {
                        let e;
                        e = this.profiler.profileKernel(r, t, () => p()), this.profiler.logKernelProfile(e), c = e.outputs
                    } else c = p()
                }), d && this.addTapeNode(r, t, c, n, h, a), this.state.profiling && this.state.activeProfile.kernels.push({
                    name: r,
                    bytesAdded: this.state.numBytes - l,
                    totalBytesSnapshot: this.state.numBytes,
                    tensorsAdded: this.state.numTensors - u,
                    totalTensorsSnapshot: this.state.numTensors,
                    inputShapes: Object.keys(t).map(e => null != t[e] ? t[e].shape : null),
                    outputShapes: c.map(e => e.shape)
                }), Array.isArray(y) ? c : c[0]
            }
            saveTensorsForBackwardMode(e) {
                return e.map(e => this.keep(this.clone(e)))
            }
            getTensorsForGradient(e, t, n) {
                const r = (0, s.getGradient)(e);
                if (null != r) {
                    const e = r.inputsToSave || [],
                        s = r.outputsToSave || [];
                    let a;
                    r.saveAllInputs ? (o.assert(Array.isArray(t), () => "saveAllInputs is true, expected inputs to be an array."), a = Object.keys(t).map(e => t[e])) : a = e.map(e => t[e]);
                    const i = n.filter((e, t) => s[t]);
                    return a.concat(i)
                }
                return null
            }
            makeTensor(e, t, s, n) {
                if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
                s = s || "float32", n = n || this.backend;
                let r = e;
                "string" === s && o.isString(e[0]) && (r = e.map(e => o.encodeString(e)));
                const i = n.write(r, t, s),
                    c = new a.Tensor(t, s, i, this.nextTensorId());
                if (this.incRef(c, n), "string" === s) {
                    const e = this.state.tensorInfo.get(i),
                        t = (0, o.bytesFromStringArray)(r);
                    this.state.numBytes += t - e.bytes, e.bytes = t
                }
                return c
            }
            makeTensorFromDataId(e, t, s, n) {
                s = s || "float32";
                const r = new a.Tensor(t, s, e, this.nextTensorId());
                return this.incRef(r, n), r
            }
            makeVariable(e, t = !0, s, n) {
                s = s || this.nextVariableId().toString(), null != n && n !== e.dtype && (e = e.cast(n));
                const r = new a.Variable(e, t, s, this.nextTensorId());
                if (null != this.state.registeredVariables[r.name]) throw new Error(`Variable with name ${r.name} was already registered`);
                return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r
            }
            incRef(e, t) {
                const s = this.state.tensorInfo.has(e.dataId) ? this.state.tensorInfo.get(e.dataId).refCount : 0;
                if (this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++, 0 === s) {
                    this.state.numDataBuffers++;
                    let s = 0;
                    "complex64" !== e.dtype && "string" !== e.dtype && (s = e.size * o.bytesPerElement(e.dtype)), this.state.tensorInfo.set(e.dataId, {
                        backend: t || this.backend,
                        dtype: e.dtype,
                        shape: e.shape,
                        bytes: s,
                        refCount: 0
                    }), this.state.numBytes += s
                }
                this.state.tensorInfo.get(e.dataId).refCount++, e instanceof a.Variable || this.track(e)
            }
            disposeTensor(e) {
                if (!this.state.tensorInfo.has(e.dataId)) return;
                this.state.numTensors--, "string" === e.dtype && this.state.numStringTensors--;
                const t = this.state.tensorInfo.get(e.dataId);
                t.refCount <= 1 ? ("complex64" !== e.dtype && (this.state.numBytes -= t.bytes), this.state.numDataBuffers--, t.backend.disposeData(e.dataId), this.state.tensorInfo.delete(e.dataId)) : this.state.tensorInfo.get(e.dataId).refCount--
            }
            disposeVariables() {
                for (const e in this.state.registeredVariables) {
                    const t = this.state.registeredVariables[e];
                    this.disposeVariable(t)
                }
            }
            disposeVariable(e) {
                this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name]
            }
            memory() {
                const e = this.backend.memory();
                return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e
            }
            async profile(e) {
                this.state.profiling = !0;
                const t = this.state.numBytes,
                    s = this.state.numTensors;
                return this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(e => e.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - s, this.state.activeProfile
            }
            isTapeOn() {
                return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
            }
            addTapeNode(e, t, n, r, a, i) {
                const c = {
                        id: this.state.nextTapeNodeId++,
                        kernelName: e,
                        inputs: t,
                        outputs: n,
                        saved: a
                    },
                    h = (0, s.getGradient)(e);
                null != h && (r = h.gradFunc), null != r && (c.gradient = (e => (e = e.map((e, t) => {
                    if (null == e) {
                        const e = n[t],
                            s = o.makeZerosTypedArray(e.size, e.dtype);
                        return this.makeTensor(s, e.shape, e.dtype)
                    }
                    return e
                }), r(e.length > 1 ? e : e[0], a, i)))), this.state.activeTape.push(c)
            }
            keep(e) {
                return e.kept = !0, e
            }
            startTape() {
                0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
            }
            endTape() {
                this.state.gradientDepth--
            }
            startScope(e) {
                const t = {
                    track: [],
                    name: "unnamed scope",
                    id: this.state.nextScopeId++
                };
                e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t
            }
            endScope(e) {
                const t = (0, i.getTensorsInContainer)(e),
                    s = new Set(t.map(e => e.id));
                for (let r = 0; r < this.state.activeScope.track.length; r++) {
                    const e = this.state.activeScope.track[r];
                    e.kept || s.has(e.id) || e.dispose()
                }
                const n = this.state.scopeStack.pop();
                this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach(e => {
                    e.kept || e.scopeId !== n.id || this.track(e)
                })
            }
            gradients(e, t, s, n = !1) {
                if (o.assert(t.length > 0, () => "gradients() received an empty list of xs."), null != s && "float32" !== s.dtype) throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);
                const i = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
                o.assert(i instanceof a.Tensor, () => "The result y returned by f() must be a tensor.");
                const c = (0, r.getFilteredNodesXToY)(this.state.activeTape, t, i);
                if (!n && 0 === c.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
                return this.tidy("backward", () => {
                    const e = {};
                    e[i.id] = null == s ? u(i.shape) : s, (0, r.backpropagateGradients)(e, c, e => this.tidy(e));
                    const n = t.map(t => e[t.id]);
                    return 0 === this.state.gradientDepth && (this.state.activeTape.forEach(e => {
                        for (const t of e.saved) t.dispose()
                    }), this.state.activeTape = null), {
                        value: i,
                        grads: n
                    }
                })
            }
            customGrad(e) {
                return o.assert(o.isFunction(e), () => "The f passed in customGrad(f) must be a function."), (...t) => {
                    let s;
                    o.assert(t.every(e => e instanceof a.Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
                    const n = {};
                    return t.forEach((e, t) => {
                        n[t] = e
                    }), this.runKernelFunc((n, r) => (s = e(...t, r), o.assert(s.value instanceof a.Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), o.assert(o.isFunction(s.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), s.value), n, (e, n) => {
                        const r = s.gradFunc(e, n),
                            i = Array.isArray(r) ? r : [r];
                        o.assert(i.length === t.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), o.assert(i.every(e => e instanceof a.Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
                        const c = {};
                        return i.forEach((e, t) => {
                            c[t] = (() => e)
                        }), c
                    })
                }
            }
            readSync(e) {
                return this.state.tensorInfo.get(e).backend.readSync(e)
            }
            read(e) {
                return this.state.tensorInfo.get(e).backend.read(e)
            }
            async time(e) {
                const t = (0, o.now)(),
                    s = await this.backend.time(e);
                return s.wallMs = (0, o.now)() - t, s
            }
            track(e) {
                return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e
            }
            get registeredVariables() {
                return this.state.registeredVariables
            }
            reset() {
                this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new d;
                for (const e in this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
                this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
            }
        }

        function u(e) {
            const t = (0, o.makeOnesTypedArray)((0, o.sizeFromShape)(e), "float32");
            return f.makeTensor(t, e, "float32")
        }

        function p() {
            const s = (0, t.getGlobalNamespace)();
            if (null == s._tfengine) {
                const t = new e.Environment(s);
                s._tfengine = new l(t)
            }
            return (0, e.setEnvironmentGlobal)(s._tfengine.ENV), (0, a.setTensorTracker)(() => s._tfengine), s._tfengine
        }
        exports.Engine = l, l.nextTensorId = 0, l.nextVariableId = 0;
        const f = p();
        exports.ENGINE = f;
    }, {
        "./environment": "Fbeg",
        "./global_util": "QcKL",
        "./kernel_registry": "wJg6",
        "./profiler": "LCLi",
        "./tape": "ugac",
        "./tensor": "DTHt",
        "./tensor_util": "fpST",
        "./util": "P6nv"
    }],
    "GUPw": [function(require, module, exports) {
        "use strict";

        function e() {
            return "undefined" != typeof navigator && null != navigator
        }

        function i() {
            if (e()) {
                const e = navigator.userAgent || navigator.vendor || window.opera;
                return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))
            }
            return !1
        }

        function o() {
            return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isMobile = i, exports.isBrowser = o;
    }, {}],
    "BElI": [function(require, module, exports) {
        var process = require("process");
        var e = require("process"),
            r = o(require("./device_util")),
            t = require("./environment");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = n();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, i, a) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }
        const i = (0, t.env)();
        i.registerFlag("DEBUG", () => !1, e => {
            e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
        }), i.registerFlag("IS_BROWSER", () => r.isBrowser()), i.registerFlag("IS_NODE", () => void 0 !== e && void 0 !== e.versions && void 0 !== e.versions.node), i.registerFlag("IS_CHROME", () => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)), i.registerFlag("PROD", () => !1), i.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => i.getBool("DEBUG")), i.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0), i.registerFlag("IS_TEST", () => !1);
    }, {
        "./device_util": "GUPw",
        "./environment": "Fbeg",
        "process": "g5IB"
    }],
    "sdEe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Prelu = exports.Pow = exports.Pool = exports.PadV2 = exports.OneHot = exports.OnesLike = exports.NonMaxSuppressionV5 = exports.NonMaxSuppressionV4 = exports.NonMaxSuppressionV3 = exports.NotEqual = exports.Negate = exports.Multiply = exports.Mod = exports.Minimum = exports.Min = exports.Mean = exports.MaxPoolWithArgmax = exports.MaxPool3DBackprop = exports.MaxPool3D = exports.MaxPoolBackprop = exports.MaxPool = exports.Maximum = exports.Max = exports.LRNBackprop = exports.LRN = exports.LogSoftmax = exports.LogicalOr = exports.LogicalNot = exports.LogicalAnd = exports.Log1p = exports.Log = exports.LinSpace = exports.LessEqual = exports.Less = exports.IsNan = exports.IsInf = exports.IsFinite = exports.Imag = exports.IFFT = exports.Identity = exports.GreaterEqual = exports.Greater = exports.GatherNd = exports.GatherV2 = exports.FusedBatchNorm = exports.Fill = exports.FloorDiv = exports.Floor = exports.FFT = exports.Expm1 = exports.Exp = exports.Equal = exports.Erf = exports.EluGrad = exports.Elu = exports.Div = exports.Dilation2DBackpropFilter = exports.Dilation2DBackpropInput = exports.Dilation2D = exports.Diag = exports.DepthwiseConv2dNativeBackpropInput = exports.DepthwiseConv2dNativeBackpropFilter = exports.DepthwiseConv2dNative = exports.DepthToSpace = exports.CropAndResize = exports.Cumsum = exports.Cosh = exports.Cos = exports.Conv3DBackpropInputV2 = exports.Conv3DBackpropFilterV2 = exports.Conv3D = exports.Conv2DBackpropInput = exports.Conv2DBackpropFilter = exports.Conv2D = exports.Concat = exports.Complex = exports.ClipByValue = exports.Ceil = exports.Cast = exports.BroadcastTo = exports.BatchToSpaceND = exports.BatchMatMul = exports.AvgPool3DBackprop = exports.AvgPool3D = exports.AvgPoolBackprop = exports.AvgPool = exports.Atan2 = exports.Atanh = exports.Atan = exports.Asinh = exports.Asin = exports.ArgMin = exports.ArgMax = exports.Any = exports.All = exports.AddN = exports.Add = exports.Acosh = exports.Acos = exports.Abs = void 0, exports.FusedDepthwiseConv2D = exports.FusedConv2D = exports._FusedMatMul = exports.RotateWithOffset = exports.FromPixels = exports.Step = exports.ZerosLike = exports.UnsortedSegmentSum = exports.Unpack = exports.Transpose = exports.TopK = exports.Tile = exports.Tanh = exports.Tan = exports.StridedSlice = exports.SparseToDense = exports.Sub = exports.Square = exports.SquaredDifference = exports.Softmax = exports.SplitV = exports.SpaceToBatchND = exports.Sum = exports.Sqrt = exports.Softplus = exports.Sigmoid = exports.Sign = exports.Sinh = exports.Sin = exports.Slice = exports.Selu = exports.SelectV2 = exports.ScatterNd = exports.Rsqrt = exports.Round = exports.Reverse = exports.Relu6 = exports.ResizeBilinearGrad = exports.ResizeBilinear = exports.ResizeNearestNeighborGrad = exports.ResizeNearestNeighbor = exports.Reshape = exports.Relu = exports.Reciprocal = exports.Real = exports.Range = exports.Prod = void 0;
        const o = "Abs";
        exports.Abs = o;
        const t = "Acos";
        exports.Acos = t;
        const e = "Acosh";
        exports.Acosh = e;
        const s = "Add";
        exports.Add = s;
        const r = "AddN";
        exports.AddN = r;
        const p = "All";
        exports.All = p;
        const x = "Any";
        exports.Any = x;
        const n = "ArgMax";
        exports.ArgMax = n;
        const a = "ArgMin";
        exports.ArgMin = a;
        const c = "Asin";
        exports.Asin = c;
        const i = "Asinh";
        exports.Asinh = i;
        const l = "Atan";
        exports.Atan = l;
        const u = "Atanh";
        exports.Atanh = u;
        const d = "Atan2";
        exports.Atan2 = d;
        const D = "AvgPool";
        exports.AvgPool = D;
        const S = "AvgPoolBackprop";
        exports.AvgPoolBackprop = S;
        const g = "AvgPool3D";
        exports.AvgPool3D = g;
        const h = "AvgPool3DBackprop";
        exports.AvgPool3DBackprop = h;
        const v = "BatchMatMul";
        exports.BatchMatMul = v;
        const N = "BatchToSpaceND";
        exports.BatchToSpaceND = N;
        const M = "BroadcastTo";
        exports.BroadcastTo = M;
        const A = "Cast";
        exports.Cast = A;
        const B = "Ceil";
        exports.Ceil = B;
        const C = "ClipByValue";
        exports.ClipByValue = C;
        const m = "Complex";
        exports.Complex = m;
        const F = "Concat";
        exports.Concat = F;
        const R = "Conv2D";
        exports.Conv2D = R;
        const k = "Conv2DBackpropFilter";
        exports.Conv2DBackpropFilter = k;
        const P = "Conv2DBackpropInput";
        exports.Conv2DBackpropInput = P;
        const L = "Conv3D";
        exports.Conv3D = L;
        const T = "Conv3DBackpropFilterV2";
        exports.Conv3DBackpropFilterV2 = T;
        const I = "Conv3DBackpropInputV2";
        exports.Conv3DBackpropInputV2 = I;
        const V = "Cos";
        exports.Cos = V;
        const f = "Cosh";
        exports.Cosh = f;
        const E = "Cumsum";
        exports.Cumsum = E;
        const q = "CropAndResize";
        exports.CropAndResize = q;
        const G = "DepthToSpace";
        exports.DepthToSpace = G;
        const w = "DepthwiseConv2dNative";
        exports.DepthwiseConv2dNative = w;
        const z = "DepthwiseConv2dNativeBackpropFilter";
        exports.DepthwiseConv2dNativeBackpropFilter = z;
        const b = "DepthwiseConv2dNativeBackpropInput";
        exports.DepthwiseConv2dNativeBackpropInput = b;
        const y = "Diag";
        exports.Diag = y;
        const O = "Dilation2D";
        exports.Dilation2D = O;
        const U = "Dilation2DBackpropInput";
        exports.Dilation2DBackpropInput = U;
        const W = "Dilation2DBackpropFilter";
        exports.Dilation2DBackpropFilter = W;
        const _ = "Div";
        exports.Div = _;
        const H = "Elu";
        exports.Elu = H;
        const K = "EluGrad";
        exports.EluGrad = K;
        const Z = "Erf";
        exports.Erf = Z;
        const j = "Equal";
        exports.Equal = j;
        const J = "Exp";
        exports.Exp = J;
        const Q = "Expm1";
        exports.Expm1 = Q;
        const X = "FFT";
        exports.FFT = X;
        const Y = "Floor";
        exports.Floor = Y;
        const $ = "FloorDiv";
        exports.FloorDiv = $;
        const oo = "Fill";
        exports.Fill = oo;
        const to = "FusedBatchNorm";
        exports.FusedBatchNorm = to;
        const eo = "GatherV2";
        exports.GatherV2 = eo;
        const so = "GatherNd";
        exports.GatherNd = so;
        const ro = "Greater";
        exports.Greater = ro;
        const po = "GreaterEqual";
        exports.GreaterEqual = po;
        const xo = "Identity";
        exports.Identity = xo;
        const no = "IFFT";
        exports.IFFT = no;
        const ao = "Imag";
        exports.Imag = ao;
        const co = "IsFinite";
        exports.IsFinite = co;
        const io = "IsInf";
        exports.IsInf = io;
        const lo = "IsNan";
        exports.IsNan = lo;
        const uo = "Less";
        exports.Less = uo;
        const Do = "LessEqual";
        exports.LessEqual = Do;
        const So = "LinSpace";
        exports.LinSpace = So;
        const go = "Log";
        exports.Log = go;
        const ho = "Log1p";
        exports.Log1p = ho;
        const vo = "LogicalAnd";
        exports.LogicalAnd = vo;
        const No = "LogicalNot";
        exports.LogicalNot = No;
        const Mo = "LogicalOr";
        exports.LogicalOr = Mo;
        const Ao = "LogSoftmax";
        exports.LogSoftmax = Ao;
        const Bo = "LRN";
        exports.LRN = Bo;
        const Co = "LRNBackprop";
        exports.LRNBackprop = Co;
        const mo = "Max";
        exports.Max = mo;
        const Fo = "Maximum";
        exports.Maximum = Fo;
        const Ro = "MaxPool";
        exports.MaxPool = Ro;
        const ko = "MaxPoolBackprop";
        exports.MaxPoolBackprop = ko;
        const Po = "MaxPool3D";
        exports.MaxPool3D = Po;
        const Lo = "MaxPool3DBackprop";
        exports.MaxPool3DBackprop = Lo;
        const To = "MaxPoolWithArgmax";
        exports.MaxPoolWithArgmax = To;
        const Io = "Mean";
        exports.Mean = Io;
        const Vo = "Min";
        exports.Min = Vo;
        const fo = "Minimum";
        exports.Minimum = fo;
        const Eo = "Mod";
        exports.Mod = Eo;
        const qo = "Multiply";
        exports.Multiply = qo;
        const Go = "Negate";
        exports.Negate = Go;
        const wo = "NotEqual";
        exports.NotEqual = wo;
        const zo = "NonMaxSuppressionV3";
        exports.NonMaxSuppressionV3 = zo;
        const bo = "NonMaxSuppressionV4";
        exports.NonMaxSuppressionV4 = bo;
        const yo = "NonMaxSuppressionV5";
        exports.NonMaxSuppressionV5 = yo;
        const Oo = "OnesLike";
        exports.OnesLike = Oo;
        const Uo = "OneHot";
        exports.OneHot = Uo;
        const Wo = "PadV2";
        exports.PadV2 = Wo;
        const _o = "Pool";
        exports.Pool = _o;
        const Ho = "Pow";
        exports.Pow = Ho;
        const Ko = "Prelu";
        exports.Prelu = Ko;
        const Zo = "Prod";
        exports.Prod = Zo;
        const jo = "Range";
        exports.Range = jo;
        const Jo = "Real";
        exports.Real = Jo;
        const Qo = "Reciprocal";
        exports.Reciprocal = Qo;
        const Xo = "Relu";
        exports.Relu = Xo;
        const Yo = "Reshape";
        exports.Reshape = Yo;
        const $o = "ResizeNearestNeighbor";
        exports.ResizeNearestNeighbor = $o;
        const ot = "ResizeNearestNeighborGrad";
        exports.ResizeNearestNeighborGrad = ot;
        const tt = "ResizeBilinear";
        exports.ResizeBilinear = tt;
        const et = "ResizeBilinearGrad";
        exports.ResizeBilinearGrad = et;
        const st = "Relu6";
        exports.Relu6 = st;
        const rt = "Reverse";
        exports.Reverse = rt;
        const pt = "Round";
        exports.Round = pt;
        const xt = "Rsqrt";
        exports.Rsqrt = xt;
        const nt = "ScatterNd";
        exports.ScatterNd = nt;
        const at = "SelectV2";
        exports.SelectV2 = at;
        const ct = "Selu";
        exports.Selu = ct;
        const it = "Slice";
        exports.Slice = it;
        const lt = "Sin";
        exports.Sin = lt;
        const ut = "Sinh";
        exports.Sinh = ut;
        const dt = "Sign";
        exports.Sign = dt;
        const Dt = "Sigmoid";
        exports.Sigmoid = Dt;
        const St = "Softplus";
        exports.Softplus = St;
        const gt = "Sqrt";
        exports.Sqrt = gt;
        const ht = "Sum";
        exports.Sum = ht;
        const vt = "SpaceToBatchND";
        exports.SpaceToBatchND = vt;
        const Nt = "SplitV";
        exports.SplitV = Nt;
        const Mt = "Softmax";
        exports.Softmax = Mt;
        const At = "SquaredDifference";
        exports.SquaredDifference = At;
        const Bt = "Square";
        exports.Square = Bt;
        const Ct = "Sub";
        exports.Sub = Ct;
        const mt = "SparseToDense";
        exports.SparseToDense = mt;
        const Ft = "StridedSlice";
        exports.StridedSlice = Ft;
        const Rt = "Tan";
        exports.Tan = Rt;
        const kt = "Tanh";
        exports.Tanh = kt;
        const Pt = "Tile";
        exports.Tile = Pt;
        const Lt = "TopK";
        exports.TopK = Lt;
        const Tt = "Transpose";
        exports.Transpose = Tt;
        const It = "Unpack";
        exports.Unpack = It;
        const Vt = "UnsortedSegmentSum";
        exports.UnsortedSegmentSum = Vt;
        const ft = "ZerosLike";
        exports.ZerosLike = ft;
        const Et = "Step";
        exports.Step = Et;
        const qt = "FromPixels";
        exports.FromPixels = qt;
        const Gt = "RotateWithOffset";
        exports.RotateWithOffset = Gt;
        const wt = "_FusedMatMul";
        exports._FusedMatMul = wt;
        const zt = "FusedConv2D";
        exports.FusedConv2D = zt;
        const bt = "FusedDepthwiseConv2D";
        exports.FusedDepthwiseConv2D = bt;
    }, {}],
    "c6yR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.inferShape = o, exports.convertToTensor = a, exports.convertToTensorArray = u;
        var r = require("./engine"),
            e = require("./environment"),
            t = require("./tensor"),
            n = require("./util");

        function o(r, t) {
            let o = r;
            if ((0, n.isTypedArray)(r)) return "string" === t ? [] : [r.length];
            if (!Array.isArray(r)) return [];
            const i = [];
            for (; Array.isArray(o) || (0, n.isTypedArray)(o) && "string" !== t;) i.push(o.length), o = o[0];
            return Array.isArray(r) && (0, e.env)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && s(r, i, []), i
        }

        function s(r, e, t) {
            if (t = t || [], !Array.isArray(r) && !(0, n.isTypedArray)(r)) return void(0, n.assert)(0 === e.length, () => `Element arr[${t.join("][")}] is a primitive, ` + `but should be an array/TypedArray of ${e[0]} elements`);
            (0, n.assert)(e.length > 0, () => `Element arr[${t.join("][")}] should be a primitive, ` + `but is an array of ${r.length} elements`), (0, n.assert)(r.length === e[0], () => `Element arr[${t.join("][")}] should have ${e[0]} ` + `elements, but has ${r.length} elements`);
            const o = e.slice(1);
            for (let n = 0; n < r.length; ++n) s(r[n], o, t.concat(n))
        }

        function i(r, e, t, n) {
            if (null != r && ("numeric" !== r && r !== e || "numeric" === r && "string" === e)) throw new Error(`Argument '${t}' passed to '${n}' must ` + `be ${r} tensor, but got ${e} tensor`)
        }

        function a(e, s, a, u = "numeric") {
            if (e instanceof t.Tensor) return i(u, e.dtype, s, a), e;
            let l = (0, n.inferDtype)(e);
            if ("string" !== l && ["bool", "int32", "float32"].indexOf(u) >= 0 && (l = u), i(u, l, s, a), null == e || !(0, n.isTypedArray)(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) {
                const r = null == e ? "null" : e.constructor.name;
                throw new Error(`Argument '${s}' passed to '${a}' must be a ` + `Tensor or TensorLike, but got '${r}'`)
            }
            const y = o(e, l);
            (0, n.isTypedArray)(e) || Array.isArray(e) || (e = [e]);
            const f = "string" !== l ? (0, n.toTypedArray)(e, l) : (0, n.flatten)(e, [], !0);
            return r.ENGINE.makeTensor(f, y, l)
        }

        function u(r, e, t, n = "numeric") {
            if (!Array.isArray(r)) throw new Error(`Argument ${e} passed to ${t} must be a ` + "`Tensor[]` or `TensorLike[]`");
            return r.map((r, n) => a(r, `${e}[${n}]`, t), n)
        }
    }, {
        "./engine": "Nc3Y",
        "./environment": "Fbeg",
        "./tensor": "DTHt",
        "./util": "P6nv"
    }],
    "JtaO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.op = t;
        var e = require("../engine");

        function t(t) {
            const n = Object.keys(t);
            if (1 !== n.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + `${n.length} keys.`);
            let o = n[0];
            const r = t[o];
            o.endsWith("_") && (o = o.substring(0, o.length - 1));
            const i = (...t) => {
                e.ENGINE.startScope(o);
                try {
                    const o = r(...t);
                    return o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), e.ENGINE.endScope(o), o
                } catch (n) {
                    throw e.ENGINE.endScope(null), n
                }
            };
            return Object.defineProperty(i, "name", {
                value: o,
                configurable: !0
            }), i
        }
    }, {
        "../engine": "Nc3Y"
    }],
    "qqq3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cast = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = s(require("../util")),
            o = require("./operation");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = i();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function u(o, i) {
            const s = (0, r.convertToTensor)(o, "x", "cast");
            if (!n.isValidDtype(i)) throw new Error(`Failed to cast to unknown dtype ${i}`);
            if ("string" === i && "string" !== s.dtype || "string" !== i && "string" === s.dtype) throw new Error("Only strings can be casted to strings");
            const u = {
                    x: s
                },
                c = {
                    dtype: i
                };
            return e.ENGINE.runKernelFunc(e => e.cast(s, i), u, null, t.Cast, c)
        }
        const c = (0, o.op)({
            cast_: u
        });
        exports.cast = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "k2PI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.mul = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            t = require("../tensor_util_env"),
            u = require("./operation");

        function o(u, o) {
            let l = (0, t.convertToTensor)(u, "a", "mul"),
                i = (0, t.convertToTensor)(o, "b", "mul");
            [l, i] = (0, n.makeTypesMatch)(l, i);
            const s = {
                a: l,
                b: i
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.multiply(l, i);
                return r([l, i]), n
            }, s, null, r.Multiply)
        }
        const l = (0, u.op)({
            mul_: o
        });
        exports.mul = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "e2o4": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.step = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("./operation");

        function o(n, o = 0) {
            const s = (0, t.convertToTensor)(n, "x", "step"),
                p = {
                    x: s
                },
                u = {
                    alpha: o
                };
            return e.ENGINE.runKernelFunc(e => e.step(s, o), p, null, r.Step, u)
        }
        const s = (0, n.op)({
            step_: o
        });
        exports.step = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "ElQS": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.absGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/mul"),
            t = require("../ops/step");
        const o = {
            kernelName: e.Abs,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [a] = o;
                return {
                    x: () => (0, s.mul)(e, (0, t.step)((0, r.cast)(a, "float32"), -1))
                }
            }
        };
        exports.absGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/mul": "k2PI",
        "../ops/step": "e2o4"
    }],
    "Pk64": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.floorDiv = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util"),
            n = require("../tensor_util_env"),
            t = require("./operation");

        function i(t, i) {
            let l = (0, n.convertToTensor)(t, "a", "floorDiv"),
                u = (0, n.convertToTensor)(i, "b", "floorDiv");
            [l, u] = (0, o.makeTypesMatch)(l, u);
            const s = {
                a: l,
                b: u
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.floorDiv(l, u);
                return r([l, u]), o
            }, s, null, r.FloorDiv)
        }
        const l = (0, t.op)({
            floorDiv_: i
        });
        exports.floorDiv = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "D8Fc": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.div = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            i = require("../tensor_util"),
            n = require("../tensor_util_env"),
            t = require("./floorDiv"),
            o = require("./operation");

        function u(o, u) {
            let s = (0, n.convertToTensor)(o, "a", "div"),
                v = (0, n.convertToTensor)(u, "b", "div");
            if ([s, v] = (0, i.makeTypesMatch)(s, v), "int32" === s.dtype && "int32" === v.dtype) return (0, t.floorDiv)(s, v);
            const l = {
                a: s,
                b: v
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const i = e.realDivide(s, v);
                return r([s, v]), i
            }, l, null, r.Div, {})
        }
        const s = (0, o.op)({
            div_: u
        });
        exports.div = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./floorDiv": "Pk64",
        "./operation": "JtaO"
    }],
    "iGYA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.neg = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            o = require("./operation");

        function t(o) {
            const t = (0, r.convertToTensor)(o, "x", "neg"),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc(e => e.neg(t), u, null, n.Negate)
        }
        const u = (0, o.op)({
            neg_: t
        });
        exports.neg = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "m0jF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.makeTensor = s;
        var e = require("../engine"),
            r = require("../util");

        function s(s, o, t, a) {
            if (null == a && (a = (0, r.inferDtype)(s)), "complex64" === a) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
            if (!(0, r.isTypedArray)(s) && !Array.isArray(s) && "number" != typeof s && "boolean" != typeof s && "string" != typeof s) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
            if (null != o) {
                (0, r.assertNonNegativeIntegerDimensions)(o);
                const e = (0, r.sizeFromShape)(o),
                    s = (0, r.sizeFromShape)(t);
                (0, r.assert)(e === s, () => `Based on the provided shape, [${o}], the tensor should have ` + `${e} values but has ${s}`);
                for (let a = 0; a < t.length; ++a) {
                    const e = t[a],
                        s = a !== t.length - 1 || e !== (0, r.sizeFromShape)(o.slice(a));
                    (0, r.assert)(t[a] === o[a] || !s, () => "Error creating a new Tensor. Inferred shape " + `(${t}) does not match the provided ` + `shape (${o}). `)
                }
            }
            return (0, r.isTypedArray)(s) || Array.isArray(s) || (s = [s]), o = o || t, s = "string" !== a ? (0, r.toTypedArray)(s, a) : (0, r.flatten)(s, [], !0), e.ENGINE.makeTensor(s, o, a)
        }
    }, {
        "../engine": "Nc3Y",
        "../util": "P6nv"
    }],
    "Ay42": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.scalar = t;
        var r = require("../util"),
            e = require("./tensor_ops_util");

        function t(t, a) {
            if (((0, r.isTypedArray)(t) && "string" !== a || Array.isArray(t)) && "complex64" !== a) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
            if ("string" === a && (0, r.isTypedArray)(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
            return (0, e.makeTensor)(t, [], [], a)
        }
    }, {
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "iJpu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sqrt = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("./operation");

        function o(n) {
            const o = (0, t.convertToTensor)(n, "x", "sqrt"),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.sqrt(o);
                return r([o]), t
            }, s, null, r.Sqrt)
        }
        const s = (0, n.op)({
            sqrt_: o
        });
        exports.sqrt = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "mJRX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.square = void 0;
        var e = require("../engine"),
            r = require("../tensor_util_env"),
            u = require("./operation");

        function n(u) {
            const n = (0, r.convertToTensor)(u, "x", "square"),
                o = [n];
            return e.ENGINE.runKernelFunc((e, r) => (r([n]), e.square(n)), {
                x: n
            }, null, "Square", {}, o, [])
        }
        const o = (0, u.op)({
            square_: n
        });
        exports.square = o;
    }, {
        "../engine": "Nc3Y",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "dGex": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sub = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            t = require("../tensor_util_env"),
            u = require("./operation");

        function o(u, o) {
            let s = (0, t.convertToTensor)(u, "a", "sub"),
                i = (0, t.convertToTensor)(o, "b", "sub");
            [s, i] = (0, n.makeTypesMatch)(s, i);
            const c = {
                a: s,
                b: i
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.subtract(s, i);
                return r([s, i]), n
            }, c, null, r.Sub)
        }
        const s = (0, u.op)({
            sub_: o
        });
        exports.sub = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "JeEo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.acosGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/div"),
            o = require("../ops/neg"),
            a = require("../ops/scalar"),
            u = require("../ops/sqrt"),
            t = require("../ops/square"),
            i = require("../ops/sub");
        const n = {
            kernelName: e.Acos,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [c] = n;
                return {
                    x: () => {
                        const n = (0, t.square)((0, r.cast)(c, "float32")),
                            p = (0, u.sqrt)((0, i.sub)((0, a.scalar)(1), n));
                        return (0, o.neg)((0, s.div)(e, p))
                    }
                }
            }
        };
        exports.acosGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/neg": "iGYA",
        "../ops/scalar": "Ay42",
        "../ops/sqrt": "iJpu",
        "../ops/square": "mJRX",
        "../ops/sub": "dGex"
    }],
    "xSyH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.acoshGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/div"),
            o = require("../ops/sqrt"),
            t = require("../ops/square"),
            u = require("../ops/sub");
        const a = {
            kernelName: e.Acosh,
            inputsToSave: ["x"],
            gradFunc: (e, a) => {
                const [i] = a;
                return {
                    x: () => {
                        const a = (0, o.sqrt)((0, u.sub)((0, t.square)((0, r.cast)(i, "float32")), 1));
                        return (0, s.div)(e, a)
                    }
                }
            }
        };
        exports.acoshGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/sqrt": "iJpu",
        "../ops/square": "mJRX",
        "../ops/sub": "dGex"
    }],
    "Xh9J": [function(require, module, exports) {
        "use strict";

        function t(t, e) {
            const n = t.length,
                s = [];
            for (let o = 0; o < n; o++) {
                const r = n - 1 - o,
                    l = t[r] || 1;
                (e[e.length - 1 - o] || 1) > 1 && 1 === l && s.unshift(r)
            }
            return s
        }

        function e(t, e) {
            const n = [];
            for (let s = 0; s < e.length; s++) {
                const o = t[t.length - s - 1],
                    r = e.length - s - 1,
                    l = e[r];
                (null == o || 1 === o && l > 1) && n.unshift(r)
            }
            return n
        }

        function n(t, e) {
            const n = [],
                s = Math.max(t.length, e.length);
            for (let o = 0; o < s; o++) {
                let s = t[t.length - o - 1];
                null == s && (s = 1);
                let r = e[e.length - o - 1];
                if (null == r && (r = 1), 1 === s) n.unshift(r);
                else if (1 === r) n.unshift(s);
                else {
                    if (s !== r) {
                        throw Error("Operands could not be broadcast together with shapes " + `${t} and ${e}.`)
                    }
                    n.unshift(s)
                }
            }
            return n
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getBroadcastDims = t, exports.getReductionAxes = e, exports.assertAndGetBroadcastShape = n;
    }, {}],
    "FPsn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.addGradConfig = void 0;
        var e = require("../kernel_names"),
            t = n(require("../ops/broadcast_util"));

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function n(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = r();
            if (t && t.has(e)) return t.get(e);
            var n = {},
                a = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = a ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, o, s) : n[o] = e[o]
                } return n.default = e, t && t.set(e, n), n
        }
        const a = {
            kernelName: e.Add,
            inputsToSave: ["a", "b"],
            gradFunc: (e, r) => {
                const [n, a] = r, o = t.assertAndGetBroadcastShape(n.shape, a.shape);
                return {
                    a: () => {
                        let r = e;
                        const a = t.getReductionAxes(n.shape, o);
                        return a.length > 0 && (r = r.sum(a)), r.reshape(n.shape)
                    },
                    b: () => {
                        let r = e;
                        const n = t.getReductionAxes(a.shape, o);
                        return n.length > 0 && (r = r.sum(n)), r.reshape(a.shape)
                    }
                }
            }
        };
        exports.addGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J"
    }],
    "eWqU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.addNGradConfig = void 0;
        var e = require("../kernel_names");
        const r = {
            kernelName: e.AddN,
            saveAllInputs: !0,
            gradFunc: (e, r) => {
                const d = {};
                return r.forEach((r, n) => {
                    d[n] = (() => e.clone())
                }), d
            }
        };
        exports.addNGradConfig = r;
    }, {
        "../kernel_names": "sdEe"
    }],
    "PDcB": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.zerosLike = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function i(n) {
            const i = (0, o.convertToTensor)(n, "x", "zerosLike"),
                s = {
                    x: i
                };
            return e.ENGINE.runKernelFunc(e => e.zerosLike(i), s, null, r.ZerosLike)
        }
        const s = (0, n.op)({
            zerosLike_: i
        });
        exports.zerosLike = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "uSdy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.argMaxGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const o = {
            kernelName: e.ArgMax,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [a] = o;
                return {
                    x: () => (0, r.zerosLike)(a)
                }
            }
        };
        exports.argMaxGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "pXdU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.argMinGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const n = {
            kernelName: e.ArgMin,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [o] = n;
                return {
                    x: () => (0, r.zerosLike)(o)
                }
            }
        };
        exports.argMinGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "aEuk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.asinGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/div"),
            a = require("../ops/scalar"),
            i = require("../ops/sqrt"),
            o = require("../ops/square"),
            u = require("../ops/sub");
        const t = {
            kernelName: e.Asin,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => (0, s.div)(e, (0, i.sqrt)((0, u.sub)((0, a.scalar)(1), (0, o.square)((0, r.cast)(n, "float32")))))
                }
            }
        };
        exports.asinGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/scalar": "Ay42",
        "../ops/sqrt": "iJpu",
        "../ops/square": "mJRX",
        "../ops/sub": "dGex"
    }],
    "ZDFV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.add = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            t = require("../tensor_util_env"),
            o = require("./operation");

        function d(o, d) {
            let u = (0, t.convertToTensor)(o, "a", "add"),
                s = (0, t.convertToTensor)(d, "b", "add");
            [u, s] = (0, n.makeTypesMatch)(u, s);
            const a = {
                a: u,
                b: s
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.add(u, s);
                return r([u, s]), n
            }, a, null, r.Add)
        }
        const u = (0, o.op)({
            add_: d
        });
        exports.add = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "u5uO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.asinhGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            s = require("../ops/cast"),
            a = require("../ops/div"),
            o = require("../ops/scalar"),
            i = require("../ops/sqrt"),
            t = require("../ops/square");
        const n = {
            kernelName: e.Asinh,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [u] = n;
                return {
                    x: () => {
                        const n = (0, i.sqrt)((0, r.add)((0, o.scalar)(1), (0, t.square)((0, s.cast)(u, "float32"))));
                        return (0, a.div)(e, n)
                    }
                }
            }
        };
        exports.asinhGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/scalar": "Ay42",
        "../ops/sqrt": "iJpu",
        "../ops/square": "mJRX"
    }],
    "QI4k": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reshape = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            o = require("./operation");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, o, u) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(o, s) {
            const u = (0, t.convertToTensor)(o, "x", "reshape", null);
            s = n.inferFromImplicitShape(s, u.size), n.assert(u.size === n.sizeFromShape(s), () => "new shape and old shape must have the same number of elements.");
            const i = {
                    x: u
                },
                a = {
                    shape: s
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([u]), e.reshape(u, s)), i, null, r.Reshape, a)
        }
        const a = (0, o.op)({
            reshape_: i
        });
        exports.reshape = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "DsMP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.axesAreInnerMostDims = n, exports.combineLocations = o, exports.computeOutAndReduceShapes = u, exports.expandShapeToKeepDim = s, exports.assertAxesAreInnerMostDims = p, exports.getAxesPermutation = i, exports.getUndoAxesPermutation = f, exports.getInnerMostAxes = a;
        var e = r(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, u) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, u, s) : n[u] = e[u]
                } return n.default = e, r && r.set(e, n), n
        }

        function n(e, t) {
            for (let r = 0; r < e.length; ++r)
                if (e[e.length - r - 1] !== t - 1 - r) return !1;
            return !0
        }

        function o(e, t, r) {
            const n = e.length + t.length,
                o = [];
            let u = 0,
                s = 0;
            for (let p = 0; p < n; p++) - 1 === r.indexOf(p) ? o.push(e[u++]) : o.push(t[s++]);
            return o
        }

        function u(e, t) {
            const r = [],
                n = e.length;
            for (let o = 0; o < n; o++) - 1 === t.indexOf(o) && r.push(e[o]);
            return [r, t.map(t => e[t])]
        }

        function s(e, t) {
            return o(e, t.map(e => 1), t)
        }

        function p(t, r, o) {
            e.assert(n(r, o), () => `${t} supports only inner-most axes for now. ` + `Got axes ${r} and rank-${o} input.`)
        }

        function i(e, t) {
            if (n(e, t)) return null;
            const r = [];
            for (let n = 0; n < t; ++n) - 1 === e.indexOf(n) && r.push(n);
            return e.forEach(e => r.push(e)), r
        }

        function f(e) {
            return e.map((e, t) => [t, e]).sort((e, t) => e[1] - t[1]).map(e => e[0])
        }

        function a(e, t) {
            const r = [];
            for (let n = t - e; n < t; ++n) r.push(n);
            return r
        }
    }, {
        "../util": "P6nv"
    }],
    "ITAy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sum = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("../util"),
            s = require("./axis_util"),
            u = require("./operation");

        function o(u, o = null, i = !1) {
            let a = (0, n.convertToTensor)(u, "x", "sum");
            "bool" === a.dtype && (a = a.toInt());
            const l = {
                    x: a
                },
                p = {
                    axis: o,
                    keepDims: i
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                r([a]);
                const n = (0, t.parseAxisParam)(o, a.shape),
                    u = (0, s.getAxesPermutation)(n, a.rank);
                let l = n,
                    p = a;
                null != u && (p = a.transpose(u), l = (0, s.getInnerMostAxes)(l.length, a.rank));
                let m = e.sum(p, l);
                if (i) {
                    const e = (0, s.expandShapeToKeepDim)(m.shape, n);
                    m = m.reshape(e)
                }
                return m
            }, l, null, r.Sum, p)
        }
        const i = (0, u.op)({
            sum_: o
        });
        exports.sum = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "TJcA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atan2GradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            s = require("../ops/broadcast_util"),
            a = require("../ops/div"),
            t = require("../ops/mul"),
            u = require("../ops/neg"),
            n = require("../ops/reshape"),
            o = require("../ops/square"),
            p = require("../ops/sum");
        const i = {
            kernelName: e.Atan2,
            inputsToSave: ["a", "b"],
            gradFunc: (e, i) => {
                const [d, q] = i, c = (0, s.assertAndGetBroadcastShape)(d.shape, q.shape);
                return {
                    a: () => {
                        const u = (0, r.add)((0, o.square)(d), (0, o.square)(q));
                        let i = (0, t.mul)(e, (0, a.div)(q, u));
                        const h = (0, s.getReductionAxes)(d.shape, c);
                        return h.length > 0 && (i = (0, p.sum)(i, h)), (0, n.reshape)(i, d.shape)
                    },
                    b: () => {
                        const i = (0, r.add)((0, o.square)(d), (0, o.square)(q));
                        let h = (0, u.neg)((0, t.mul)(e, (0, a.div)(d, i)));
                        const l = (0, s.getReductionAxes)(q.shape, c);
                        return l.length > 0 && (h = (0, p.sum)(h, l)), (0, n.reshape)(h, q.shape)
                    }
                }
            }
        };
        exports.atan2GradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/broadcast_util": "Xh9J",
        "../ops/div": "D8Fc",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/reshape": "QI4k",
        "../ops/square": "mJRX",
        "../ops/sum": "ITAy"
    }],
    "X7rA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atanGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            a = require("../ops/cast"),
            s = require("../ops/div"),
            t = require("../ops/square");
        const o = {
            kernelName: e.Atan,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [n] = o;
                return {
                    x: () => (0, s.div)(e, (0, r.add)((0, t.square)((0, a.cast)(n, "float32")), 1))
                }
            }
        };
        exports.atanGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/square": "mJRX"
    }],
    "z0kM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atanhGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/div"),
            a = require("../ops/square"),
            o = require("../ops/sub"),
            t = require("../ops/scalar");
        const u = {
            kernelName: e.Atanh,
            inputsToSave: ["x"],
            gradFunc: (e, u) => {
                const [i] = u;
                return {
                    x: () => (0, s.div)(e, (0, o.sub)((0, t.scalar)(1), (0, a.square)((0, r.cast)(i, "float32"))))
                }
            }
        };
        exports.atanhGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/square": "mJRX",
        "../ops/sub": "dGex",
        "../ops/scalar": "Ay42"
    }],
    "Evju": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.computeDilation2DInfo = r, exports.computePool2DInfo = o, exports.computePool3DInfo = i, exports.computeConv2DInfo = a, exports.computeConv3DInfo = s, exports.computeDefaultPad = u, exports.tupleValuesAreOne = M, exports.eitherStridesOrDilationsAreOne = b, exports.convertConv2DDataFormat = w;
        var t = n(require("../util"));

        function e() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return e = function() {
                return t
            }, t
        }

        function n(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var n = e();
            if (n && n.has(t)) return n.get(t);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in t)
                if (Object.prototype.hasOwnProperty.call(t, i)) {
                    var a = o ? Object.getOwnPropertyDescriptor(t, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, i, a) : r[i] = t[i]
                } return r.default = t, n && n.set(t, r), r
        }

        function r(t, e, n, r, o = "NHWC", i) {
            return a(t, [...e, t[3]], n, i, r, null, null, w(o))
        }

        function o(t, e, n, r, o, i, s = "channelsLast") {
            const [h, l] = f(e);
            let u;
            if ("channelsLast" === s) u = [h, l, t[3], t[3]];
            else {
                if ("channelsFirst" !== s) throw new Error(`Unknown dataFormat ${s}`);
                u = [h, l, t[1], t[1]]
            }
            return a(t, u, n, r, o, i, !1, s)
        }

        function i(t, e, n, r, o, i, a = "NDHWC") {
            const [h, l, u] = c(e);
            let f, p;
            if ("NDHWC" === a) p = "channelsLast", f = [h, l, u, t[4], t[4]];
            else {
                if ("NCDHW" !== a) throw new Error(`Unknown dataFormat ${a}`);
                p = "channelsFirst", f = [h, l, u, t[1], t[1]]
            }
            return s(t, f, n, r, o, !1, p, i)
        }

        function a(t, e, n, r, o, i, a = !1, s = "channelsLast") {
            let [h, l, u, c] = [-1, -1, -1, -1];
            if ("channelsLast" === s)[h, l, u, c] = t;
            else {
                if ("channelsFirst" !== s) throw new Error(`Unknown dataFormat ${s}`);
                [h, c, l, u] = t
            }
            const [m, g, , M] = e, [b, w] = f(n), [D, W] = f(r), I = p(m, D), y = p(g, W), {
                padInfo: H,
                outHeight: F,
                outWidth: L
            } = d(o, l, u, b, w, I, y, i, s), C = a ? M * c : M;
            let v;
            return "channelsFirst" === s ? v = [h, C, F, L] : "channelsLast" === s && (v = [h, F, L, C]), {
                batchSize: h,
                dataFormat: s,
                inHeight: l,
                inWidth: u,
                inChannels: c,
                outHeight: F,
                outWidth: L,
                outChannels: C,
                padInfo: H,
                strideHeight: b,
                strideWidth: w,
                filterHeight: m,
                filterWidth: g,
                effectiveFilterHeight: I,
                effectiveFilterWidth: y,
                dilationHeight: D,
                dilationWidth: W,
                inShape: t,
                outShape: v,
                filterShape: e
            }
        }

        function s(t, e, n, r, o, i = !1, a = "channelsLast", s) {
            let [h, l, u, f, d] = [-1, -1, -1, -1, -1];
            if ("channelsLast" === a)[h, l, u, f, d] = t;
            else {
                if ("channelsFirst" !== a) throw new Error(`Unknown dataFormat ${a}`);
                [h, d, l, u, f] = t
            }
            const [g, M, b, , w] = e, [D, W, I] = c(n), [y, H, F] = c(r), L = p(g, y), C = p(M, H), v = p(b, F), {
                padInfo: k,
                outDepth: E,
                outHeight: $,
                outWidth: x
            } = m(o, l, u, f, D, W, I, L, C, v, s), O = i ? w * d : w;
            let S;
            return "channelsFirst" === a ? S = [h, O, E, $, x] : "channelsLast" === a && (S = [h, E, $, x, O]), {
                batchSize: h,
                dataFormat: a,
                inDepth: l,
                inHeight: u,
                inWidth: f,
                inChannels: d,
                outDepth: E,
                outHeight: $,
                outWidth: x,
                outChannels: O,
                padInfo: k,
                strideDepth: D,
                strideHeight: W,
                strideWidth: I,
                filterDepth: g,
                filterHeight: M,
                filterWidth: b,
                effectiveFilterDepth: L,
                effectiveFilterHeight: C,
                effectiveFilterWidth: v,
                dilationDepth: y,
                dilationHeight: H,
                dilationWidth: F,
                inShape: t,
                outShape: S,
                filterShape: e
            }
        }

        function h(e, n, r, o, i) {
            null == o && (o = u(e, n, r));
            const a = e[0],
                s = e[1],
                h = g((a - n + 2 * o) / r + 1, i);
            t.assert(t.isInt(h), () => `The output # of rows (${h}) must be an integer. ` + "Change the stride and/or zero pad parameters");
            const l = g((s - n + 2 * o) / r + 1, i);
            return t.assert(t.isInt(l), () => `The output # of columns (${l}) must be an integer. ` + "Change the stride and/or zero pad parameters"), [h, l]
        }

        function l(e, n, r, o, i, a) {
            null == i && (i = u(e, n, o));
            const s = e[0],
                h = e[1],
                l = e[2],
                f = g((s - n + 2 * i) / o + 1, a);
            t.assert(t.isInt(f), () => `The output # of depths (${f}) must be an integer. ` + "Change the stride and/or zero pad parameters");
            const c = g((h - n + 2 * i) / o + 1, a);
            t.assert(t.isInt(c), () => `The output # of rows (${c}) must be an integer. ` + "Change the stride and/or zero pad parameters");
            const p = g((l - n + 2 * i) / o + 1, a);
            return t.assert(t.isInt(p), () => `The output # of columns (${p}) must be an integer. ` + "Change the stride and/or zero pad parameters"), [f, c, p, r]
        }

        function u(t, e, n, r = 1) {
            const o = p(e, r);
            return Math.floor((t[0] * (n - 1) - n + o) / 2)
        }

        function f(t) {
            return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
        }

        function c(t) {
            return "number" == typeof t ? [t, t, t] : t
        }

        function p(t, e) {
            return e <= 1 ? t : t + (t - 1) * (e - 1)
        }

        function d(t, e, n, r, o, i, a, s, l) {
            let u, f, c;
            if ("number" == typeof t) {
                u = {
                    top: t,
                    bottom: t,
                    left: t,
                    right: t,
                    type: 0 === t ? "VALID" : "NUMBER"
                };
                const o = h([e, n], i, r, t, s);
                f = o[0], c = o[1]
            } else if ("same" === t) {
                f = Math.ceil(e / r), c = Math.ceil(n / o);
                const t = Math.max(0, (f - 1) * r + i - e),
                    s = Math.max(0, (c - 1) * o + a - n),
                    h = Math.floor(t / 2),
                    l = t - h,
                    p = Math.floor(s / 2);
                u = {
                    top: h,
                    bottom: l,
                    left: p,
                    right: s - p,
                    type: "SAME"
                }
            } else if ("valid" === t) u = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                type: "VALID"
            }, f = Math.ceil((e - i + 1) / r), c = Math.ceil((n - a + 1) / o);
            else {
                if ("object" != typeof t) throw Error(`Unknown padding parameter: ${t}`); {
                    const h = "channelsLast" === l ? t[1][0] : t[2][0],
                        p = "channelsLast" === l ? t[1][1] : t[2][1],
                        d = "channelsLast" === l ? t[2][0] : t[3][0],
                        m = "channelsLast" === l ? t[2][1] : t[3][1];
                    u = {
                        top: h,
                        bottom: p,
                        left: d,
                        right: m,
                        type: 0 === h && 0 === p && 0 === d && 0 === m ? "VALID" : "EXPLICIT"
                    }, f = g((e - i + h + p) / r + 1, s), c = g((n - a + d + m) / o + 1, s)
                }
            }
            return {
                padInfo: u,
                outHeight: f,
                outWidth: c
            }
        }

        function m(t, e, n, r, o, i, a, s, h, u, f) {
            let c, p, d, m;
            if ("number" == typeof t) {
                c = {
                    top: t,
                    bottom: t,
                    left: t,
                    right: t,
                    front: t,
                    back: t,
                    type: 0 === t ? "VALID" : "NUMBER"
                };
                const i = l([e, n, r, 1], s, 1, o, t, f);
                p = i[0], d = i[1], m = i[2]
            } else if ("same" === t) {
                const t = ((p = Math.ceil(e / o)) - 1) * o + s - e,
                    l = ((d = Math.ceil(n / i)) - 1) * i + h - n,
                    f = ((m = Math.ceil(r / a)) - 1) * a + u - r,
                    g = Math.floor(t / 2),
                    M = t - g,
                    b = Math.floor(l / 2),
                    w = l - b,
                    D = Math.floor(f / 2);
                c = {
                    top: b,
                    bottom: w,
                    left: D,
                    right: f - D,
                    front: g,
                    back: M,
                    type: "SAME"
                }
            } else {
                if ("valid" !== t) throw Error(`Unknown padding parameter: ${t}`);
                c = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    front: 0,
                    back: 0,
                    type: "VALID"
                }, p = Math.ceil((e - s + 1) / o), d = Math.ceil((n - h + 1) / i), m = Math.ceil((r - u + 1) / a)
            }
            return {
                padInfo: c,
                outDepth: p,
                outHeight: d,
                outWidth: m
            }
        }

        function g(t, e) {
            if (!e) return t;
            switch (e) {
                case "round":
                    return Math.round(t);
                case "ceil":
                    return Math.ceil(t);
                case "floor":
                    return Math.floor(t);
                default:
                    throw new Error(`Unknown roundingMode ${e}`)
            }
        }

        function M(t) {
            const [e, n, r] = f(t);
            return 1 === e && 1 === n && 1 === r
        }

        function b(t, e) {
            return M(t) || M(e)
        }

        function w(t) {
            if ("NHWC" === t) return "channelsLast";
            if ("NCHW" === t) return "channelsFirst";
            throw new Error(`Unknown dataFormat ${t}`)
        }
    }, {
        "../util": "P6nv"
    }],
    "Po20": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPool3dBackprop = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = i(require("../util")),
            n = i(require("./conv_util")),
            a = require("./operation"),
            p = require("./reshape");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var o = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = t ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(o, n, a) : o[n] = e[n]
                } return o.default = e, r && r.set(e, o), o
        }

        function u(a, s, i, u, l = [1, 1, 1], d, c) {
            const k = (0, o.convertToTensor)(a, "dy", "avgPool3dBackprop"),
                f = (0, o.convertToTensor)(s, "input", "avgPool3dBackprop");
            let g = k,
                h = f,
                v = !1;
            4 === f.rank && (v = !0, g = (0, p.reshape)(k, [1, k.shape[0], k.shape[1], k.shape[2], k.shape[3]]), h = (0, p.reshape)(f, [1, f.shape[0], f.shape[1], f.shape[2], f.shape[3]])), t.assert(5 === g.rank, () => "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + `${g.rank}.`), t.assert(5 === h.rank, () => "Error in avgPool3dBackprop: input must be rank 5 but got rank " + `${h.rank}.`), t.assert(n.eitherStridesOrDilationsAreOne(u, l), () => "Error in avgPool3dBackprop: Either strides or dilations " + `must be 1. Got strides ${u} and dilations '${l}'`), null != c && t.assert(t.isInt(d), () => "Error in maxPool3dBackprop: pad must be an integer when " + `using, dimRoundingMode ${c} but got pad ${d}.`);
            const P = {
                    dy: g,
                    input: h
                },
                b = {
                    filterSize: i,
                    strides: u,
                    dilations: l,
                    pad: d,
                    dimRoundingMode: c
                },
                y = e.ENGINE.runKernelFunc(e => {
                    const r = n.computePool3DInfo(h.shape, i, u, l, d, c);
                    return e.avgPool3dBackprop(g, h, r)
                }, P, null, r.AvgPool3DBackprop, b);
            return v ? (0, p.reshape)(y, [y.shape[1], y.shape[2], y.shape[3], y.shape[4]]) : y
        }
        const l = (0, a.op)({
            avgPool3dBackprop_: u
        });
        exports.avgPool3dBackprop = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "u0xB": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPool3DGradConfig = void 0;
        var e = require("../kernel_names"),
            o = require("../ops/avg_pool_3d_backprop");
        const r = {
            kernelName: e.AvgPool3D,
            inputsToSave: ["x"],
            gradFunc: (e, r, a) => {
                const [i] = r, {
                    filterSize: n,
                    strides: d,
                    dilations: s,
                    pad: t,
                    dimRoundingMode: l
                } = a, p = null == s ? [1, 1, 1] : s;
                return {
                    x: () => (0, o.avgPool3dBackprop)(e, i, n, d, p, t, l)
                }
            }
        };
        exports.avgPool3DGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/avg_pool_3d_backprop": "Po20"
    }],
    "OIHV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPoolBackprop = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = u(require("../util")),
            n = u(require("./conv_util")),
            a = require("./operation"),
            p = require("./reshape");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var o = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = t ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(o, n, a) : o[n] = e[n]
                } return o.default = e, r && r.set(e, o), o
        }

        function i(a, s, u, i, c) {
            const l = (0, o.convertToTensor)(a, "dy", "avgPoolBackprop"),
                k = (0, o.convertToTensor)(s, "input", "avgPoolBackprop");
            t.assert(k.rank === l.rank, () => `Rank of input (${k.rank}) does not match rank of dy (${l.rank})`);
            let f = k,
                v = l,
                h = !1;
            3 === k.rank && (h = !0, f = (0, p.reshape)(k, [1, k.shape[0], k.shape[1], k.shape[2]]), v = (0, p.reshape)(l, [1, l.shape[0], l.shape[1], l.shape[2]])), t.assert(4 === v.rank, () => "Error in avgPoolBackprop: dy must be rank 4 but got rank " + `${v.rank}.`), t.assert(4 === f.rank, () => "Error in avgPoolBackprop: input must be rank 4 but got rank " + `${f.rank}.`);
            const g = {
                    dy: v,
                    input: f
                },
                P = {
                    filterSize: u,
                    strides: i,
                    pad: c
                },
                d = e.ENGINE.runKernelFunc(e => {
                    const r = n.computePool2DInfo(f.shape, u, i, 1, c);
                    return e.avgPoolBackprop(v, f, r)
                }, g, null, r.AvgPoolBackprop, P);
            return h ? (0, p.reshape)(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
        const c = (0, a.op)({
            avgPoolBackprop_: i
        });
        exports.avgPoolBackprop = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "dUPW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPoolGradConfig = void 0;
        var e = require("../kernel_names"),
            o = require("../ops/avg_pool_backprop");
        const r = {
            kernelName: e.AvgPool,
            inputsToSave: ["x"],
            gradFunc: (e, r, a) => {
                const [s] = r, {
                    filterSize: t,
                    strides: p,
                    pad: i
                } = a;
                return {
                    x: () => (0, o.avgPoolBackprop)(e, s, t, p, i)
                }
            }
        };
        exports.avgPoolGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/avg_pool_backprop": "OIHV"
    }],
    "mMWq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.matMul = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            a = require("../tensor_util"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            s = require("./operation"),
            o = require("./reshape");

        function p() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return p = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = p();
            if (r && r.has(e)) return r.get(e);
            var a = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var s = t ? Object.getOwnPropertyDescriptor(e, n) : null;
                    s && (s.get || s.set) ? Object.defineProperty(a, n, s) : a[n] = e[n]
                } return a.default = e, r && r.set(e, a), a
        }

        function i(s, p, u = !1, i = !1) {
            let h = (0, t.convertToTensor)(s, "a", "matMul"),
                l = (0, t.convertToTensor)(p, "b", "matMul");
            [h, l] = (0, a.makeTypesMatch)(h, l), n.assert(h.rank >= 2 && l.rank >= 2 && h.rank === l.rank, () => "Error in matMul: inputs must have the same rank of at least 2, " + `got ranks ${h.rank} and ${l.rank}.`);
            const c = u ? h.shape[h.rank - 2] : h.shape[h.rank - 1],
                f = i ? l.shape[l.rank - 1] : l.shape[l.rank - 2],
                k = u ? h.shape[h.rank - 1] : h.shape[h.rank - 2],
                m = i ? l.shape[l.rank - 2] : l.shape[l.rank - 1],
                M = h.shape.slice(0, -2),
                d = l.shape.slice(0, -2),
                v = n.sizeFromShape(M),
                y = n.sizeFromShape(d);
            n.assert(n.arraysEqual(M, d), () => `Error in matMul: outer dimensions (${M}) and (` + `${d}) of Tensors with shapes ${h.shape} and ` + `${l.shape} must match.`), n.assert(c === f, () => `Error in matMul: inner shapes (${c}) and (` + `${f}) of Tensors with shapes ${h.shape} and ` + `${l.shape} and transposeA=${u}` + ` and transposeB=${i} must match.`);
            const $ = h.shape.slice(0, -2).concat([k, m]),
                b = u ? (0, o.reshape)(h, [v, c, k]) : (0, o.reshape)(h, [v, k, c]),
                O = i ? (0, o.reshape)(l, [y, m, f]) : (0, o.reshape)(l, [y, f, m]),
                _ = {
                    a: b,
                    b: O
                },
                q = {
                    transposeA: u,
                    transposeB: i
                },
                j = e.ENGINE.runKernelFunc((e, r) => (r([b, O]), e.batchMatMul(b, O, u, i)), _, null, r.BatchMatMul, q);
            return (0, o.reshape)(j, $)
        }
        const h = (0, s.op)({
            matMul_: i
        });
        exports.matMul = h;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "Czv4": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchMatMulGradConfig = void 0;
        var a = require("../kernel_names"),
            t = require("../ops/mat_mul");
        const e = {
            kernelName: a.BatchMatMul,
            inputsToSave: ["a", "b"],
            gradFunc: (a, e, r) => {
                const [u, l] = e, {
                    transposeA: s,
                    transposeB: M
                } = r;
                return s || M ? !s && M ? {
                    a: () => (0, t.matMul)(a, l, !1, !1),
                    b: () => (0, t.matMul)(a, u, !0, !1)
                } : s && !M ? {
                    a: () => (0, t.matMul)(l, a, !1, !0),
                    b: () => (0, t.matMul)(u, a, !1, !1)
                } : {
                    a: () => (0, t.matMul)(l, a, !0, !0),
                    b: () => (0, t.matMul)(a, u, !0, !0)
                } : {
                    a: () => (0, t.matMul)(a, l, !1, !0),
                    b: () => (0, t.matMul)(u, a, !0, !1)
                }
            }
        };
        exports.batchMatMulGradConfig = e;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mat_mul": "mMWq"
    }],
    "rWul": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.spaceToBatchND = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = s(require("../util")),
            o = require("./operation");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function i(o, a, s) {
            const i = (0, r.convertToTensor)(o, "x", "spaceToBatchND");
            n.assert(i.rank >= 1 + a.length, () => `input rank ${i.rank} should be > than [blockShape] ${a.length}`), n.assert(s.length === a.length, () => `paddings.shape[0] ${s.length} must be equal to [blockShape] ${a.length}`), n.assert(i.shape.reduce((e, t, r) => r > 0 && r <= a.length ? e && (t + s[r - 1][0] + s[r - 1][1]) % a[r - 1] == 0 : e, !0), () => `input spatial dimensions ${i.shape.slice(1)} with paddings ${s.toString()} must be divisible by blockShapes ${a.toString()}`);
            const c = {
                    x: i
                },
                u = {
                    blockShape: a,
                    paddings: s
                };
            return e.ENGINE.runKernelFunc(e => e.spaceToBatchND(i, a, s), c, null, t.SpaceToBatchND, u)
        }
        const c = (0, o.op)({
            spaceToBatchND_: i
        });
        exports.spaceToBatchND = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "CDA7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchToSpaceNDGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/space_to_batch_nd");
        const a = {
            kernelName: e.BatchToSpaceND,
            gradFunc: (e, a, o) => {
                const {
                    blockShape: c,
                    crops: t
                } = o;
                return {
                    x: () => (0, r.spaceToBatchND)(e, c, t)
                }
            }
        };
        exports.batchToSpaceNDGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/space_to_batch_nd": "rWul"
    }],
    "Gxda": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.broadcastToGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/sum");
        const o = {
            kernelName: e.BroadcastTo,
            gradFunc: (e, o, t) => {
                const a = t,
                    s = a.inputShape,
                    n = a.shape,
                    c = Array.from(n);
                for (let r = s.length - 1; r >= 0; r--)
                    if (s[r] === n[r]) c[r] = 1;
                    else if (1 !== s[r]) throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${n}].`);
                const d = [];
                for (let r = 0; r < c.length; r++) c[r] > 1 && d.push(r);
                return {
                    x: () => (0, r.sum)(e, d, !0)
                }
            }
        };
        exports.broadcastToGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/sum": "ITAy"
    }],
    "ZcTz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.castGradConfig = void 0;
        var e = require("../kernel_names");
        const r = {
            kernelName: e.Cast,
            gradFunc: e => ({
                x: () => e.clone()
            })
        };
        exports.castGradConfig = r;
    }, {
        "../kernel_names": "sdEe"
    }],
    "MI0y": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ceilGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const i = {
            kernelName: e.Ceil,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.ceilGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "Dbo2": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.greaterEqual = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util"),
            a = require("../tensor_util_env"),
            n = require("./broadcast_util"),
            u = require("./operation");

        function o(u, o) {
            let s = (0, a.convertToTensor)(u, "a", "greaterEqual"),
                l = (0, a.convertToTensor)(o, "b", "greaterEqual");
            [s, l] = (0, t.makeTypesMatch)(s, l), (0, n.assertAndGetBroadcastShape)(s.shape, l.shape);
            const i = {
                a: s,
                b: l
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.greaterEqual(s, l);
                return r([s, l]), t
            }, i, null, r.GreaterEqual)
        }
        const s = (0, u.op)({
            greaterEqual_: o
        });
        exports.greaterEqual = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "FvS1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.lessEqual = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            s = require("../tensor_util"),
            t = require("../tensor_util_env"),
            n = require("./broadcast_util"),
            u = require("./operation");

        function a(u, a) {
            let l = (0, t.convertToTensor)(u, "a", "lessEqual"),
                o = (0, t.convertToTensor)(a, "b", "lessEqual");
            [l, o] = (0, s.makeTypesMatch)(l, o), (0, n.assertAndGetBroadcastShape)(l.shape, o.shape);
            const i = {
                a: l,
                b: o
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const s = e.lessEqual(l, o);
                return r([l, o]), s
            }, i, null, r.LessEqual)
        }
        const l = (0, u.op)({
            lessEqual_: a
        });
        exports.lessEqual = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "lYzt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logicalAnd = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = require("./broadcast_util"),
            l = require("./operation");

        function t(l, t) {
            const a = (0, r.convertToTensor)(l, "a", "logicalAnd", "bool"),
                i = (0, r.convertToTensor)(t, "b", "logicalAnd", "bool");
            (0, n.assertAndGetBroadcastShape)(a.shape, i.shape);
            const s = {
                a: a,
                b: i
            };
            return e.ENGINE.runKernelFunc(e => e.logicalAnd(a, i), s, null, o.LogicalAnd)
        }
        const a = (0, l.op)({
            logicalAnd_: t
        });
        exports.logicalAnd = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "BsuI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.where = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = require("../util"),
            n = require("./broadcast_util"),
            s = require("./operation");

        function a(s, a, i) {
            const c = (0, o.convertToTensor)(a, "a", "where"),
                h = (0, o.convertToTensor)(i, "b", "where"),
                u = (0, o.convertToTensor)(s, "condition", "where", "bool"),
                p = (0, n.assertAndGetBroadcastShape)(c.shape, h.shape),
                d = c.broadcastTo(p),
                l = h.broadcastTo(p);
            1 === u.rank && (0, t.assert)(u.shape[0] === c.shape[0], () => "The first dimension of `a` must match the size of `condition`."), 1 !== u.rank && (0, t.assertShapesMatch)(u.shape, l.shape, "Error in where: ");
            const T = {
                condition: u,
                t: d,
                e: l
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.select(u, d, l);
                return r([u]), o
            }, T, null, r.SelectV2)
        }
        const i = (0, s.op)({
            where_: a
        });
        exports.where = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "ckME": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.clipByValueGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/greater_equal"),
            l = require("../ops/less_equal"),
            a = require("../ops/logical_and"),
            i = require("../ops/where"),
            s = require("../ops/zeros_like");
        const u = {
            kernelName: e.ClipByValue,
            inputsToSave: ["x"],
            gradFunc: (e, u, o) => {
                const [p] = u, {
                    clipValueMin: n,
                    clipValueMax: t
                } = o;
                return {
                    x: () => (0, i.where)((0, a.logicalAnd)((0, r.greaterEqual)(p, n), (0, l.lessEqual)(p, t)), e, (0, s.zerosLike)(e))
                }
            }
        };
        exports.clipByValueGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/greater_equal": "Dbo2",
        "../ops/less_equal": "FvS1",
        "../ops/logical_and": "lYzt",
        "../ops/where": "BsuI",
        "../ops/zeros_like": "PDcB"
    }],
    "Z8ze": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.prepareSplitSize = s;
        var e = require("../util");

        function s(s, t, r = 0) {
            let i = [];
            if ("number" == typeof t)(0, e.assert)(s.shape[r] % t == 0, () => "Number of splits must evenly divide the axis."), i = new Array(t).fill(s.shape[r] / t);
            else {
                const a = t.reduce((e, s) => (-1 === s && (e += 1), e), 0);
                (0, e.assert)(a <= 1, () => "There should be only one negative value in split array.");
                const n = t.indexOf(-1);
                if (-1 !== n) {
                    const e = t.reduce((e, s) => s > 0 ? e + s : e);
                    t[n] = s.shape[r] - e
                }(0, e.assert)(s.shape[r] === t.reduce((e, s) => e + s), () => "The sum of sizes must match the size of the axis dimension."), i = t
            }
            return i
        }
    }, {
        "../util": "P6nv"
    }],
    "VA1I": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.split = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            i = require("../tensor_util_env"),
            t = require("../util"),
            s = require("./operation"),
            n = require("./split_util");

        function p(s, p, u = 0) {
            const l = (0, i.convertToTensor)(s, "x", "split"),
                o = {
                    x: l
                },
                a = {
                    numOrSizeSplits: p,
                    axis: u
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const i = (0, t.parseAxisParam)(u, l.shape)[0],
                    s = (0, n.prepareSplitSize)(l, p, i);
                return e.split(l, s, i)
            }, o, null, r.SplitV, a)
        }
        const u = (0, s.op)({
            split_: p
        });
        exports.split = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./split_util": "Z8ze"
    }],
    "keWD": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concatGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/split"),
            a = require("../util");
        const s = {
            kernelName: e.Concat,
            saveAllInputs: !0,
            gradFunc: (e, s, t) => {
                const n = s.map(e => e.shape),
                    {
                        axis: o
                    } = t,
                    p = (0, a.parseAxisParam)(o, s[0].shape)[0],
                    i = n.map(e => e[p]);
                return (0, r.split)(e, i, p).map(e => () => e)
            }
        };
        exports.concatGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/split": "VA1I",
        "../util": "P6nv"
    }],
    "JjEd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2DBackpropFilter = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = p(require("../util")),
            n = p(require("./conv_util")),
            o = require("./operation"),
            a = require("./reshape");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(o, i, p, s, u, c = "NHWC", l) {
            let d = o;
            3 === o.rank && (d = (0, a.reshape)(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
            let h = i;
            3 === h.rank && (h = (0, a.reshape)(i, [1, i.shape[0], i.shape[1], i.shape[2]])), t.assert(4 === d.rank, () => "Error in conv2dDerFilter: input must be rank 4, but got shape " + `${d.shape}.`), t.assert(4 === h.rank, () => "Error in conv2dDerFilter: dy must be rank 4, but got shape " + `${h.shape}.`), t.assert(4 === p.length, () => "Error in conv2dDerFilter: filterShape must be length 4, but got " + `${p}.`);
            const f = "NHWC" === c ? d.shape[3] : d.shape[1],
                v = "NHWC" === c ? h.shape[3] : h.shape[1];
            t.assert(f === p[2], () => `Error in conv2dDerFilter: depth of input ${f}) must ` + `match input depth in filter (${p[2]}.`), t.assert(v === p[3], () => `Error in conv2dDerFilter: depth of dy (${v}) must ` + `match output depth for filter (${p[3]}).`), null != l && t.assert(t.isInt(u), () => "Error in conv2dDerFilter: pad must be an integer when using, " + `dimRoundingMode ${l} but got pad ${u}.`);
            const D = {
                    x: d,
                    dy: h
                },
                b = {
                    strides: s,
                    pad: u,
                    dataFormat: c,
                    dimRoundingMode: l
                };
            return e.ENGINE.runKernelFunc(e => {
                const r = n.convertConv2DDataFormat(c),
                    t = n.computeConv2DInfo(d.shape, p, s, 1, u, l, !1, r);
                return e.conv2dDerFilter(d, h, t)
            }, D, null, r.Conv2DBackpropFilter, b)
        }
        const u = (0, o.op)({
            conv2DBackpropFilter_: s
        });
        exports.conv2DBackpropFilter = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "GLx7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2DBackpropInput = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = u(require("../util")),
            n = u(require("./conv_util")),
            o = require("./operation"),
            a = require("./reshape");

        function p() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return p = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = p();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(o, p, u, s, i, c = "NHWC", h) {
            t.assert(o.length === p.rank, () => "Length of inShape " + `(${o.length}) and rank of dy (${p.rank}) must match`);
            let d = o,
                l = p,
                f = !1;
            3 === p.rank && (f = !0, l = (0, a.reshape)(p, [1, p.shape[0], p.shape[1], p.shape[2]]), d = [1, o[0], o[1], o[2]]), t.assert(4 === d.length, () => "Error in conv2dDerInput: inShape must be length 4, but got length " + `${d.length}.`), t.assert(4 === l.rank, () => "Error in conv2dDerInput: dy must be rank 4, but got " + `rank ${l.rank}`), t.assert(4 === u.rank, () => "Error in conv2dDerInput: filter must be rank 4, but got " + `rank ${u.rank}`);
            const v = "NHWC" === c ? d[3] : d[1],
                g = "NHWC" === c ? l.shape[3] : l.shape[1];
            t.assert(v === u.shape[2], () => `Error in conv2dDerInput: depth of input (${v}) must ` + `match input depth for filter ${u.shape[2]}.`), t.assert(g === u.shape[3], () => `Error in conv2dDerInput: depth of output (${g}) must ` + `match output depth for filter ${u.shape[3]}.`), null != h && t.assert(t.isInt(i), () => "Error in conv2dDerInput: pad must be an integer when using, " + `dimRoundingMode ${h} but got pad ${i}.`);
            const k = {
                    dy: l,
                    filter: u
                },
                m = {
                    strides: s,
                    pad: i,
                    dataFormat: c,
                    dimRoundingMode: h,
                    inputShape: d
                },
                D = e.ENGINE.runKernelFunc((e, r) => {
                    const t = n.convertConv2DDataFormat(c),
                        o = n.computeConv2DInfo(d, u.shape, s, 1, i, h, !1, t),
                        a = e.conv2dDerInput(l, u, o);
                    return r([l, u]), a
                }, k, null, r.Conv2DBackpropInput, m);
            return f ? (0, a.reshape)(D, [D.shape[1], D.shape[2], D.shape[3]]) : D
        }
        const i = (0, o.op)({
            conv2DBackpropInput_: s
        });
        exports.conv2DBackpropInput = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "f1tQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2DGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/conv2d_backprop_filter"),
            t = require("../ops/conv2d_backprop_input"),
            n = a(require("../ops/conv_util")),
            o = a(require("../util"));

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }
        const p = {
            kernelName: e.Conv2D,
            inputsToSave: ["x", "filter"],
            gradFunc: (e, i, a) => {
                const [p, u] = i, {
                    dilations: s,
                    strides: c,
                    pad: l,
                    dataFormat: f
                } = a;
                return o.assert(n.tupleValuesAreOne(s), () => "Error in gradient of conv2D: dilation rates greater than 1 " + `are not yet supported in gradients. Got dilations '${s}'`), {
                    x: () => (0, t.conv2DBackpropInput)(p.shape, e, u, c, l, f),
                    filter: () => (0, r.conv2DBackpropFilter)(p, e, u.shape, c, l, f)
                }
            }
        };
        exports.conv2DGradConfig = p;
    }, {
        "../kernel_names": "sdEe",
        "../ops/conv2d_backprop_filter": "JjEd",
        "../ops/conv2d_backprop_input": "GLx7",
        "../ops/conv_util": "Evju",
        "../util": "P6nv"
    }],
    "oJQk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2d = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            o = u(require("./conv_util")),
            s = require("./operation"),
            i = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, o, s) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(s, a, u, p, c = "NHWC", d = [1, 1], l) {
            const f = (0, t.convertToTensor)(s, "x", "conv2d"),
                v = (0, t.convertToTensor)(a, "filter", "conv2d");
            let h = f,
                b = !1;
            3 === f.rank && (b = !0, h = (0, i.reshape)(f, [1, f.shape[0], f.shape[1], f.shape[2]])), n.assert(4 === h.rank, () => `Error in conv2d: input must be rank 4, but got rank ${h.rank}.`), n.assert(4 === v.rank, () => "Error in conv2d: filter must be rank 4, but got rank " + `${v.rank}.`), null != l && n.assert(n.isInt(p), () => "Error in conv2d: pad must be an integer when using, " + `dimRoundingMode ${l} but got pad ${p}.`);
            const g = "NHWC" === c ? h.shape[3] : h.shape[1];
            n.assert(g === v.shape[2], () => `Error in conv2d: depth of input (${g}) must match ` + `input depth for filter ${v.shape[2]}.`), n.assert(o.eitherStridesOrDilationsAreOne(u, d), () => "Error in conv2D: Either strides or dilations must be 1. " + `Got strides ${u} and dilations '${d}'`);
            const k = {
                    x: h,
                    filter: v
                },
                m = {
                    strides: u,
                    pad: p,
                    dataFormat: c,
                    dilations: d,
                    dimRoundingMode: l
                },
                O = e.ENGINE.runKernelFunc((e, r) => {
                    const t = o.convertConv2DDataFormat(c),
                        n = o.computeConv2DInfo(h.shape, v.shape, u, d, p, l, !1, t),
                        s = e.conv2d(h, v, n);
                    return r([h, v]), s
                }, k, null, r.Conv2D, m);
            return b ? (0, i.reshape)(O, [O.shape[1], O.shape[2], O.shape[3]]) : O
        }
        const c = (0, s.op)({
            conv2d_: p
        });
        exports.conv2d = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "gRvo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2DBackpropInputGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/conv2d"),
            o = require("../ops/conv2d_backprop_filter");
        const n = {
            kernelName: e.Conv2DBackpropInput,
            inputsToSave: ["dy", "filter"],
            gradFunc: (e, n, p) => {
                const [t, a] = n, {
                    strides: d,
                    pad: c,
                    dataFormat: i,
                    dimRoundingMode: s
                } = p;
                return {
                    dy: () => (0, r.conv2d)(e, a, d, c, i, 1, s),
                    filter: () => (0, o.conv2DBackpropFilter)(e, t, a.shape, d, c, i, s)
                }
            }
        };
        exports.conv2DBackpropInputGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/conv2d": "oJQk",
        "../ops/conv2d_backprop_filter": "JjEd"
    }],
    "g2Xi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv3DBackpropFilter = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = s(require("../util")),
            n = s(require("./conv_util")),
            o = require("./operation"),
            p = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var p = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    p && (p.get || p.set) ? Object.defineProperty(t, o, p) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(o, a, s, i, u) {
            let c = o;
            4 === o.rank && (c = (0, p.reshape)(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]));
            let l = a;
            4 === l.rank && (l = (0, p.reshape)(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])), t.assert(5 === c.rank, () => "Error in conv3dDerFilter: input must be rank 5, but got shape " + `${c.shape}.`), t.assert(5 === l.rank, () => "Error in conv3dDerFilter: dy must be rank 5, but got shape " + `${l.shape}.`), t.assert(5 === s.length, () => "Error in conv3dDerFilter: filterShape must be length 5, but got " + `${s}.`), t.assert(c.shape[4] === s[3], () => `Error in conv3dDerFilter: depth of input ${c.shape[4]}) must ` + `match input depth in filter (${s[3]}.`), t.assert(l.shape[4] === s[4], () => `Error in conv3dDerFilter: depth of dy (${l.shape[4]}) must ` + `match output depth for filter (${s[4]}).`);
            const h = {
                    x: c,
                    y: l
                },
                f = {
                    strides: i,
                    pad: u
                };
            return e.ENGINE.runKernelFunc(e => {
                const r = n.computeConv3DInfo(c.shape, s, i, 1, u);
                return e.conv3dDerFilter(c, l, r)
            }, h, null, r.Conv3DBackpropFilterV2, f)
        }
        const u = (0, o.op)({
            conv3DBackpropFilter_: i
        });
        exports.conv3DBackpropFilter = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "bEFz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv3DBackpropInput = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = u(require("../util")),
            n = u(require("./conv_util")),
            o = require("./operation"),
            p = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var p = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    p && (p.get || p.set) ? Object.defineProperty(t, o, p) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(o, a, u, s, i) {
            t.assert(o.length === a.rank, () => "Length of inShape " + `(${o.length}) and rank of dy (${a.rank}) must match`);
            let c = o,
                h = a,
                f = !1;
            4 === a.rank && (f = !0, h = (0, p.reshape)(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]]), c = [1, o[0], o[1], o[2], o[3]]);
            const l = c[4],
                d = h.shape[4];
            t.assert(5 === c.length, () => "Error in conv3dDerInput: inShape must be length 5, but got length " + `${c.length}.`), t.assert(5 === h.rank, () => "Error in conv3dDerInput: dy must be rank 5, but got " + `rank ${h.rank}`), t.assert(5 === u.rank, () => "Error in conv3dDerInput: filter must be rank 5, but got " + `rank ${u.rank}`), t.assert(l === u.shape[3], () => `Error in conv3dDerInput: depth of input (${l}) must ` + `match input depth for filter ${u.shape[3]}.`), t.assert(d === u.shape[4], () => `Error in conv3dDerInput: depth of output (${d}) must ` + `match output depth for filter ${u.shape[4]}.`);
            const v = {
                    dy: h
                },
                k = {
                    pad: i
                },
                g = e.ENGINE.runKernelFunc(e => {
                    const r = n.computeConv3DInfo(c, u.shape, s, 1, i);
                    return e.conv3dDerInput(h, u, r)
                }, v, null, r.Conv3DBackpropInputV2, k);
            return f ? (0, p.reshape)(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g
        }
        const i = (0, o.op)({
            conv3DBackpropInput_: s
        });
        exports.conv3DBackpropInput = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "sdO1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv3DGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/conv3d_backprop_filter"),
            t = require("../ops/conv3d_backprop_input"),
            n = require("../ops/conv_util"),
            o = a(require("../util"));

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }
        const p = {
            kernelName: e.Conv3D,
            inputsToSave: ["x", "filter"],
            gradFunc: (e, i, a) => {
                const {
                    dilations: p,
                    strides: u,
                    pad: s
                } = a;
                o.assert((0, n.tupleValuesAreOne)(p), () => "Error in gradient of conv3D: dilation rates greater than 1 are " + `not yet supported in gradients. Got dilations '${p}'`);
                const [c, l] = i;
                return {
                    x: () => (0, t.conv3DBackpropInput)(c.shape, e, l, u, s),
                    filter: () => (0, r.conv3DBackpropFilter)(c, e, l.shape, u, s)
                }
            }
        };
        exports.conv3DGradConfig = p;
    }, {
        "../kernel_names": "sdEe",
        "../ops/conv3d_backprop_filter": "g2Xi",
        "../ops/conv3d_backprop_input": "bEFz",
        "../ops/conv_util": "Evju",
        "../util": "P6nv"
    }],
    "AdWB": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sin = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            i = require("./operation");

        function o(i) {
            const o = (0, r.convertToTensor)(i, "x", "sin"),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.sin(o);
                return n([o]), r
            }, s, null, n.Sin)
        }
        const s = (0, i.op)({
            sin_: o
        });
        exports.sin = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "XliK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cosGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/mul"),
            o = require("../ops/neg"),
            n = require("../ops/sin");
        const t = {
            kernelName: e.Cos,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [i] = t;
                return {
                    x: () => (0, s.mul)((0, o.neg)((0, n.sin)((0, r.cast)(i, "float32"))), e)
                }
            }
        };
        exports.cosGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/sin": "AdWB"
    }],
    "fN3P": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sinh = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            i = require("./operation");

        function o(i) {
            const o = (0, r.convertToTensor)(i, "x", "sinh"),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.sinh(o);
                return n([o]), r
            }, s, null, n.Sinh)
        }
        const s = (0, i.op)({
            sinh_: o
        });
        exports.sinh = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "VVun": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.coshGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/mul"),
            o = require("../ops/sinh");
        const t = {
            kernelName: e.Cosh,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => (0, s.mul)((0, o.sinh)((0, r.cast)(n, "float32")), e)
                }
            }
        };
        exports.coshGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/mul": "k2PI",
        "../ops/sinh": "fN3P"
    }],
    "uQkx": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transpose = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            o = require("./operation");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, o, u) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function a(o, s) {
            const u = (0, t.convertToTensor)(o, "x", "transpose");
            if (null == s && (s = u.shape.map((e, r) => r).reverse()), n.assert(u.rank === s.length, () => `Error in transpose: rank of input ${u.rank} ` + `must match length of perm ${s}.`), s.forEach(e => {
                    n.assert(e >= 0 && e < u.rank, () => `All entries in 'perm' must be between 0 and ${u.rank-1}` + ` but got ${s}`)
                }), u.rank <= 1) return u.clone();
            const a = {
                    x: u
                },
                i = {
                    perm: s
                };
            return e.ENGINE.runKernelFunc(e => e.transpose(u, s), a, null, r.Transpose, i)
        }
        const i = (0, o.op)({
            transpose_: a
        });
        exports.transpose = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "Kzhc": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cumsum = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            s = require("./axis_util"),
            u = require("./operation"),
            t = require("./transpose");

        function o(u, o = 0, i = !1, c = !1) {
            const l = (0, n.convertToTensor)(u, "x", "cumsum"),
                m = {
                    x: l
                },
                a = {
                    axis: o,
                    exclusive: i,
                    reverse: c
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = (0, s.getAxesPermutation)([o], l.rank);
                let u = l;
                null != n && (u = (0, t.transpose)(l, n));
                const m = (0, s.getInnerMostAxes)(1, l.rank)[0];
                let a = e.cumsum(u, m, i, c);
                if (r([l]), null != n) {
                    const e = (0, s.getUndoAxesPermutation)(n);
                    a = (0, t.transpose)(a, e)
                }
                return a
            }, m, null, r.Cumsum, a)
        }
        const i = (0, u.op)({
            cumsum_: o
        });
        exports.cumsum = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./axis_util": "DsMP",
        "./operation": "JtaO",
        "./transpose": "uQkx"
    }],
    "KT66": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cumsumGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/axis_util"),
            s = require("../ops/cumsum"),
            u = require("../ops/transpose");
        const t = {
            kernelName: e.Cumsum,
            inputsToSave: ["x"],
            gradFunc: (e, t, n) => {
                const [o] = t, {
                    axis: i,
                    exclusive: a,
                    reverse: m
                } = n;
                return {
                    x: () => {
                        const t = (0, r.getAxesPermutation)([i], o.rank);
                        let n = (0, s.cumsum)(e, i, a, !m);
                        return null != t && (n = (0, u.transpose)(n, t)), n
                    }
                }
            }
        };
        exports.cumsumGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/axis_util": "DsMP",
        "../ops/cumsum": "Kzhc",
        "../ops/transpose": "uQkx"
    }],
    "pXLg": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthwiseConv2dNativeBackpropFilter = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            p = require("./operation"),
            t = require("./reshape");

        function i(p, i, a, s) {
            let n = p;
            3 === p.rank && (n = (0, t.reshape)(p, [1, p.shape[0], p.shape[1], p.shape[2]]));
            let o = i;
            3 === o.rank && (o = (0, t.reshape)(i, [1, i.shape[0], i.shape[1], i.shape[2]]));
            const h = {
                x: n,
                dy: o
            };
            return e.ENGINE.runKernelFunc(e => e.depthwiseConv2DDerFilter(n, o, s), h, null, r.DepthwiseConv2dNativeBackpropFilter)
        }
        const a = (0, p.op)({
            depthwiseConv2dNativeBackpropFilter_: i
        });
        exports.depthwiseConv2dNativeBackpropFilter = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "mUFN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthwiseConv2dNativeBackpropInput = void 0;
        var e = require("../engine"),
            p = require("../kernel_names"),
            r = require("./operation"),
            t = require("./reshape");

        function n(r, n, s, a) {
            let o = n,
                i = !1;
            3 === n.rank && (i = !0, o = (0, t.reshape)(n, [1, n.shape[0], n.shape[1], n.shape[2]]));
            const u = {
                    dy: o
                },
                h = e.ENGINE.runKernelFunc(e => e.depthwiseConv2DDerInput(o, s, a), u, null, p.DepthwiseConv2dNativeBackpropInput);
            return i ? (0, t.reshape)(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
        }
        const s = (0, r.op)({
            depthwiseConv2dNativeBackpropInput_: n
        });
        exports.depthwiseConv2dNativeBackpropInput = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "xQGO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthwiseConv2dNativeGradConfig = void 0;
        var e = require("../kernel_names"),
            t = a(require("../ops/conv_util")),
            r = require("../ops/depthwise_conv2d_native_backprop_filter"),
            n = require("../ops/depthwise_conv2d_native_backprop_input"),
            i = a(require("../util"));

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = o();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, i, a) : r[i] = e[i]
                } return r.default = e, t && t.set(e, r), r
        }
        const s = {
            kernelName: e.DepthwiseConv2dNative,
            inputsToSave: ["x", "filter"],
            gradFunc: (e, o, a) => {
                const {
                    dilations: s,
                    strides: d,
                    pad: p,
                    dimRoundingMode: u
                } = a, l = null == s ? [1, 1] : s;
                i.assert(t.tupleValuesAreOne(l), () => "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations " + `'${l}'`);
                const [v, f] = o;
                i.assert(4 === v.rank, () => "Error in gradient of depthwiseConv2dNative: input must be " + `rank 4, but got rank ${v.rank}.`), i.assert(4 === f.rank, () => "Error in gradient of depthwiseConv2dNative: filter must be " + `rank 4, but got rank ${f.rank}.`), i.assert(v.shape[3] === f.shape[2], () => "Error in gradient of depthwiseConv2d: number of input " + `channels (${v.shape[3]}) must match the inChannels dimension ` + `in filter ${f.shape[2]}.`), i.assert(t.eitherStridesOrDilationsAreOne(d, l), () => "Error in gradient of depthwiseConv2d: Either strides or " + `dilations must be  1. Got strides ${d} and dilations ` + `'${l}'.`), null != u && i.assert(i.isInt(p), () => "Error in depthwiseConv2d: pad must be an integer when using, " + `dimRoundingMode ${u} but got pad ${p}.`);
                const c = t.computeConv2DInfo(v.shape, f.shape, d, l, p, u, !0);
                return {
                    x: () => (0, n.depthwiseConv2dNativeBackpropInput)(v.shape, e, f, c),
                    filter: () => (0, r.depthwiseConv2dNativeBackpropFilter)(v, e, f.shape, c)
                }
            }
        };
        exports.depthwiseConv2dNativeGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/conv_util": "Evju",
        "../ops/depthwise_conv2d_native_backprop_filter": "pXLg",
        "../ops/depthwise_conv2d_native_backprop_input": "mUFN",
        "../util": "P6nv"
    }],
    "VsH5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.dilation2dGradConfig = void 0;
        var e = require("../engine"),
            r = require("../kernel_names");
        const i = {
            kernelName: r.Dilation2D,
            inputsToSave: ["x", "filter"],
            gradFunc: (i, n, t) => {
                const [o, l] = n, a = {
                    x: o,
                    filter: l,
                    dy: i
                }, d = {
                    x: o,
                    filter: l,
                    dy: i
                };
                return {
                    x: () => e.ENGINE.runKernel(r.Dilation2DBackpropInput, a, t),
                    filter: () => e.ENGINE.runKernel(r.Dilation2DBackpropFilter, d, t)
                }
            }
        };
        exports.dilation2dGradConfig = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "ESiR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.divGradConfig = void 0;
        var e = require("../kernel_names"),
            r = p(require("../ops/broadcast_util")),
            t = require("../ops/div"),
            o = require("../ops/mul"),
            n = require("../ops/neg"),
            s = require("../ops/reshape"),
            a = require("../ops/square"),
            u = require("../ops/sum");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, n, s) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }
        const c = {
            kernelName: e.Div,
            inputsToSave: ["a", "b"],
            gradFunc: (e, i) => {
                const [p, c] = i, l = r.assertAndGetBroadcastShape(p.shape, c.shape);
                return {
                    a: () => {
                        const o = (0, t.div)(e, c.toFloat()),
                            n = r.getReductionAxes(p.shape, l);
                        return n.length > 0 ? (0, u.sum)(o, n).reshape(p.shape) : o
                    },
                    b: () => {
                        let i = (0, o.mul)(e, p.toFloat());
                        const d = r.getReductionAxes(c.shape, l);
                        d.length > 0 && (i = (0, s.reshape)((0, u.sum)(i, d), c.shape));
                        const f = (0, a.square)(c);
                        return (0, n.neg)((0, t.div)(i, f.toFloat()))
                    }
                }
            }
        };
        exports.divGradConfig = c;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/div": "D8Fc",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/reshape": "QI4k",
        "../ops/square": "mJRX",
        "../ops/sum": "ITAy"
    }],
    "NTdC": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.eluGradConfig = void 0;
        var e = require("../engine"),
            r = require("../kernel_names");
        const u = {
            kernelName: r.Elu,
            outputsToSave: [!0],
            gradFunc: (u, n) => {
                const [l] = n, o = e => e.eluDer(u, l), t = {
                    dy: u,
                    y: l
                };
                return {
                    x: () => e.ENGINE.runKernelFunc(o, t, null, r.EluGrad)
                }
            }
        };
        exports.eluGradConfig = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "zsk9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.exp = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function t(o) {
            const t = (0, n.convertToTensor)(o, "x", "exp"),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.exp(t);
                return r([n]), n
            }, u, null, r.Exp)
        }
        const u = (0, o.op)({
            exp_: t
        });
        exports.exp = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "rek3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.erfGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/exp"),
            s = require("../ops/mul"),
            u = require("../ops/neg"),
            o = require("../ops/square");
        const t = {
            kernelName: e.Erf,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t, a = (0, s.mul)((0, r.exp)((0, u.neg)((0, o.square)(n))), 2 / Math.sqrt(Math.PI));
                return {
                    x: () => (0, s.mul)(e, a)
                }
            }
        };
        exports.erfGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/exp": "zsk9",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/square": "mJRX"
    }],
    "Y9DI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.expGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul");
        const o = {
            kernelName: e.Exp,
            outputsToSave: [!0],
            gradFunc: (e, o) => {
                const [t] = o;
                return {
                    x: () => (0, r.mul)(e, t)
                }
            }
        };
        exports.expGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI"
    }],
    "xe2w": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.expm1GradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/exp"),
            o = require("../ops/mul");
        const p = {
            kernelName: e.Expm1,
            inputsToSave: ["x"],
            gradFunc: (e, p) => {
                const [s] = p;
                return {
                    x: () => (0, o.mul)(e, (0, r.exp)(s))
                }
            }
        };
        exports.expm1GradConfig = p;
    }, {
        "../kernel_names": "sdEe",
        "../ops/exp": "zsk9",
        "../ops/mul": "k2PI"
    }],
    "gPYw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.floorGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const o = {
            kernelName: e.Floor,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.floorGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "mHhM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.floorDivGradConfig = void 0;
        var e = require("../kernel_names"),
            t = require("../ops/broadcast_util");
        const o = {
            kernelName: e.FloorDiv,
            inputsToSave: ["a", "b"],
            gradFunc: (e, o) => {
                const [r, s] = o, a = (0, t.assertAndGetBroadcastShape)(r.shape, s.shape);
                return {
                    a: () => {
                        const o = e.div(s.toFloat()),
                            n = (0, t.getReductionAxes)(r.shape, a);
                        return n.length > 0 ? o.sum(n).reshape(r.shape) : o
                    },
                    b: () => {
                        let o = e.mul(r.toFloat());
                        const n = (0, t.getReductionAxes)(s.shape, a);
                        n.length > 0 && (o = o.sum(n).reshape(s.shape));
                        const u = s.square();
                        return o.div(u.toFloat()).neg()
                    }
                }
            }
        };
        exports.floorDivGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J"
    }],
    "XwKw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rsqrt = void 0;
        var r = require("../engine"),
            e = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("./operation");

        function s(n) {
            const s = (0, t.convertToTensor)(n, "x", "rsqrt"),
                o = {
                    x: s
                };
            return r.ENGINE.runKernelFunc((r, e) => {
                const t = r.rsqrt(s);
                return e([s]), t
            }, o, null, e.Rsqrt)
        }
        const o = (0, n.op)({
            rsqrt_: s
        });
        exports.rsqrt = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "mfii": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tile = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            o = require("./operation");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(o, u) {
            const i = (0, t.convertToTensor)(o, "x", "tile", null);
            n.assert(i.rank === u.length, () => `Error in transpose: rank of input ${i.rank} ` + `must match length of reps ${u}.`);
            const l = [i],
                s = {
                    x: i
                },
                a = {
                    reps: u
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.tile(i, u);
                return r([i]), t
            }, s, null, r.Tile, a, l)
        }
        const s = (0, o.op)({
            tile_: l
        });
        exports.tile = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "MxAQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fusedBatchNormGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            s = require("../ops/broadcast_util"),
            a = require("../ops/mul"),
            u = require("../ops/reshape"),
            l = require("../ops/rsqrt"),
            p = require("../ops/scalar"),
            t = require("../ops/sub"),
            n = require("../ops/sum"),
            o = require("../ops/tile");
        const m = {
            kernelName: e.FusedBatchNorm,
            inputsToSave: ["x", "mean", "variance", "scale"],
            gradFunc: (e, m, i) => {
                const {
                    varianceEpsilon: h
                } = i, [c, d, q, f] = m, k = null == f ? (0, p.scalar)(1) : f, v = (0, s.getReductionAxes)(d.shape, c.shape), x = [];
                if (1 === d.rank) {
                    for (let e = 0; e < c.shape.length - 1; ++e) x.push(c.shape[e]);
                    x.push(1)
                }
                const g = (0, t.sub)(c, d),
                    b = (0, a.mul)(e, k),
                    N = (0, l.rsqrt)((0, r.add)(q, (0, p.scalar)(h))),
                    _ = (0, a.mul)((0, a.mul)((0, a.mul)(N, N), N), (0, p.scalar)(-.5));
                return {
                    x: () => 1 === d.rank ? (0, u.reshape)((0, a.mul)((0, a.mul)(e, (0, o.tile)(N.as4D(1, 1, 1, d.shape[0]), x)), k), c.shape) : (0, u.reshape)((0, a.mul)((0, a.mul)(e, N), k), c.shape),
                    mean: () => {
                        let e = (0, a.mul)((0, a.mul)(N, (0, p.scalar)(-1)), b);
                        return 1 === d.rank && (e = (0, n.sum)(e, v)), (0, u.reshape)(e, d.shape)
                    },
                    variance: () => {
                        let e = (0, a.mul)((0, a.mul)(_, g), b);
                        return 1 === d.rank && (e = (0, n.sum)(e, v)), (0, u.reshape)(e, d.shape)
                    },
                    scale: () => {
                        const r = (0, a.mul)(g, N);
                        let s = (0, a.mul)(e, r);
                        return 1 === d.rank && (s = (0, n.sum)(s, v)), (0, u.reshape)(s, d.shape)
                    },
                    offset: () => {
                        let r = e;
                        return 1 === d.rank && (r = (0, n.sum)(r, v)), (0, u.reshape)(r, d.shape)
                    }
                }
            }
        };
        exports.fusedBatchNormGradConfig = m;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/broadcast_util": "Xh9J",
        "../ops/mul": "k2PI",
        "../ops/reshape": "QI4k",
        "../ops/rsqrt": "XwKw",
        "../ops/scalar": "Ay42",
        "../ops/sub": "dGex",
        "../ops/sum": "ITAy",
        "../ops/tile": "mfii"
    }],
    "GWRE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.unsortedSegmentSum = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            t = require("../tensor_util_env"),
            r = require("../util"),
            u = require("./operation");

        function s(u, s, o) {
            const m = (0, t.convertToTensor)(u, "x", "unsortedSegmentSum"),
                i = (0, t.convertToTensor)(s, "segmentIds", "unsortedSegmentSum", "int32");
            (0, r.assert)((0, r.isInt)(o), () => "numSegments must be of dtype int");
            const S = {
                    x: m,
                    segmentIds: i
                },
                d = {
                    numSegments: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const t = e.unsortedSegmentSum(m, i, o);
                return n([i]), t
            }, S, null, n.UnsortedSegmentSum, d)
        }
        const o = (0, u.op)({
            unsortedSegmentSum_: s
        });
        exports.unsortedSegmentSum = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "yxTd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.gatherGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/axis_util"),
            s = require("../ops/reshape"),
            t = require("../ops/transpose"),
            n = require("../ops/unsorted_segment_sum"),
            o = require("../util");
        const i = {
            kernelName: e.GatherV2,
            inputsToSave: ["x", "indices"],
            gradFunc: (e, i, p) => {
                const [l, c] = i, {
                    axis: h
                } = p, g = (0, o.parseAxisParam)(h, l.shape)[0];
                return {
                    x: () => {
                        const o = l.shape,
                            i = c.size,
                            p = o.slice(0, g),
                            d = p.length,
                            x = o.slice(h, o.length).slice(1),
                            f = x.length,
                            m = a(0, d),
                            q = a(d + 1, d + 1 + f),
                            _ = u([p, [i], x]),
                            v = (0, s.reshape)(e, _),
                            G = (0, s.reshape)(c, [i]),
                            P = u([
                                [d], m, q
                            ]),
                            S = (0, t.transpose)(v, P);
                        let k = (0, n.unsortedSegmentSum)(S, G, l.shape[g]);
                        const A = (0, r.getUndoAxesPermutation)(P);
                        return k = (0, t.transpose)(k, A)
                    },
                    indices: () => c
                }
            }
        };

        function a(e, r) {
            const s = [];
            for (let t = e; t < r; ++t) s.push(t);
            return s
        }

        function u(e) {
            const r = [];
            for (let s = 0; s < e.length; ++s)
                for (let t = 0; t < e[s].length; ++t) r.push(e[s][t]);
            return r
        }
        exports.gatherGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/axis_util": "DsMP",
        "../ops/reshape": "QI4k",
        "../ops/transpose": "uQkx",
        "../ops/unsorted_segment_sum": "GWRE",
        "../util": "P6nv"
    }],
    "hc7R": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.greaterEqualGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const a = {
            kernelName: e.GreaterEqual,
            inputsToSave: ["a", "b"],
            gradFunc: (e, a) => {
                const [o, s] = a;
                return {
                    a: () => (0, r.zerosLike)(o),
                    b: () => (0, r.zerosLike)(s)
                }
            }
        };
        exports.greaterEqualGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "W6R7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.identityGradConfig = void 0;
        var e = require("../kernel_names");
        const t = {
            kernelName: e.Identity,
            gradFunc: e => ({
                x: () => e.toFloat()
            })
        };
        exports.identityGradConfig = t;
    }, {
        "../kernel_names": "sdEe"
    }],
    "lKGj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isFiniteGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const i = {
            kernelName: e.IsFinite,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.isFiniteGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "sqJA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isInfGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const s = {
            kernelName: e.IsInf,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.isInfGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "gPIs": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isNanGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const s = {
            kernelName: e.IsNan,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.isNanGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "etSi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.log1pGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            o = require("../ops/div");
        const d = {
            kernelName: e.Log1p,
            inputsToSave: ["x"],
            gradFunc: (e, d) => {
                const [s] = d;
                return {
                    x: () => (0, o.div)(e, (0, r.add)(s, 1))
                }
            }
        };
        exports.log1pGradConfig = d;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/div": "D8Fc"
    }],
    "GDRk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            o = require("../ops/div");
        const s = {
            kernelName: e.Log,
            inputsToSave: ["x"],
            gradFunc: (e, s) => {
                const [t] = s;
                return {
                    x: () => (0, o.div)(e, (0, r.cast)(t, "float32"))
                }
            }
        };
        exports.logGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc"
    }],
    "BAfN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logSoftmaxGradConfig = void 0;
        var e = require("../kernel_names");
        const o = {
            kernelName: e.LogSoftmax,
            inputsToSave: [],
            outputsToSave: [!0],
            gradFunc: (e, o, t) => {
                const [r] = o, {
                    axis: s
                } = t;
                return {
                    logits: () => {
                        const o = r.exp();
                        return e.sub(e.sum(s, !0).mul(o))
                    }
                }
            }
        };
        exports.logSoftmaxGradConfig = o;
    }, {
        "../kernel_names": "sdEe"
    }],
    "kRNN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.localResponseNormalizationBackprop = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            r = require("./operation");

        function a(r, a, n, p = 5, i = 1, s = 1, t = .5) {
            const l = {
                    x: r,
                    y: a,
                    dy: n
                },
                c = {
                    depthRadius: p,
                    bias: i,
                    alpha: s,
                    beta: t
                };
            return e.ENGINE.runKernelFunc(e => e.LRNGrad(n, r, a, p, i, s, t), l, null, o.LRNBackprop, c)
        }
        const n = (0, r.op)({
            localResponseNormalizationBackprop_: a
        });
        exports.localResponseNormalizationBackprop = n;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "./operation": "JtaO"
    }],
    "mpRs": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.lrnGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/local_response_normalization_backprop");
        const o = {
            kernelName: e.LRN,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (e, o, a) => {
                const [n, s] = o, {
                    depthRadius: t,
                    bias: p,
                    alpha: i,
                    beta: l
                } = a;
                return {
                    x: () => (0, r.localResponseNormalizationBackprop)(n, s, e, t, p, i, l)
                }
            }
        };
        exports.lrnGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/local_response_normalization_backprop": "kRNN"
    }],
    "WG94": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.equal = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util"),
            u = require("../tensor_util_env"),
            a = require("./broadcast_util"),
            n = require("./operation");

        function o(n, o) {
            let s = (0, u.convertToTensor)(n, "a", "equal"),
                l = (0, u.convertToTensor)(o, "b", "equal");
            [s, l] = (0, t.makeTypesMatch)(s, l), (0, a.assertAndGetBroadcastShape)(s.shape, l.shape);
            const i = {
                a: s,
                b: l
            };
            return e.ENGINE.runKernelFunc(e => e.equal(s, l), i, null, r.Equal)
        }
        const s = (0, n.op)({
            equal_: o
        });
        exports.equal = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "h2YN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.gradForMinAndMax = s;
        var e = u(require("../ops/axis_util")),
            r = require("../ops/cast"),
            t = require("../ops/equal"),
            n = require("../ops/mul"),
            a = require("../ops/reshape"),
            o = require("../ops/transpose");

        function p() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return p = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = p();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, a, o) : t[a] = e[a]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(p, u, s, i, c) {
            return u.rank < s.rank && (u = (0, a.reshape)(u, e.expandShapeToKeepDim(u.shape, i))), p.rank < s.rank && (p = (0, a.reshape)(p, e.expandShapeToKeepDim(p.shape, i))), {
                x: () => {
                    const e = (0, n.mul)(p, (0, r.cast)((0, t.equal)(s, u), p.dtype));
                    return null == c ? e : (0, o.transpose)(e, c)
                }
            }
        }
    }, {
        "../ops/axis_util": "DsMP",
        "../ops/cast": "qqq3",
        "../ops/equal": "WG94",
        "../ops/mul": "k2PI",
        "../ops/reshape": "QI4k",
        "../ops/transpose": "uQkx"
    }],
    "KejH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxGradConfig = void 0;
        var e = require("../kernel_names"),
            r = u(require("../ops/axis_util")),
            t = require("../ops/transpose"),
            n = u(require("../util")),
            o = require("./min_max_grad_util");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, o, u) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }
        const i = {
            kernelName: e.Max,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (e, a, u) => {
                const i = u,
                    {
                        reductionIndices: s
                    } = i,
                    [p, c] = a,
                    f = n.parseAxisParam(s, p.shape),
                    l = r.getAxesPermutation(f, p.rank),
                    d = (0, o.gradForMinAndMax)(e, c, p, f, l);
                return {
                    x: () => {
                        let e = d.x();
                        return null != l && (e = (0, t.transpose)(e)), e
                    }
                }
            }
        };
        exports.maxGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/axis_util": "DsMP",
        "../ops/transpose": "uQkx",
        "../util": "P6nv",
        "./min_max_grad_util": "h2YN"
    }],
    "Ndy5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.less = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            s = require("../tensor_util"),
            t = require("../tensor_util_env"),
            n = require("./broadcast_util"),
            o = require("./operation");

        function u(o, u) {
            let a = (0, t.convertToTensor)(o, "a", "less"),
                l = (0, t.convertToTensor)(u, "b", "less");
            [a, l] = (0, s.makeTypesMatch)(a, l), (0, n.assertAndGetBroadcastShape)(a.shape, l.shape);
            const i = {
                a: a,
                b: l
            };
            return e.ENGINE.runKernelFunc(e => e.less(a, l), i, null, r.Less)
        }
        const a = (0, o.op)({
            less_: u
        });
        exports.less = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "wKJk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maximumGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            a = require("../ops/greater_equal"),
            s = require("../ops/less"),
            u = require("../ops/mul");
        const t = {
            kernelName: e.Maximum,
            inputsToSave: ["a", "b"],
            gradFunc: (e, t) => {
                const [o, i] = t;
                return {
                    a: () => (0, u.mul)(e, (0, r.cast)((0, a.greaterEqual)(o, i), "float32")),
                    b: () => (0, u.mul)(e, (0, r.cast)((0, s.less)(o, i), "float32"))
                }
            }
        };
        exports.maximumGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/greater_equal": "Dbo2",
        "../ops/less": "Ndy5",
        "../ops/mul": "k2PI"
    }],
    "LNEW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPool3dBackprop = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = i(require("../util")),
            a = i(require("./conv_util")),
            n = require("./operation"),
            p = require("./reshape");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var o = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var n = t ? Object.getOwnPropertyDescriptor(e, a) : null;
                    n && (n.get || n.set) ? Object.defineProperty(o, a, n) : o[a] = e[a]
                } return o.default = e, r && r.set(e, o), o
        }

        function u(n, s, i, u, l, c = [1, 1, 1], d, k) {
            const h = (0, o.convertToTensor)(n, "dy", "maxPool3dBackprop"),
                f = (0, o.convertToTensor)(s, "input", "maxPool3dBackprop"),
                m = (0, o.convertToTensor)(i, "output", "maxPool3dBackprop");
            let P = h,
                b = f,
                x = m,
                g = !1;
            4 === f.rank && (g = !0, P = (0, p.reshape)(h, [1, h.shape[0], h.shape[1], h.shape[2], h.shape[3]]), b = (0, p.reshape)(f, [1, f.shape[0], f.shape[1], f.shape[2], f.shape[3]]), x = (0, p.reshape)(m, [1, m.shape[0], m.shape[1], m.shape[2], m.shape[3]])), t.assert(5 === P.rank, () => "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + `${P.rank}.`), t.assert(5 === b.rank, () => "Error in maxPool3dBackprop: input must be rank 5 but got rank " + `${b.rank}.`), t.assert(5 === x.rank, () => "Error in maxPool3dBackprop: output must be rank 5 but got rank " + `${x.rank}.`), t.assert(a.eitherStridesOrDilationsAreOne(l, c), () => "Error in maxPool3dBackprop: Either strides or dilations " + `must be 1. Got strides ${l} and dilations '${c}'`), null != k && t.assert(t.isInt(d), () => "Error in maxPool3dBackprop: pad must be an integer when " + `using, dimRoundingMode ${k} but got pad ${d}.`);
            const v = {
                    dy: P,
                    input: b,
                    output: x
                },
                y = {
                    filterSize: u,
                    strides: l,
                    dilations: c,
                    pad: d,
                    dimRoundingMode: k
                },
                B = e.ENGINE.runKernelFunc(e => {
                    const r = a.computePool3DInfo(b.shape, u, l, c, d, k);
                    return e.maxPool3dBackprop(P, b, x, r)
                }, v, null, r.MaxPool3DBackprop, y);
            return g ? (0, p.reshape)(B, [B.shape[1], B.shape[2], B.shape[3], B.shape[4]]) : B
        }
        const l = (0, n.op)({
            maxPool3dBackprop_: u
        });
        exports.maxPool3dBackprop = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "TipK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPool3DGradConfig = void 0;
        var o = require("../kernel_names"),
            e = require("../ops/max_pool_3d_backprop");
        const r = {
            kernelName: o.MaxPool3D,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (o, r, a) => {
                const [t, i] = r, {
                    filterSize: n,
                    strides: s,
                    dilations: d,
                    pad: l,
                    dimRoundingMode: p
                } = a, u = null == d ? [1, 1, 1] : d;
                return {
                    x: () => (0, e.maxPool3dBackprop)(o, t, i, n, s, u, l, p)
                }
            }
        };
        exports.maxPool3DGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/max_pool_3d_backprop": "LNEW"
    }],
    "zf8m": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPoolBackprop = void 0;
        var r = require("../engine"),
            e = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = p(require("../util")),
            n = p(require("./conv_util")),
            a = require("./operation");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return u = function() {
                return r
            }, r
        }

        function p(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var e = u();
            if (e && e.has(r)) return e.get(r);
            var o = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in r)
                if (Object.prototype.hasOwnProperty.call(r, n)) {
                    var a = t ? Object.getOwnPropertyDescriptor(r, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(o, n, a) : o[n] = r[n]
                } return o.default = r, e && e.set(r, o), o
        }

        function i(a, u, p, i, c, s, l) {
            const k = (0, o.convertToTensor)(a, "dy", "maxPoolBackprop"),
                f = (0, o.convertToTensor)(u, "input", "maxPoolBackprop"),
                d = (0, o.convertToTensor)(p, "output", "maxPoolBackprop");
            t.assert(f.rank === k.rank, () => `Rank of input (${f.rank}) does not match rank of dy ` + `(${k.rank})`), t.assert(4 === k.rank, () => "Error in maxPoolBackprop: dy must be rank 4 but got rank " + `${k.rank}.`), t.assert(4 === f.rank, () => "Error in maxPoolBackprop: input must be rank 4 but got rank " + `${f.rank}.`), null != l && t.assert(t.isInt(s), () => "Error in maxPoolBackprop: pad must be an integer when using, " + `dimRoundingMode ${l} but got pad ${s}.`);
            const m = {
                    dy: k,
                    input: f,
                    output: d
                },
                P = {
                    filterSize: i,
                    strides: c,
                    pad: s,
                    dimRoundingMode: l
                };
            return r.ENGINE.runKernelFunc(r => {
                const e = n.computePool2DInfo(f.shape, i, c, 1, s, l);
                return r.maxPoolBackprop(k, f, d, e)
            }, m, null, e.MaxPoolBackprop, P)
        }
        const c = (0, a.op)({
            maxPoolBackprop_: i
        });
        exports.maxPoolBackprop = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO"
    }],
    "CBRa": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPoolGradConfig = void 0;
        var e = require("../kernel_names"),
            o = require("../ops/max_pool_backprop");
        const r = {
            kernelName: e.MaxPool,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (e, r, a) => {
                const [t, s] = r, {
                    filterSize: p,
                    strides: i,
                    pad: n
                } = a;
                return {
                    x: () => (0, o.maxPoolBackprop)(e, t, s, p, i, n)
                }
            }
        };
        exports.maxPoolGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/max_pool_backprop": "zf8m"
    }],
    "MsiO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.minGradConfig = void 0;
        var e = require("../kernel_names"),
            r = a(require("../ops/axis_util")),
            t = require("../ops/transpose"),
            n = a(require("../util")),
            o = require("./min_max_grad_util");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }
        const u = {
            kernelName: e.Min,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (e, i, a) => {
                const u = a,
                    {
                        axis: s
                    } = u,
                    [p, f] = i,
                    l = n.parseAxisParam(s, p.shape),
                    c = r.getAxesPermutation(l, p.rank),
                    d = (0, o.gradForMinAndMax)(e, f, p, l, c);
                return {
                    x: () => {
                        let e = d.x();
                        return null != c && (e = (0, t.transpose)(e)), e
                    }
                }
            }
        };
        exports.minGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/axis_util": "DsMP",
        "../ops/transpose": "uQkx",
        "../util": "P6nv",
        "./min_max_grad_util": "h2YN"
    }],
    "QdS7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.greater = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util"),
            a = require("../tensor_util_env"),
            n = require("./broadcast_util"),
            o = require("./operation");

        function s(o, s) {
            let u = (0, a.convertToTensor)(o, "a", "greater"),
                i = (0, a.convertToTensor)(s, "b", "greater");
            [u, i] = (0, t.makeTypesMatch)(u, i), (0, n.assertAndGetBroadcastShape)(u.shape, i.shape);
            const c = {
                a: u,
                b: i
            };
            return e.ENGINE.runKernelFunc(e => e.greater(u, i), c, null, r.Greater)
        }
        const u = (0, o.op)({
            greater_: s
        });
        exports.greater = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "S1mw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.minimumGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/greater"),
            a = require("../ops/less_equal"),
            u = require("../ops/mul");
        const t = {
            kernelName: e.Minimum,
            inputsToSave: ["a", "b"],
            gradFunc: (e, t) => {
                const [i, o] = t;
                return {
                    a: () => (0, u.mul)(e, (0, r.cast)((0, a.lessEqual)(i, o), "float32")),
                    b: () => (0, u.mul)(e, (0, r.cast)((0, s.greater)(i, o), "float32"))
                }
            }
        };
        exports.minimumGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/greater": "QdS7",
        "../ops/less_equal": "FvS1",
        "../ops/mul": "k2PI"
    }],
    "XD37": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.floor = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function t(n) {
            const t = (0, o.convertToTensor)(n, "x", "floor"),
                l = {
                    x: t
                };
            return e.ENGINE.runKernelFunc(e => e.floor(t), l, null, r.Floor)
        }
        const l = (0, n.op)({
            floor_: t
        });
        exports.floor = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "jAgP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.modGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/broadcast_util"),
            s = require("../ops/div"),
            o = require("../ops/floor"),
            t = require("../ops/mul"),
            a = require("../ops/neg"),
            u = require("../ops/reshape"),
            n = require("../ops/sum");
        const p = {
            kernelName: e.Mod,
            inputsToSave: ["a", "b"],
            gradFunc: (e, p) => {
                const [i, d] = p, h = (0, r.assertAndGetBroadcastShape)(i.shape, d.shape);
                return {
                    a: () => {
                        const s = (0, r.getReductionAxes)(i.shape, h);
                        return s.length > 0 ? (0, u.reshape)((0, n.sum)(e, s), i.shape) : e
                    },
                    b: () => {
                        const p = (0, t.mul)(e, (0, a.neg)((0, o.floor)((0, s.div)(i, d)))),
                            c = (0, r.getReductionAxes)(d.shape, h);
                        return c.length > 0 ? (0, u.reshape)((0, n.sum)(p, c), d.shape) : p
                    }
                }
            }
        };
        exports.modGradConfig = p;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/div": "D8Fc",
        "../ops/floor": "XD37",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/reshape": "QI4k",
        "../ops/sum": "ITAy"
    }],
    "M1Jy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.multiplyGradConfig = void 0;
        var e = require("../kernel_names"),
            s = require("../ops/broadcast_util"),
            r = require("../ops/cast"),
            t = require("../ops/mul"),
            a = require("../ops/reshape"),
            u = require("../ops/sum");
        const o = {
            kernelName: e.Multiply,
            inputsToSave: ["a", "b"],
            gradFunc: (e, o) => {
                const [p, n] = o, i = (0, s.assertAndGetBroadcastShape)(p.shape, n.shape);
                return {
                    a: () => {
                        const o = (0, t.mul)(e, (0, r.cast)(n, "float32")),
                            l = (0, s.getReductionAxes)(p.shape, i);
                        return l.length > 0 ? (0, a.reshape)((0, u.sum)(o, l), p.shape) : o
                    },
                    b: () => {
                        const o = (0, t.mul)(e, (0, r.cast)(p, "float32")),
                            l = (0, s.getReductionAxes)(n.shape, i);
                        return l.length > 0 ? (0, a.reshape)((0, u.sum)(o, l), n.shape) : o
                    }
                }
            }
        };
        exports.multiplyGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/cast": "qqq3",
        "../ops/mul": "k2PI",
        "../ops/reshape": "QI4k",
        "../ops/sum": "ITAy"
    }],
    "WZur": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.negateGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/neg");
        const n = {
            kernelName: e.Negate,
            gradFunc: e => ({
                x: () => (0, r.neg)(e)
            })
        };
        exports.negateGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/neg": "iGYA"
    }],
    "Iowv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.complex = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = p(require("../util")),
            o = require("./operation");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var p = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    p && (p.get || p.set) ? Object.defineProperty(t, o, p) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(o, a) {
            const p = (0, t.convertToTensor)(o, "real", "complex"),
                u = (0, t.convertToTensor)(a, "imag", "complex");
            n.assertShapesMatch(p.shape, u.shape, `real and imag shapes, ${p.shape} and ${u.shape}, ` + "must match in call to tf.complex().");
            const c = {
                real: p,
                imag: u
            };
            return e.ENGINE.runKernelFunc(e => e.complex(p, u), c, null, r.Complex)
        }
        const c = (0, o.op)({
            complex_: u
        });
        exports.complex = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "R5fo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.zeros = t;
        var e = require("../engine"),
            r = require("../util"),
            o = require("./complex");

        function t(s, i = "float32") {
            if ("complex64" === i) {
                const e = t(s, "float32"),
                    r = t(s, "float32");
                return (0, o.complex)(e, r)
            }
            const n = (0, r.makeZerosTypedArray)((0, r.sizeFromShape)(s), i);
            return e.ENGINE.makeTensor(n, s, i)
        }
    }, {
        "../engine": "Nc3Y",
        "../util": "P6nv",
        "./complex": "Iowv"
    }],
    "dCXG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.oneHotGradConfig = void 0;
        var e = require("../kernel_names"),
            o = require("../ops/zeros");
        const r = {
            kernelName: e.OneHot,
            inputsToSave: ["indices"],
            gradFunc: (e, r) => {
                const n = r[0];
                return {
                    indices: () => (0, o.zeros)(n.shape, "float32")
                }
            }
        };
        exports.oneHotGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros": "R5fo"
    }],
    "hnES": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.onesLikeGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const o = {
            kernelName: e.OnesLike,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.onesLikeGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "lf1s": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.padV2GradConfig = void 0;
        var e = require("../kernel_names");
        const r = {
            kernelName: e.PadV2,
            inputsToSave: ["x"],
            gradFunc: (e, r, a) => {
                const s = r[0],
                    {
                        paddings: n
                    } = a,
                    d = n.map(e => e[0]);
                return {
                    x: () => e.slice(d, s.shape)
                }
            }
        };
        exports.padV2GradConfig = r;
    }, {
        "../kernel_names": "sdEe"
    }],
    "vwHA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.log = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function t(n) {
            const t = (0, o.convertToTensor)(n, "x", "log"),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.log(t);
                return r([t]), o
            }, u, null, r.Log)
        }
        const u = (0, n.op)({
            log_: t
        });
        exports.log = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "vt1B": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pow = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util"),
            n = require("../tensor_util_env"),
            t = require("./operation");

        function s(t, s) {
            let u = (0, n.convertToTensor)(t, "base", "pow"),
                p = (0, n.convertToTensor)(s, "exp", "pow");
            [u, p] = (0, o.makeTypesMatch)(u, p);
            const i = {
                a: u,
                b: p
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.pow(u, p);
                return r([u, p, o]), o
            }, i, null, r.Pow)
        }
        const u = (0, t.op)({
            pow_: s
        });
        exports.pow = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "v3FT": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.powGradConfig = void 0;
        var e = require("../kernel_names"),
            r = h(require("../ops/broadcast_util")),
            t = require("../ops/cast"),
            o = require("../ops/greater"),
            s = require("../ops/log"),
            u = require("../ops/mul"),
            a = require("../ops/pow"),
            n = require("../ops/reshape"),
            p = require("../ops/scalar"),
            i = require("../ops/sub"),
            c = require("../ops/sum"),
            l = require("../ops/where"),
            f = require("../ops/zeros_like");

        function d() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return d = function() {
                return e
            }, e
        }

        function h(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = d();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var u = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, s, u) : t[s] = e[s]
                } return t.default = e, r && r.set(e, t), t
        }
        const g = {
            kernelName: e.Pow,
            inputsToSave: ["a", "b"],
            outputsToSave: [!0],
            gradFunc: (e, d) => {
                const [h, g, q] = d, b = h, w = g, m = r.assertAndGetBroadcastShape(b.shape, w.shape);
                return {
                    a: () => {
                        const o = (0, t.cast)(w, "float32");
                        let s = (0, u.mul)(e, (0, u.mul)(o, (0, a.pow)(b, (0, i.sub)(o, (0, p.scalar)(1)))));
                        const l = r.getReductionAxes(b.shape, m);
                        return l.length > 0 && (s = (0, c.sum)(s, l)), (0, n.reshape)(s, b.shape)
                    },
                    b: () => {
                        const t = (0, o.greater)(b, 0),
                            a = (0, l.where)(t, (0, s.log)(b), (0, f.zerosLike)(b));
                        let p = (0, u.mul)(e, (0, u.mul)(q, a));
                        const i = r.getReductionAxes(w.shape, m);
                        return i.length > 0 && (p = (0, c.sum)(p, i)), (0, n.reshape)(p, w.shape)
                    }
                }
            }
        };
        exports.powGradConfig = g;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/cast": "qqq3",
        "../ops/greater": "QdS7",
        "../ops/log": "vwHA",
        "../ops/mul": "k2PI",
        "../ops/pow": "vt1B",
        "../ops/reshape": "QI4k",
        "../ops/scalar": "Ay42",
        "../ops/sub": "dGex",
        "../ops/sum": "ITAy",
        "../ops/where": "BsuI",
        "../ops/zeros_like": "PDcB"
    }],
    "Pbhi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.preluGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/broadcast_util"),
            s = require("../ops/greater"),
            u = require("../ops/mul"),
            o = require("../ops/reshape"),
            a = require("../ops/sum"),
            p = require("../ops/where"),
            t = require("../ops/zeros_like");
        const i = {
            kernelName: e.Prelu,
            inputsToSave: ["x", "alpha"],
            gradFunc: (e, i) => {
                const [l, n] = i, h = (0, s.greater)(l, 0);
                return {
                    x: () => (0, p.where)(h, e, (0, u.mul)(e, n)),
                    alpha: () => {
                        let s = (0, p.where)(h, (0, t.zerosLike)(e), (0, u.mul)(e, l));
                        const i = (0, r.getReductionAxes)(n.shape, e.shape);
                        return i.length > 0 && (s = (0, a.sum)(s, i)), (0, o.reshape)(s, n.shape)
                    }
                }
            }
        };
        exports.preluGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/greater": "QdS7",
        "../ops/mul": "k2PI",
        "../ops/reshape": "QI4k",
        "../ops/sum": "ITAy",
        "../ops/where": "BsuI",
        "../ops/zeros_like": "PDcB"
    }],
    "GoQG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reciprocalGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/div"),
            o = require("../ops/neg"),
            i = require("../ops/square");
        const s = {
            kernelName: e.Reciprocal,
            inputsToSave: ["x"],
            gradFunc: (e, s) => {
                const [a] = s;
                return {
                    x: () => (0, r.div)(e, (0, o.neg)((0, i.square)(a)))
                }
            }
        };
        exports.reciprocalGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/div": "D8Fc",
        "../ops/neg": "iGYA",
        "../ops/square": "mJRX"
    }],
    "QfHw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.relu6GradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/less_equal"),
            u = require("../ops/mul"),
            o = require("../ops/step");
        const t = {
            kernelName: e.Relu6,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [l] = t, a = (0, u.mul)((0, s.lessEqual)(l, 6), (0, o.step)(l));
                return {
                    x: () => (0, u.mul)(e, (0, r.cast)(a, "float32"))
                }
            }
        };
        exports.relu6GradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/less_equal": "FvS1",
        "../ops/mul": "k2PI",
        "../ops/step": "e2o4"
    }],
    "sCmN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reluGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/mul"),
            t = require("../ops/step");
        const o = {
            kernelName: e.Relu,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [u] = o;
                return {
                    x: () => (0, s.mul)(e, (0, r.cast)((0, t.step)(u), "float32"))
                }
            }
        };
        exports.reluGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/mul": "k2PI",
        "../ops/step": "e2o4"
    }],
    "LSQe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reshapeGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/reshape");
        const s = {
            kernelName: e.Reshape,
            inputsToSave: ["x"],
            gradFunc: (e, s) => {
                const [a] = s;
                return {
                    x: () => (0, r.reshape)(e, a.shape)
                }
            }
        };
        exports.reshapeGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/reshape": "QI4k"
    }],
    "nSk6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resizeBilinearGradConfig = void 0;
        var e = require("../engine"),
            r = require("../kernel_names");
        const i = {
            kernelName: r.ResizeBilinear,
            inputsToSave: ["images"],
            gradFunc: (i, n, s) => {
                const [a] = n, o = e => {
                    const {
                        alignCorners: r
                    } = s;
                    return e.resizeBilinearBackprop(i, a, r)
                }, l = {
                    images: a
                };
                return {
                    images: () => e.ENGINE.runKernelFunc(o, l, null, r.ResizeBilinearGrad, s)
                }
            }
        };
        exports.resizeBilinearGradConfig = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "ZiCH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resizeNearestNeighborGradConfig = void 0;
        var e = require("../engine"),
            r = require("../kernel_names");
        const s = {
            kernelName: r.ResizeNearestNeighbor,
            inputsToSave: ["images"],
            gradFunc: (s, i, n) => {
                const [a] = i, o = e => {
                    const {
                        alignCorners: r
                    } = n;
                    return e.resizeNearestNeighborBackprop(s, a, r)
                }, t = {
                    images: a
                };
                return {
                    images: () => e.ENGINE.runKernelFunc(o, t, null, r.ResizeNearestNeighborGrad, n)
                }
            }
        };
        exports.resizeNearestNeighborGradConfig = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "F06q": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.clone = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            o = require("./operation");

        function t(o) {
            const t = (0, r.convertToTensor)(o, "x", "clone", null),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc(() => e.ENGINE.makeTensorFromDataId(t.dataId, t.shape, t.dtype), u, null, n.Identity)
        }
        const u = (0, o.op)({
            clone_: t
        });
        exports.clone = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "SxGN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverse = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            s = require("../util"),
            o = require("./clone"),
            t = require("./operation"),
            u = require("./reshape");

        function i(t, i) {
            const a = (0, n.convertToTensor)(t, "x", "reverse"),
                c = {
                    x: a
                },
                p = {
                    dims: i
                };
            return e.ENGINE.runKernelFunc(e => {
                const r = (0, s.parseAxisParam)(i, a.shape);
                if (0 === a.rank) return (0, o.clone)(a);
                const n = e.reverse(a, r);
                return (0, u.reshape)(n, a.shape)
            }, c, null, r.Reverse, p)
        }
        const a = (0, t.op)({
            reverse_: i
        });
        exports.reverse = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./clone": "F06q",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "YSs8": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverseGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/reverse"),
            s = require("../util");
        const a = {
            kernelName: e.Reverse,
            gradFunc: (e, a, i) => {
                const {
                    dims: o
                } = i, t = (0, s.parseAxisParam)(o, e.shape);
                return {
                    x: () => (0, r.reverse)(e, t)
                }
            }
        };
        exports.reverseGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/reverse": "SxGN",
        "../util": "P6nv"
    }],
    "GJpt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.roundGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const o = {
            kernelName: e.Round,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.roundGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "agRd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rsqrtGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/div"),
            o = require("../ops/mul"),
            s = require("../ops/neg"),
            t = require("../ops/pow");
        const i = {
            kernelName: e.Rsqrt,
            inputsToSave: ["x"],
            gradFunc: (e, i) => {
                const [n] = i;
                return {
                    x: () => (0, s.neg)((0, r.div)(e, (0, o.mul)((0, t.pow)(n, 1.5), 2)))
                }
            }
        };
        exports.rsqrtGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/div": "D8Fc",
        "../ops/mul": "k2PI",
        "../ops/neg": "iGYA",
        "../ops/pow": "vt1B"
    }],
    "XZse": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logicalNot = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function l(t) {
            const l = (0, r.convertToTensor)(t, "x", "logicalNot", "bool"),
                n = {
                    x: l
                };
            return e.ENGINE.runKernelFunc(e => e.logicalNot(l), n, null, o.LogicalNot)
        }
        const n = (0, t.op)({
            logicalNot_: l
        });
        exports.logicalNot = n;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "q0Ys": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.selectV2PoolGradConfig = void 0;
        var e = require("../kernel_names"),
            o = require("../ops/cast"),
            r = require("../ops/logical_not"),
            t = require("../ops/mul"),
            s = require("../ops/zeros_like");
        const i = {
            kernelName: e.SelectV2,
            inputsToSave: ["condition"],
            gradFunc: (e, i) => {
                const [l] = i;
                return {
                    condition: () => (0, o.cast)((0, s.zerosLike)(l), "float32"),
                    t: () => (0, t.mul)(e, (0, o.cast)(l, e.dtype)),
                    e: () => (0, t.mul)(e, (0, o.cast)((0, r.logicalNot)(l), e.dtype))
                }
            }
        };
        exports.selectV2PoolGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/logical_not": "XZse",
        "../ops/mul": "k2PI",
        "../ops/zeros_like": "PDcB"
    }],
    "ssng": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SELU_SCALE = exports.SELU_SCALEALPHA = void 0;
        const e = 1.7580993408473768;
        exports.SELU_SCALEALPHA = e;
        const t = 1.0507009873554805;
        exports.SELU_SCALE = t;
    }, {}],
    "HeX4": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.seluGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/exp"),
            u = require("../ops/greater"),
            a = require("../ops/mul"),
            o = require("../ops/scalar"),
            t = require("../ops/selu_util"),
            l = require("../ops/where");
        const i = {
            kernelName: e.Selu,
            inputsToSave: ["x"],
            gradFunc: (e, i) => {
                const [p] = i;
                return {
                    x: () => {
                        const i = (0, u.greater)(p, (0, o.scalar)(0)),
                            n = (0, o.scalar)(t.SELU_SCALEALPHA),
                            c = (0, o.scalar)(t.SELU_SCALE),
                            q = (0, a.mul)(e, c),
                            x = (0, a.mul)((0, a.mul)(e, n), (0, s.exp)((0, r.cast)(p, "float32")));
                        return (0, l.where)(i, q, x)
                    }
                }
            }
        };
        exports.seluGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/exp": "zsk9",
        "../ops/greater": "QdS7",
        "../ops/mul": "k2PI",
        "../ops/scalar": "Ay42",
        "../ops/selu_util": "ssng",
        "../ops/where": "BsuI"
    }],
    "dkCO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sigmoidGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            s = require("../ops/scalar"),
            o = require("../ops/sub");
        const u = {
            kernelName: e.Sigmoid,
            outputsToSave: [!0],
            gradFunc: (e, u) => {
                const [i] = u;
                return {
                    x: () => (0, r.mul)(e, (0, r.mul)(i, (0, o.sub)((0, s.scalar)(1), i)))
                }
            }
        };
        exports.sigmoidGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/scalar": "Ay42",
        "../ops/sub": "dGex"
    }],
    "reLl": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.signGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const s = {
            kernelName: e.Sign,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.signGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "g9ZU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cos = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function s(n) {
            const s = (0, o.convertToTensor)(n, "x", "cos"),
                t = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.cos(s);
                return r([s]), o
            }, t, null, r.Cos)
        }
        const t = (0, n.op)({
            cos_: s
        });
        exports.cos = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "yO8n": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sinGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/cos"),
            o = require("../ops/mul");
        const n = {
            kernelName: e.Sin,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [t] = n;
                return {
                    x: () => (0, o.mul)((0, s.cos)((0, r.cast)(t, "float32")), e)
                }
            }
        };
        exports.sinGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/cos": "g9ZU",
        "../ops/mul": "k2PI"
    }],
    "GpTU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cosh = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function s(n) {
            const s = (0, o.convertToTensor)(n, "x", "cosh"),
                t = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.cosh(s);
                return r([s]), o
            }, t, null, r.Cosh)
        }
        const t = (0, n.op)({
            cosh_: s
        });
        exports.cosh = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "AfRo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sinhGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/cosh"),
            o = require("../ops/mul");
        const n = {
            kernelName: e.Sinh,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [t] = n;
                return {
                    x: () => (0, o.mul)((0, s.cosh)((0, r.cast)(t, "float32")), e)
                }
            }
        };
        exports.sinhGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/cosh": "GpTU",
        "../ops/mul": "k2PI"
    }],
    "hajs": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pad = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function a(o, a, t = 0) {
            const s = (0, n.convertToTensor)(o, "x", "pad");
            if (0 === s.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
            const d = {
                    paddings: a,
                    constantValue: t
                },
                i = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([s]), e.pad(s, a, t)), i, null, r.PadV2, d)
        }
        const t = (0, o.op)({
            pad_: a
        });
        exports.pad = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "Quoj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.assertParamsValid = n, exports.maskToAxes = o, exports.computeOutShape = s, exports.stridesWithElidedDims = l, exports.startIndicesWithElidedDims = u, exports.stopIndicesWithElidedDims = c, exports.stridesForAxis = f, exports.startForAxis = p, exports.stopForAxis = h, exports.isSliceContinous = g, exports.computeFlatOffset = d, exports.parseSliceParams = m;
        var e = r(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var l = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    l && (l.get || l.set) ? Object.defineProperty(n, s, l) : n[s] = e[s]
                } return n.default = e, r && r.set(e, n), n
        }

        function n(t, r, n) {
            e.assert(t.rank === r.length, () => `Error in slice${t.rank}D: Length of begin ${r} must ` + `match the rank of the array (${t.rank}).`), e.assert(t.rank === n.length, () => `Error in slice${t.rank}D: Length of size ${n} must ` + `match the rank of the array (${t.rank}).`);
            for (let o = 0; o < t.rank; ++o) e.assert(r[o] + n[o] <= t.shape[o], () => `Error in slice${t.rank}D: begin[${o}] + size[${o}] ` + `(${r[o]+n[o]}) would overflow input.shape[${o}] (${t.shape[o]})`)
        }

        function o(e) {
            const t = [];
            let r = 0;
            for (; e > 0;) 1 & e && t.push(r), e /= 2, r++;
            return t
        }

        function s(e, t, r) {
            const n = [];
            for (let o = 0; o < e.length; o++) n[o] = Math.ceil((t[o] - e[o]) / r[o]);
            return n
        }

        function l(e, t, r, n) {
            const o = [...e];
            for (let s = o.length; s < n.length; s++) o.push(1);
            for (let s = 0; s < r; s++) 0 === s ? o[t] = 1 : (o.splice(t, 0, 1), o.pop());
            return o
        }

        function i(e, t, r) {
            return r <= e ? r : r - (t - 1)
        }

        function a(e, t) {
            const r = [];
            for (let n = 0; n < e; n++) r.push(t + n);
            return r
        }

        function u(e, t, r, n, o) {
            const s = [...o],
                l = a(r, t);
            for (let a = 0; a < s.length; a++)
                if (l.indexOf(a) > -1) s[a] = 0;
                else {
                    const o = i(t, r, a);
                    let l = n[o];
                    e & 1 << o && (l = 0), s[a] = l
                } return s
        }

        function c(t, r, n, o, s) {
            const l = [...s],
                u = a(n, r);
            for (let e = 0; e < l.length; e++)
                if (u.indexOf(e) > -1) l[e] = Number.MAX_SAFE_INTEGER;
                else {
                    const s = i(r, n, e);
                    let a = o[s];
                    t & 1 << s && (a = Number.MAX_SAFE_INTEGER), l[e] = a
                } for (let i = 0; i < l.length; i++) {
                const t = s[i];
                l[i] < 0 && (l[i] += t), l[i] = e.clamp(0, l[i], s[i])
            }
            return l
        }

        function f(e, t, r) {
            let n = e[t];
            return (r & 1 << t || null == n) && (n = 1), n
        }

        function p(t, r, n, o, s, l) {
            let i = r[s];
            const a = n[s] || 1;
            (t & 1 << s || l & 1 << s || null == i) && (i = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
            const u = o[s];
            return i < 0 && (i += u), i = e.clamp(0, i, u - 1)
        }

        function h(t, r, n, o, s, l) {
            let i = r[s];
            const a = n[s] || 1;
            (t & 1 << s || l & 1 << s || null == i) && (i = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
            const u = o[s];
            return i < 0 && (i += u), i = a > 0 ? e.clamp(0, i, u) : e.clamp(-1, i, u - 1)
        }

        function g(e, t, r) {
            let n = r.length;
            for (let o = 0; o < r.length; o++)
                if (r[o] > 1) {
                    n = o;
                    break
                } for (let o = n + 1; o < r.length; o++)
                if (t[o] > 0 || r[o] !== e[o]) return !1;
            return !0
        }

        function d(e, t) {
            let r = e.length > 0 ? e[e.length - 1] : 1;
            for (let n = 0; n < e.length - 1; n++) r += e[n] * t[n];
            return r
        }

        function m(t, r, n) {
            let o, s;
            return (o = "number" == typeof r ? [r, ...new Array(t.rank - 1).fill(0)] : r.length < t.rank ? r.concat(new Array(t.rank - r.length).fill(0)) : r.slice()).forEach(t => {
                e.assert(-1 !== t, () => "slice() does not support negative begin indexing.")
            }), s = (s = null == n ? new Array(t.rank).fill(-1) : "number" == typeof n ? [n, ...new Array(t.rank - 1).fill(-1)] : n.length < t.rank ? n.concat(new Array(t.rank - n.length).fill(-1)) : n).map((r, n) => r >= 0 ? r : (e.assert(-1 === r, () => "Negative size values should be exactly -1 but got " + `${r} for the slice() size at index ${n}.`), t.shape[n] - o[n])), [o, s]
        }
    }, {
        "../util": "P6nv"
    }],
    "h1Er": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sliceGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/pad"),
            s = require("../ops/slice_util");
        const i = {
            kernelName: e.Slice,
            inputsToSave: ["x"],
            gradFunc: (e, i, a) => {
                const [o] = i, {
                    begin: n,
                    size: t
                } = a, p = o.shape, [l, u] = (0, s.parseSliceParams)(o, n, t), c = [];
                for (let r = 0; r < e.rank; r++) c.push([l[r], p[r] - l[r] - u[r]]);
                return {
                    x: () => (0, r.pad)(e, c)
                }
            }
        };
        exports.sliceGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/pad": "hajs",
        "../ops/slice_util": "Quoj"
    }],
    "fO38": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.softmaxGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            s = require("../ops/sub"),
            o = require("../ops/sum");
        const u = {
            kernelName: e.Softmax,
            outputsToSave: [!0],
            gradFunc: (e, u, t) => {
                const [a] = u, {
                    dim: i
                } = t, m = (0, r.mul)(e, a);
                return {
                    logits: () => (0, s.sub)(m, (0, r.mul)((0, o.sum)(m, [i], !0), a))
                }
            }
        };
        exports.softmaxGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/sub": "dGex",
        "../ops/sum": "ITAy"
    }],
    "yARQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sigmoid = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            i = require("../tensor_util_env"),
            o = require("./operation");

        function n(o) {
            const n = (0, i.convertToTensor)(o, "x", "sigmoid"),
                s = {
                    x: n
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const i = e.sigmoid(n);
                return r([i]), i
            }, s, null, r.Sigmoid)
        }
        const s = (0, o.op)({
            sigmoid_: n
        });
        exports.sigmoid = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "hrsO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.softplusGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            s = require("../ops/sigmoid");
        const o = {
            kernelName: e.Softplus,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [t] = o;
                return {
                    x: () => (0, r.mul)(e, (0, s.sigmoid)(t))
                }
            }
        };
        exports.softplusGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/sigmoid": "yARQ"
    }],
    "Q9gF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchToSpaceND = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = c(require("../util")),
            o = require("./operation");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function c(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var c = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    c && (c.get || c.set) ? Object.defineProperty(r, o, c) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function u(o, a, c) {
            const u = (0, r.convertToTensor)(o, "x", "batchToSpaceND"),
                i = a.reduce((e, t) => e * t);
            n.assert(u.rank >= 1 + a.length, () => `input rank is ${u.rank} but should be > than blockShape.length ${a.length}`), n.assert(c.length === a.length, () => `crops.length is ${c.length} but should be equal to blockShape.length  ${a.length}`), n.assert(u.shape[0] % i == 0, () => `input tensor batch is ${u.shape[0]} but is not divisible by the product of ` + `the elements of blockShape ${a.join(" * ")} === ${i}`);
            const s = {
                    x: u
                },
                l = {
                    blockShape: a,
                    crops: c
                };
            return e.ENGINE.runKernelFunc(e => e.batchToSpaceND(u, a, c), s, null, t.BatchToSpaceND, l)
        }
        const i = (0, o.op)({
            batchToSpaceND_: u
        });
        exports.batchToSpaceND = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "T91W": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.spaceToBatchNDGradConfig = void 0;
        var e = require("../kernel_names"),
            a = require("../ops/batch_to_space_nd");
        const r = {
            kernelName: e.SpaceToBatchND,
            gradFunc: (e, r, o) => {
                const {
                    blockShape: c,
                    paddings: t
                } = o;
                return {
                    x: () => (0, a.batchToSpaceND)(e, c, t)
                }
            }
        };
        exports.spaceToBatchNDGradConfig = r;
    }, {
        "../kernel_names": "sdEe",
        "../ops/batch_to_space_nd": "Q9gF"
    }],
    "Toan": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.assertParamsConsistent = n, exports.computeOutShape = o;
        var e = r(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = e[s]
                } return n.default = e, r && r.set(e, n), n
        }

        function n(t, r) {
            const n = t[0].length;
            t.forEach((t, r) => {
                e.assert(t.length === n, () => `Error in concat${n}D: rank of tensors[${r}] must be the same ` + `as the rank of the rest (${n})`)
            }), e.assert(r >= 0 && r < n, () => `Error in concat${n}D: axis must be between 0 and ${n-1}.`);
            const o = t[0];
            t.forEach((t, s) => {
                for (let a = 0; a < n; a++) e.assert(a === r || t[a] === o[a], () => `Error in concat${n}D: Shape of tensors[${s}] (${t}) ` + `does not match the shape of the rest (${o}) ` + `along the non-concatenated axis ${s}.`)
            })
        }

        function o(e, t) {
            const r = e[0].slice();
            for (let n = 1; n < e.length; n++) r[t] += e[n][t];
            return r
        }
    }, {
        "../util": "P6nv"
    }],
    "P2QC": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor = t;
        var e = require("../tensor_util_env"),
            r = require("./tensor_ops_util");

        function t(t, n, o) {
            const s = (0, e.inferShape)(t, o);
            return (0, r.makeTensor)(t, n, s, o)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "./tensor_ops_util": "m0jF"
    }],
    "dDdq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concat = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = require("../util"),
            o = require("./concat_util"),
            s = require("./operation"),
            a = require("./tensor");

        function c(s, c = 0) {
            (0, n.assert)(s.length >= 1, () => "Pass at least one tensor to concat");
            let i = (0, r.convertToTensorArray)(s, "tensors", "concat");
            "complex64" === i[0].dtype && i.forEach(e => {
                if ("complex64" !== e.dtype) throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)
            });
            const u = (0, n.parseAxisParam)(c, i[0].shape)[0],
                p = (0, o.computeOutShape)(i.map(e => e.shape), u);
            if (0 === (0, n.sizeFromShape)(p)) return (0, a.tensor)([], p);
            if (1 === (i = i.filter(e => e.size > 0)).length) return i[0];
            const l = i.map(e => e.shape);
            (0, o.assertParamsConsistent)(l, u);
            const h = i,
                m = {
                    axis: c
                };
            return e.ENGINE.runKernelFunc((e, t) => {
                const r = e.concat(i, u);
                return t(i), r
            }, h, null, t.Concat, m)
        }
        const i = (0, s.op)({
            concat_: c
        });
        exports.concat = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./concat_util": "Toan",
        "./operation": "JtaO",
        "./tensor": "P2QC"
    }],
    "bAb4": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.splitVGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/concat");
        const t = {
            kernelName: e.SplitV,
            gradFunc: (e, t, o) => {
                const {
                    axis: s
                } = o;
                return {
                    x: () => (0, r.concat)(e, s)
                }
            }
        };
        exports.splitVGradConfig = t;
    }, {
        "../kernel_names": "sdEe",
        "../ops/concat": "dDdq"
    }],
    "iClX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sqrtGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cast"),
            s = require("../ops/div"),
            t = require("../ops/mul"),
            o = require("../ops/sqrt");
        const i = {
            kernelName: e.Sqrt,
            inputsToSave: ["x"],
            gradFunc: (e, i) => {
                const [u] = i;
                return {
                    x: () => (0, s.div)(e, (0, t.mul)((0, o.sqrt)((0, r.cast)(u, "float32")), 2))
                }
            }
        };
        exports.sqrtGradConfig = i;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cast": "qqq3",
        "../ops/div": "D8Fc",
        "../ops/mul": "k2PI",
        "../ops/sqrt": "iJpu"
    }],
    "mVS9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squareGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul");
        const o = {
            kernelName: e.Square,
            inputsToSave: ["x"],
            gradFunc: (e, o) => {
                const [u] = o;
                return {
                    x: () => (0, r.mul)(e, (0, r.mul)(u.toFloat(), 2))
                }
            }
        };
        exports.squareGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI"
    }],
    "TPwK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squaredDifferenceGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            u = require("../ops/scalar"),
            s = require("../ops/sub");
        const a = {
            kernelName: e.SquaredDifference,
            inputsToSave: ["a", "b"],
            gradFunc: (e, a) => {
                const [n, o] = a, i = (0, u.scalar)(2);
                return {
                    a: () => (0, r.mul)(e, (0, r.mul)(i, (0, s.sub)(n, o))),
                    b: () => (0, r.mul)(e, (0, r.mul)(i, (0, s.sub)(o, n)))
                }
            }
        };
        exports.squaredDifferenceGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/scalar": "Ay42",
        "../ops/sub": "dGex"
    }],
    "wx7z": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.stepGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const s = {
            kernelName: e.Step,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.stepGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "JOrk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.subGradConfig = void 0;
        var e = require("../kernel_names"),
            r = u(require("../ops/broadcast_util")),
            t = require("../ops/neg"),
            n = require("../ops/reshape"),
            s = require("../ops/sum");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, s) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, s, u) : t[s] = e[s]
                } return t.default = e, r && r.set(e, t), t
        }
        const a = {
            kernelName: e.Sub,
            inputsToSave: ["a", "b"],
            gradFunc: (e, o) => {
                const [u, a] = o, p = r.assertAndGetBroadcastShape(u.shape, a.shape);
                return {
                    a: () => {
                        let t = e;
                        const o = r.getReductionAxes(u.shape, p);
                        return o.length > 0 && (t = (0, s.sum)(t, o)), (0, n.reshape)(t, u.shape)
                    },
                    b: () => {
                        let o = e;
                        const u = r.getReductionAxes(a.shape, p);
                        return u.length > 0 && (o = (0, s.sum)(o, u)), (0, n.reshape)((0, t.neg)(o), a.shape)
                    }
                }
            }
        };
        exports.subGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/broadcast_util": "Xh9J",
        "../ops/neg": "iGYA",
        "../ops/reshape": "QI4k",
        "../ops/sum": "ITAy"
    }],
    "POxQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ones = s;
        var e = require("../engine"),
            r = require("../util"),
            o = require("./complex"),
            t = require("./zeros");

        function s(n, i = "float32") {
            if ("complex64" === i) {
                const e = s(n, "float32"),
                    r = (0, t.zeros)(n, "float32");
                return (0, o.complex)(e, r)
            }
            const u = (0, r.makeOnesTypedArray)((0, r.sizeFromShape)(n), i);
            return e.ENGINE.makeTensor(u, n, i)
        }
    }, {
        "../engine": "Nc3Y",
        "../util": "P6nv",
        "./complex": "Iowv",
        "./zeros": "R5fo"
    }],
    "isro": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sumGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            s = require("../ops/ones"),
            a = require("../ops/reshape"),
            o = require("../util");
        const u = {
            kernelName: e.Sum,
            inputsToSave: ["x"],
            gradFunc: (e, u, i) => {
                const [n] = u, p = n.shape.slice(), {
                    axis: t
                } = i;
                (0, o.parseAxisParam)(t, n.shape).forEach(e => {
                    p[e] = 1
                });
                const l = (0, a.reshape)(e, p),
                    c = (0, r.mul)(l, (0, s.ones)(n.shape, "float32"));
                return {
                    x: () => c
                }
            }
        };
        exports.sumGradConfig = u;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/ones": "POxQ",
        "../ops/reshape": "QI4k",
        "../util": "P6nv"
    }],
    "se8T": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tanGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/cos"),
            s = require("../ops/div"),
            o = require("../ops/square");
        const n = {
            kernelName: e.Tan,
            inputsToSave: ["x"],
            gradFunc: (e, n) => {
                const [a] = n;
                return {
                    x: () => (0, s.div)(e, (0, o.square)((0, r.cos)(a)))
                }
            }
        };
        exports.tanGradConfig = n;
    }, {
        "../kernel_names": "sdEe",
        "../ops/cos": "g9ZU",
        "../ops/div": "D8Fc",
        "../ops/square": "mJRX"
    }],
    "xokp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tanhGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/mul"),
            s = require("../ops/scalar"),
            u = require("../ops/square"),
            a = require("../ops/sub");
        const o = {
            kernelName: e.Tanh,
            outputsToSave: [!0],
            gradFunc: (e, o) => {
                const [t] = o;
                return {
                    x: () => (0, r.mul)((0, a.sub)((0, s.scalar)(1), (0, u.square)(t)), e)
                }
            }
        };
        exports.tanhGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/mul": "k2PI",
        "../ops/scalar": "Ay42",
        "../ops/square": "mJRX",
        "../ops/sub": "dGex"
    }],
    "zP07": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slice = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("./operation"),
            i = s(require("./slice_util"));

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, i, s) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function c(n, o, s) {
            const c = (0, t.convertToTensor)(n, "x", "slice");
            if (0 === c.rank) throw new Error("Slicing scalar is not possible");
            const [u, l] = i.parseSliceParams(c, o, s);
            i.assertParamsValid(c, u, l);
            const a = {
                    x: c
                },
                p = {
                    begin: o,
                    size: s
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([c]), e.slice(c, u, l)), a, null, r.Slice, p)
        }
        const u = (0, n.op)({
            slice_: c
        });
        exports.slice = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./slice_util": "Quoj"
    }],
    "v6Hb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tileGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/add"),
            s = require("../ops/slice"),
            a = require("../ops/zeros_like");
        const o = {
            kernelName: e.Tile,
            inputsToSave: ["x"],
            gradFunc: (e, o, t) => {
                const [p] = o, {
                    reps: i
                } = t;
                return {
                    x: () => {
                        let o = (0, a.zerosLike)(p);
                        if (1 === p.rank)
                            for (let a = 0; a < i[0]; ++a) o = (0, r.add)(o, (0, s.slice)(e, [a * p.shape[0]], [p.shape[0]]));
                        else if (2 === p.rank)
                            for (let a = 0; a < i[0]; ++a)
                                for (let t = 0; t < i[1]; ++t) o = (0, r.add)(o, (0, s.slice)(e, [a * p.shape[0], t * p.shape[1]], [p.shape[0], p.shape[1]]));
                        else if (3 === p.rank)
                            for (let a = 0; a < i[0]; ++a)
                                for (let t = 0; t < i[1]; ++t)
                                    for (let l = 0; l < i[2]; ++l) o = (0, r.add)(o, (0, s.slice)(e, [a * p.shape[0], t * p.shape[1], l * p.shape[2]], [p.shape[0], p.shape[1], p.shape[2]]));
                        else {
                            if (4 !== p.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + `${p.rank} tensors yet.`);
                            for (let a = 0; a < i[0]; ++a)
                                for (let t = 0; t < i[1]; ++t)
                                    for (let l = 0; l < i[2]; ++l)
                                        for (let n = 0; n < i[3]; ++n) o = (0, r.add)(o, (0, s.slice)(e, [a * p.shape[0], t * p.shape[1], l * p.shape[2], n * p.shape[3]], [p.shape[0], p.shape[1], p.shape[2], p.shape[3]]))
                        }
                        return o
                    }
                }
            }
        };
        exports.tileGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/add": "ZDFV",
        "../ops/slice": "zP07",
        "../ops/zeros_like": "PDcB"
    }],
    "tjBW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transposeGradConfig = void 0;
        var e = require("../kernel_names"),
            r = o(require("../ops/axis_util")),
            t = require("../ops/transpose");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = n();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, s, a) : t[s] = e[s]
                } return t.default = e, r && r.set(e, t), t
        }
        const s = {
            kernelName: e.Transpose,
            gradFunc: (e, n, o) => {
                const s = o,
                    {
                        perm: a
                    } = s,
                    u = r.getUndoAxesPermutation(a);
                return {
                    x: () => (0, t.transpose)(e, u)
                }
            }
        };
        exports.transposeGradConfig = s;
    }, {
        "../kernel_names": "sdEe",
        "../ops/axis_util": "DsMP",
        "../ops/transpose": "uQkx"
    }],
    "XF6l": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.expandDims = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./operation"),
            n = require("./reshape");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, i, s) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(t, o = 0) {
            const i = (0, e.convertToTensor)(t, "x", "expandDims", null);
            r.assert(o <= i.rank, () => "Axis must be <= rank of the tensor");
            const s = i.shape.slice();
            return o < 0 && (r.assert(-(i.rank + 1) <= o, () => `Axis must be in the interval [${-(i.rank+1)}, ${i.rank}]`), o = i.rank + o + 1), s.splice(o, 0, 1), (0, n.reshape)(i, s)
        }
        const a = (0, t.op)({
            expandDims_: s
        });
        exports.expandDims = a;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "TWBn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.stack = void 0;
        var e = require("../tensor_util_env"),
            t = o(require("../util")),
            r = require("./concat"),
            s = require("./expand_dims"),
            n = require("./operation");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var o = s ? Object.getOwnPropertyDescriptor(e, n) : null;
                    o && (o.get || o.set) ? Object.defineProperty(r, n, o) : r[n] = e[n]
                } return r.default = e, t && t.set(e, r), r
        }

        function c(n, a = 0) {
            const o = (0, e.convertToTensorArray)(n, "tensors", "stack");
            if (t.assert(o.length >= 1, () => "Pass at least one tensor to tf.stack"), 1 === o.length) return (0, s.expandDims)(o[0], a);
            const c = o[0].rank,
                i = o[0].shape,
                u = o[0].dtype;
            t.assert(a <= c, () => "Axis must be <= rank of the tensor"), o.forEach(e => {
                t.assertShapesMatch(i, e.shape, "All tensors passed to stack must have matching shapes"), t.assert(u === e.dtype, () => "All tensors passed to stack must have matching dtypes")
            });
            const p = o.map(e => (0, s.expandDims)(e, a));
            return (0, r.concat)(p, a)
        }
        const i = (0, n.op)({
            stack_: c
        });
        exports.stack = i;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./concat": "dDdq",
        "./expand_dims": "XF6l",
        "./operation": "JtaO"
    }],
    "uMFh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.unpackGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/stack");
        const a = {
            kernelName: e.Unpack,
            gradFunc: (e, a, n) => {
                const s = n,
                    {
                        axis: t
                    } = s;
                return {
                    value: () => (0, r.stack)(e, t)
                }
            }
        };
        exports.unpackGradConfig = a;
    }, {
        "../kernel_names": "sdEe",
        "../ops/stack": "TWBn"
    }],
    "iHyk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.computeOptimalWindowSize = r, exports.PARALLELIZE_THRESHOLD = void 0;
        var e = require("../util");
        const t = 30;

        function r(r) {
            return r <= t ? r : (0, e.nearestDivisor)(r, Math.floor(Math.sqrt(r)))
        }
        exports.PARALLELIZE_THRESHOLD = t;
    }, {
        "../util": "P6nv"
    }],
    "U497": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.segOpComputeOptimalWindowSize = r, exports.computeOutShape = s, exports.collectGatherOpShapeInfo = o;
        var e = require("../util"),
            t = require("./reduce_util");

        function r(r, s) {
            let o, p = !1;
            for (r <= t.PARALLELIZE_THRESHOLD ? (o = r, p = !0) : o = (0, e.nearestDivisor)(r, Math.floor(Math.sqrt(r))); !p;) o > s || o === r ? p = !0 : o = (0, e.nearestDivisor)(r, o + 1);
            return o
        }

        function s(e, t, r) {
            const s = [],
                o = e.length;
            for (let p = 0; p < o; p++) p !== t ? s.push(e[p]) : s.push(r);
            return s
        }

        function o(e, t, r) {
            const s = e.shape[r],
                o = [];
            let p = 1,
                u = 1;
            for (let i = 0; i < r; i++) o.push(e.shape[i]), p *= e.shape[i];
            for (let i = 0; i < t.rank; i++) o.push(t.shape[i]);
            for (let i = r + 1; i < e.rank; i++) o.push(e.shape[i]), u *= e.shape[i];
            return {
                batchSize: p,
                sliceSize: u,
                dimSize: s,
                outputShape: o
            }
        }
    }, {
        "../util": "P6nv",
        "./reduce_util": "iHyk"
    }],
    "ESvM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.gather = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("../util"),
            o = require("./operation"),
            i = require("./segment_util");

        function a(o, a, s = 0) {
            const u = (0, t.convertToTensor)(o, "x", "gather"),
                c = (0, t.convertToTensor)(a, "indices", "gather", "int32"),
                p = {
                    x: u,
                    indices: c
                },
                h = {
                    axis: s
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = (0, n.parseAxisParam)(s, u.shape)[0],
                    o = (0, i.collectGatherOpShapeInfo)(u, c, t),
                    a = e.gather(u, c.flatten(), t);
                return r([u, c]), a.reshape(o.outputShape)
            }, p, null, r.GatherV2, h)
        }
        const s = (0, o.op)({
            gather_: a
        });
        exports.gather = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./segment_util": "U497"
    }],
    "X5MV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maximum = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util"),
            n = require("../tensor_util_env"),
            a = require("./broadcast_util"),
            u = require("./cast"),
            i = require("./operation");

        function o(i, o) {
            let s = (0, n.convertToTensor)(i, "a", "maximum"),
                m = (0, n.convertToTensor)(o, "b", "maximum");
            [s, m] = (0, t.makeTypesMatch)(s, m), "bool" === s.dtype && (s = (0, u.cast)(s, "int32"), m = (0, u.cast)(m, "int32")), (0, a.assertAndGetBroadcastShape)(s.shape, m.shape);
            const c = {
                a: s,
                b: m
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.maximum(s, m);
                return r([s, m]), t
            }, c, null, r.Maximum)
        }
        const s = (0, i.op)({
            maximum_: o
        });
        exports.maximum = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./cast": "qqq3",
        "./operation": "JtaO"
    }],
    "hjTI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.unsortedSegmentSumGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/expand_dims"),
            o = require("../ops/gather"),
            s = require("../ops/greater_equal"),
            n = require("../ops/logical_and"),
            t = require("../ops/maximum"),
            a = require("../ops/ones"),
            i = require("../ops/scalar"),
            u = require("../ops/where"),
            m = require("../ops/zeros_like");
        const p = {
            kernelName: e.UnsortedSegmentSum,
            inputsToSave: ["segmentIds"],
            gradFunc: (e, r) => {
                const [o] = r;
                return {
                    x: () => l(e, o)
                }
            }
        };

        function l(e, p) {
            const l = (0, t.maximum)(p, (0, m.zerosLike)(p)),
                d = (0, o.gather)(e, l);
            let c = (0, s.greaterEqual)(p, (0, i.scalar)(0, "int32"));
            const g = d.rank - c.rank;
            for (let o = 0; o < g; ++o) c = (0, r.expandDims)(c, o + 1);
            c = (0, n.logicalAnd)(c, (0, a.ones)(d.shape, "bool"));
            const q = (0, m.zerosLike)(d);
            return (0, u.where)(c, d, q)
        }
        exports.unsortedSegmentSumGradConfig = p;
    }, {
        "../kernel_names": "sdEe",
        "../ops/expand_dims": "XF6l",
        "../ops/gather": "ESvM",
        "../ops/greater_equal": "Dbo2",
        "../ops/logical_and": "lYzt",
        "../ops/maximum": "X5MV",
        "../ops/ones": "POxQ",
        "../ops/scalar": "Ay42",
        "../ops/where": "BsuI",
        "../ops/zeros_like": "PDcB"
    }],
    "qCQu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.zerosLikeGradConfig = void 0;
        var e = require("../kernel_names"),
            r = require("../ops/zeros_like");
        const o = {
            kernelName: e.ZerosLike,
            gradFunc: e => ({
                x: () => (0, r.zerosLike)(e)
            })
        };
        exports.zerosLikeGradConfig = o;
    }, {
        "../kernel_names": "sdEe",
        "../ops/zeros_like": "PDcB"
    }],
    "pbwh": [function(require, module, exports) {
        "use strict";
        var r = require("./gradients/Abs_grad"),
            e = require("./gradients/Acos_grad"),
            a = require("./gradients/Acosh_grad"),
            i = require("./gradients/Add_grad"),
            d = require("./gradients/AddN_grad"),
            g = require("./gradients/ArgMax_grad"),
            n = require("./gradients/ArgMin_grad"),
            o = require("./gradients/Asin_grad"),
            t = require("./gradients/Asinh_grad"),
            s = require("./gradients/Atan2_grad"),
            u = require("./gradients/Atan_grad"),
            f = require("./gradients/Atanh_grad"),
            C = require("./gradients/AvgPool3D_grad"),
            q = require("./gradients/AvgPool_grad"),
            G = require("./gradients/BatchMatMul_grad"),
            _ = require("./gradients/BatchToSpaceND_grad"),
            l = require("./gradients/BroadcastTo_grad"),
            c = require("./gradients/Cast_grad"),
            p = require("./gradients/Ceil_grad"),
            m = require("./gradients/ClipByValue_grad"),
            h = require("./gradients/Concat_grad"),
            S = require("./gradients/Conv2D_grad"),
            D = require("./gradients/Conv2DBackpropInput_grad"),
            v = require("./gradients/Conv3D_grad"),
            x = require("./gradients/Cos_grad"),
            N = require("./gradients/Cosh_grad"),
            M = require("./gradients/Cumsum_grad"),
            A = require("./gradients/DepthwiseConv2dNative_grad"),
            B = require("./gradients/Dilation2D_grad"),
            P = require("./gradients/Div_grad"),
            T = require("./gradients/Elu_grad"),
            V = require("./gradients/Erf_grad"),
            R = require("./gradients/Exp_grad"),
            b = require("./gradients/Expm1_grad"),
            k = require("./gradients/Floor_grad"),
            I = require("./gradients/FloorDiv_grad"),
            L = require("./gradients/FusedBatchNorm_grad"),
            y = require("./gradients/GatherV2_grad"),
            E = require("./gradients/GreaterEqual_grad"),
            z = require("./gradients/Identity_grad"),
            F = require("./gradients/IsFinite_grad"),
            w = require("./gradients/IsInf_grad"),
            H = require("./gradients/IsNan_grad"),
            O = require("./gradients/Log1p_grad"),
            U = require("./gradients/Log_grad"),
            Z = require("./gradients/LogSoftmax_grad"),
            j = require("./gradients/LRN_grad"),
            J = require("./gradients/Max_grad"),
            K = require("./gradients/Maximum_grad"),
            Q = require("./gradients/MaxPool3D_grad"),
            W = require("./gradients/MaxPool_grad"),
            X = require("./gradients/Min_grad"),
            Y = require("./gradients/Minimum_grad"),
            $ = require("./gradients/Mod_grad"),
            rr = require("./gradients/Multiply_grad"),
            er = require("./gradients/Negate_grad"),
            ar = require("./gradients/OneHot_grad"),
            ir = require("./gradients/OnesLike_grad"),
            dr = require("./gradients/PadV2_grad"),
            gr = require("./gradients/Pow_grad"),
            nr = require("./gradients/Prelu_grad"),
            or = require("./gradients/Reciprocal_grad"),
            tr = require("./gradients/Relu6_grad"),
            sr = require("./gradients/Relu_grad"),
            ur = require("./gradients/Reshape_grad"),
            fr = require("./gradients/ResizeBilinear_grad"),
            Cr = require("./gradients/ResizeNearestNeighbor_grad"),
            qr = require("./gradients/Reverse_grad"),
            Gr = require("./gradients/Round_grad"),
            _r = require("./gradients/Rsqrt_grad"),
            lr = require("./gradients/SelectV2_grad"),
            cr = require("./gradients/Selu_grad"),
            pr = require("./gradients/Sigmoid_grad"),
            mr = require("./gradients/Sign_grad"),
            hr = require("./gradients/Sin_grad"),
            Sr = require("./gradients/Sinh_grad"),
            Dr = require("./gradients/Slice_grad"),
            vr = require("./gradients/Softmax_grad"),
            xr = require("./gradients/Softplus_grad"),
            Nr = require("./gradients/SpaceToBatchND_grad"),
            Mr = require("./gradients/SplitV_grad"),
            Ar = require("./gradients/Sqrt_grad"),
            Br = require("./gradients/Square_grad"),
            Pr = require("./gradients/SquaredDifference_grad"),
            Tr = require("./gradients/Step_grad"),
            Vr = require("./gradients/Sub_grad"),
            Rr = require("./gradients/Sum_grad"),
            br = require("./gradients/Tan_grad"),
            kr = require("./gradients/Tanh_grad"),
            Ir = require("./gradients/Tile_grad"),
            Lr = require("./gradients/Transpose_grad"),
            yr = require("./gradients/Unpack_grad"),
            Er = require("./gradients/UnsortedSegmentSum_grad"),
            zr = require("./gradients/ZerosLike_grad"),
            Fr = require("./kernel_registry");
        const wr = [r.absGradConfig, e.acosGradConfig, a.acoshGradConfig, i.addGradConfig, d.addNGradConfig, g.argMaxGradConfig, n.argMinGradConfig, o.asinGradConfig, t.asinhGradConfig, s.atan2GradConfig, u.atanGradConfig, f.atanhGradConfig, C.avgPool3DGradConfig, q.avgPoolGradConfig, G.batchMatMulGradConfig, _.batchToSpaceNDGradConfig, l.broadcastToGradConfig, c.castGradConfig, p.ceilGradConfig, m.clipByValueGradConfig, h.concatGradConfig, D.conv2DBackpropInputGradConfig, S.conv2DGradConfig, v.conv3DGradConfig, x.cosGradConfig, N.coshGradConfig, M.cumsumGradConfig, A.depthwiseConv2dNativeGradConfig, B.dilation2dGradConfig, P.divGradConfig, T.eluGradConfig, V.erfGradConfig, R.expGradConfig, b.expm1GradConfig, I.floorDivGradConfig, k.floorGradConfig, L.fusedBatchNormGradConfig, y.gatherGradConfig, E.greaterEqualGradConfig, z.identityGradConfig, F.isFiniteGradConfig, w.isInfGradConfig, H.isNanGradConfig, O.log1pGradConfig, U.logGradConfig, Z.logSoftmaxGradConfig, j.lrnGradConfig, J.maxGradConfig, J.maxGradConfig, K.maximumGradConfig, Q.maxPool3DGradConfig, W.maxPoolGradConfig, X.minGradConfig, Y.minimumGradConfig, $.modGradConfig, rr.multiplyGradConfig, er.negateGradConfig, ar.oneHotGradConfig, ir.onesLikeGradConfig, dr.padV2GradConfig, dr.padV2GradConfig, gr.powGradConfig, nr.preluGradConfig, or.reciprocalGradConfig, tr.relu6GradConfig, sr.reluGradConfig, ur.reshapeGradConfig, fr.resizeBilinearGradConfig, Cr.resizeNearestNeighborGradConfig, qr.reverseGradConfig, Gr.roundGradConfig, _r.rsqrtGradConfig, lr.selectV2PoolGradConfig, cr.seluGradConfig, pr.sigmoidGradConfig, mr.signGradConfig, hr.sinGradConfig, Sr.sinhGradConfig, Dr.sliceGradConfig, vr.softmaxGradConfig, xr.softplusGradConfig, Nr.spaceToBatchNDGradConfig, Nr.spaceToBatchNDGradConfig, Mr.splitVGradConfig, Mr.splitVGradConfig, Ar.sqrtGradConfig, Pr.squaredDifferenceGradConfig, Br.squareGradConfig, Tr.stepGradConfig, Vr.subGradConfig, Rr.sumGradConfig, br.tanGradConfig, kr.tanhGradConfig, Ir.tileGradConfig, Lr.transposeGradConfig, yr.unpackGradConfig, Er.unsortedSegmentSumGradConfig, zr.zerosLikeGradConfig];
        for (const Hr of wr)(0, Fr.registerGradient)(Hr);
    }, {
        "./gradients/Abs_grad": "ElQS",
        "./gradients/Acos_grad": "JeEo",
        "./gradients/Acosh_grad": "xSyH",
        "./gradients/Add_grad": "FPsn",
        "./gradients/AddN_grad": "eWqU",
        "./gradients/ArgMax_grad": "uSdy",
        "./gradients/ArgMin_grad": "pXdU",
        "./gradients/Asin_grad": "aEuk",
        "./gradients/Asinh_grad": "u5uO",
        "./gradients/Atan2_grad": "TJcA",
        "./gradients/Atan_grad": "X7rA",
        "./gradients/Atanh_grad": "z0kM",
        "./gradients/AvgPool3D_grad": "u0xB",
        "./gradients/AvgPool_grad": "dUPW",
        "./gradients/BatchMatMul_grad": "Czv4",
        "./gradients/BatchToSpaceND_grad": "CDA7",
        "./gradients/BroadcastTo_grad": "Gxda",
        "./gradients/Cast_grad": "ZcTz",
        "./gradients/Ceil_grad": "MI0y",
        "./gradients/ClipByValue_grad": "ckME",
        "./gradients/Concat_grad": "keWD",
        "./gradients/Conv2D_grad": "f1tQ",
        "./gradients/Conv2DBackpropInput_grad": "gRvo",
        "./gradients/Conv3D_grad": "sdO1",
        "./gradients/Cos_grad": "XliK",
        "./gradients/Cosh_grad": "VVun",
        "./gradients/Cumsum_grad": "KT66",
        "./gradients/DepthwiseConv2dNative_grad": "xQGO",
        "./gradients/Dilation2D_grad": "VsH5",
        "./gradients/Div_grad": "ESiR",
        "./gradients/Elu_grad": "NTdC",
        "./gradients/Erf_grad": "rek3",
        "./gradients/Exp_grad": "Y9DI",
        "./gradients/Expm1_grad": "xe2w",
        "./gradients/Floor_grad": "gPYw",
        "./gradients/FloorDiv_grad": "mHhM",
        "./gradients/FusedBatchNorm_grad": "MxAQ",
        "./gradients/GatherV2_grad": "yxTd",
        "./gradients/GreaterEqual_grad": "hc7R",
        "./gradients/Identity_grad": "W6R7",
        "./gradients/IsFinite_grad": "lKGj",
        "./gradients/IsInf_grad": "sqJA",
        "./gradients/IsNan_grad": "gPIs",
        "./gradients/Log1p_grad": "etSi",
        "./gradients/Log_grad": "GDRk",
        "./gradients/LogSoftmax_grad": "BAfN",
        "./gradients/LRN_grad": "mpRs",
        "./gradients/Max_grad": "KejH",
        "./gradients/Maximum_grad": "wKJk",
        "./gradients/MaxPool3D_grad": "TipK",
        "./gradients/MaxPool_grad": "CBRa",
        "./gradients/Min_grad": "MsiO",
        "./gradients/Minimum_grad": "S1mw",
        "./gradients/Mod_grad": "jAgP",
        "./gradients/Multiply_grad": "M1Jy",
        "./gradients/Negate_grad": "WZur",
        "./gradients/OneHot_grad": "dCXG",
        "./gradients/OnesLike_grad": "hnES",
        "./gradients/PadV2_grad": "lf1s",
        "./gradients/Pow_grad": "v3FT",
        "./gradients/Prelu_grad": "Pbhi",
        "./gradients/Reciprocal_grad": "GoQG",
        "./gradients/Relu6_grad": "QfHw",
        "./gradients/Relu_grad": "sCmN",
        "./gradients/Reshape_grad": "LSQe",
        "./gradients/ResizeBilinear_grad": "nSk6",
        "./gradients/ResizeNearestNeighbor_grad": "ZiCH",
        "./gradients/Reverse_grad": "YSs8",
        "./gradients/Round_grad": "GJpt",
        "./gradients/Rsqrt_grad": "agRd",
        "./gradients/SelectV2_grad": "q0Ys",
        "./gradients/Selu_grad": "HeX4",
        "./gradients/Sigmoid_grad": "dkCO",
        "./gradients/Sign_grad": "reLl",
        "./gradients/Sin_grad": "yO8n",
        "./gradients/Sinh_grad": "AfRo",
        "./gradients/Slice_grad": "h1Er",
        "./gradients/Softmax_grad": "fO38",
        "./gradients/Softplus_grad": "hrsO",
        "./gradients/SpaceToBatchND_grad": "T91W",
        "./gradients/SplitV_grad": "bAb4",
        "./gradients/Sqrt_grad": "iClX",
        "./gradients/Square_grad": "mVS9",
        "./gradients/SquaredDifference_grad": "TPwK",
        "./gradients/Step_grad": "wx7z",
        "./gradients/Sub_grad": "JOrk",
        "./gradients/Sum_grad": "isro",
        "./gradients/Tan_grad": "se8T",
        "./gradients/Tanh_grad": "xokp",
        "./gradients/Tile_grad": "v6Hb",
        "./gradients/Transpose_grad": "tjBW",
        "./gradients/Unpack_grad": "uMFh",
        "./gradients/UnsortedSegmentSum_grad": "hjTI",
        "./gradients/ZerosLike_grad": "qCQu",
        "./kernel_registry": "wJg6"
    }],
    "szKX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.PlatformBrowser = void 0;
        var e = require("../environment");
        class r {
            fetch(e, r) {
                return fetch(e, r)
            }
            now() {
                return performance.now()
            }
            encode(e, r) {
                if ("utf-8" !== r && "utf8" !== r) throw new Error(`Browser's encoder only supports utf-8, but got ${r}`);
                return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(e)
            }
            decode(e, r) {
                return new TextDecoder(r).decode(e)
            }
        }
        exports.PlatformBrowser = r, (0, e.env)().get("IS_BROWSER") && (0, e.env)().setPlatform("browser", new r);
    }, {
        "../environment": "Fbeg"
    }],
    "sC8V": [function(require, module, exports) {

    }, {}],
    "sDG1": [function(require, module, exports) {
        var process = require("process");
        var e = require("process");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resetSystemFetch = n, exports.setSystemFetch = c, exports.getSystemFetch = s, exports.PlatformNode = exports.getNodeFetch = void 0;
        var t = require("../environment");
        const r = {
            importFetch: () => require("node-fetch")
        };
        let o;

        function n() {
            o = null
        }

        function c(e) {
            o = e
        }

        function s() {
            return o
        }
        exports.getNodeFetch = r;
        class u {
            constructor() {
                this.util = require("util"), this.textEncoder = new this.util.TextEncoder
            }
            fetch(e, n) {
                return null != (0, t.env)().global.fetch ? (0, t.env)().global.fetch(e, n) : (null == o && (o = r.importFetch()), o(e, n))
            }
            now() {
                const t = e.hrtime();
                return 1e3 * t[0] + t[1] / 1e6
            }
            encode(e, t) {
                if ("utf-8" !== t && "utf8" !== t) throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
                return this.textEncoder.encode(e)
            }
            decode(e, t) {
                return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e)
            }
        }
        exports.PlatformNode = u, (0, t.env)().get("IS_NODE") && (0, t.env)().setPlatform("node", new u);
    }, {
        "../environment": "Fbeg",
        "node-fetch": "sC8V",
        "util": "sC8V",
        "process": "g5IB"
    }],
    "annF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DTYPE_VALUE_SIZE_MAP = void 0;
        const t = {
            float32: 4,
            float16: 2,
            int32: 4,
            uint16: 2,
            uint8: 1,
            bool: 1,
            complex64: 8
        };
        exports.DTYPE_VALUE_SIZE_MAP = t;
    }, {}],
    "FRly": [function(require, module, exports) {
        "use strict";
        exports.byteLength = u, exports.toByteArray = i, exports.fromByteArray = d;
        for (var r = [], t = [], e = "undefined" != typeof Uint8Array ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = n.length; o < a; ++o) r[o] = n[o], t[n.charCodeAt(o)] = o;

        function h(r) {
            var t = r.length;
            if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var e = r.indexOf("=");
            return -1 === e && (e = t), [e, e === t ? 0 : 4 - e % 4]
        }

        function u(r) {
            var t = h(r),
                e = t[0],
                n = t[1];
            return 3 * (e + n) / 4 - n
        }

        function c(r, t, e) {
            return 3 * (t + e) / 4 - e
        }

        function i(r) {
            var n, o, a = h(r),
                u = a[0],
                i = a[1],
                f = new e(c(r, u, i)),
                A = 0,
                d = i > 0 ? u - 4 : u;
            for (o = 0; o < d; o += 4) n = t[r.charCodeAt(o)] << 18 | t[r.charCodeAt(o + 1)] << 12 | t[r.charCodeAt(o + 2)] << 6 | t[r.charCodeAt(o + 3)], f[A++] = n >> 16 & 255, f[A++] = n >> 8 & 255, f[A++] = 255 & n;
            return 2 === i && (n = t[r.charCodeAt(o)] << 2 | t[r.charCodeAt(o + 1)] >> 4, f[A++] = 255 & n), 1 === i && (n = t[r.charCodeAt(o)] << 10 | t[r.charCodeAt(o + 1)] << 4 | t[r.charCodeAt(o + 2)] >> 2, f[A++] = n >> 8 & 255, f[A++] = 255 & n), f
        }

        function f(t) {
            return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t]
        }

        function A(r, t, e) {
            for (var n, o = [], a = t; a < e; a += 3) n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (255 & r[a + 2]), o.push(f(n));
            return o.join("")
        }

        function d(t) {
            for (var e, n = t.length, o = n % 3, a = [], h = 0, u = n - o; h < u; h += 16383) a.push(A(t, h, h + 16383 > u ? u : h + 16383));
            return 1 === o ? (e = t[n - 1], a.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === o && (e = (t[n - 2] << 8) + t[n - 1], a.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), a.join("")
        }
        t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
    }, {}],
    "Quj6": [function(require, module, exports) {
        exports.read = function(a, o, t, r, h) {
            var M, p, w = 8 * h - r - 1,
                f = (1 << w) - 1,
                e = f >> 1,
                i = -7,
                N = t ? h - 1 : 0,
                n = t ? -1 : 1,
                s = a[o + N];
            for (N += n, M = s & (1 << -i) - 1, s >>= -i, i += w; i > 0; M = 256 * M + a[o + N], N += n, i -= 8);
            for (p = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; p = 256 * p + a[o + N], N += n, i -= 8);
            if (0 === M) M = 1 - e;
            else {
                if (M === f) return p ? NaN : 1 / 0 * (s ? -1 : 1);
                p += Math.pow(2, r), M -= e
            }
            return (s ? -1 : 1) * p * Math.pow(2, M - r)
        }, exports.write = function(a, o, t, r, h, M) {
            var p, w, f, e = 8 * M - h - 1,
                i = (1 << e) - 1,
                N = i >> 1,
                n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                s = r ? 0 : M - 1,
                u = r ? 1 : -1,
                l = o < 0 || 0 === o && 1 / o < 0 ? 1 : 0;
            for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, p = i) : (p = Math.floor(Math.log(o) / Math.LN2), o * (f = Math.pow(2, -p)) < 1 && (p--, f *= 2), (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >= 2 && (p++, f /= 2), p + N >= i ? (w = 0, p = i) : p + N >= 1 ? (w = (o * f - 1) * Math.pow(2, h), p += N) : (w = o * Math.pow(2, N - 1) * Math.pow(2, h), p = 0)); h >= 8; a[t + s] = 255 & w, s += u, w /= 256, h -= 8);
            for (p = p << h | w, e += h; e > 0; a[t + s] = 255 & p, s += u, p /= 256, e -= 8);
            a[t + s - u] |= 128 * l
        };
    }, {}],
    "aqZJ": [function(require, module, exports) {
        var r = {}.toString;
        module.exports = Array.isArray || function(t) {
            return "[object Array]" == r.call(t)
        };
    }, {}],
    "aMB2": [function(require, module, exports) {

        var global = arguments[3];
        var t = arguments[3],
            r = require("base64-js"),
            e = require("ieee754"),
            n = require("isarray");

        function i() {
            try {
                var t = new Uint8Array(1);
                return t.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
            } catch (r) {
                return !1
            }
        }

        function o() {
            return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function u(t, r) {
            if (o() < r) throw new RangeError("Invalid typed array length");
            return f.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = f.prototype : (null === t && (t = new f(r)), t.length = r), t
        }

        function f(t, r, e) {
            if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f)) return new f(t, r, e);
            if ("number" == typeof t) {
                if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string");
                return c(this, t)
            }
            return s(this, t, r, e)
        }

        function s(t, r, e, n) {
            if ("number" == typeof r) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? g(t, r, e, n) : "string" == typeof r ? l(t, r, e) : y(t, r)
        }

        function h(t) {
            if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
            if (t < 0) throw new RangeError('"size" argument must not be negative')
        }

        function a(t, r, e, n) {
            return h(r), r <= 0 ? u(t, r) : void 0 !== e ? "string" == typeof n ? u(t, r).fill(e, n) : u(t, r).fill(e) : u(t, r)
        }

        function c(t, r) {
            if (h(r), t = u(t, r < 0 ? 0 : 0 | w(r)), !f.TYPED_ARRAY_SUPPORT)
                for (var e = 0; e < r; ++e) t[e] = 0;
            return t
        }

        function l(t, r, e) {
            if ("string" == typeof e && "" !== e || (e = "utf8"), !f.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding');
            var n = 0 | v(r, e),
                i = (t = u(t, n)).write(r, e);
            return i !== n && (t = t.slice(0, i)), t
        }

        function p(t, r) {
            var e = r.length < 0 ? 0 : 0 | w(r.length);
            t = u(t, e);
            for (var n = 0; n < e; n += 1) t[n] = 255 & r[n];
            return t
        }

        function g(t, r, e, n) {
            if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds");
            if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds");
            return r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n), f.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = f.prototype : t = p(t, r), t
        }

        function y(t, r) {
            if (f.isBuffer(r)) {
                var e = 0 | w(r.length);
                return 0 === (t = u(t, e)).length ? t : (r.copy(t, 0, 0, e), t)
            }
            if (r) {
                if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || W(r.length) ? u(t, 0) : p(t, r);
                if ("Buffer" === r.type && n(r.data)) return p(t, r.data)
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
        }

        function w(t) {
            if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes");
            return 0 | t
        }

        function d(t) {
            return +t != t && (t = 0), f.alloc(+t)
        }

        function v(t, r) {
            if (f.isBuffer(t)) return t.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
            "string" != typeof t && (t = "" + t);
            var e = t.length;
            if (0 === e) return 0;
            for (var n = !1;;) switch (r) {
                case "ascii":
                case "latin1":
                case "binary":
                    return e;
                case "utf8":
                case "utf-8":
                case void 0:
                    return $(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * e;
                case "hex":
                    return e >>> 1;
                case "base64":
                    return K(t).length;
                default:
                    if (n) return $(t).length;
                    r = ("" + r).toLowerCase(), n = !0
            }
        }

        function E(t, r, e) {
            var n = !1;
            if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
            if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
            if ((e >>>= 0) <= (r >>>= 0)) return "";
            for (t || (t = "utf8");;) switch (t) {
                case "hex":
                    return x(this, r, e);
                case "utf8":
                case "utf-8":
                    return Y(this, r, e);
                case "ascii":
                    return L(this, r, e);
                case "latin1":
                case "binary":
                    return D(this, r, e);
                case "base64":
                    return S(this, r, e);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return C(this, r, e);
                default:
                    if (n) throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(), n = !0
            }
        }

        function b(t, r, e) {
            var n = t[r];
            t[r] = t[e], t[e] = n
        }

        function R(t, r, e, n, i) {
            if (0 === t.length) return -1;
            if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
                if (i) return -1;
                e = t.length - 1
            } else if (e < 0) {
                if (!i) return -1;
                e = 0
            }
            if ("string" == typeof r && (r = f.from(r, n)), f.isBuffer(r)) return 0 === r.length ? -1 : _(t, r, e, n, i);
            if ("number" == typeof r) return r &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : _(t, [r], e, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function _(t, r, e, n, i) {
            var o, u = 1,
                f = t.length,
                s = r.length;
            if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                if (t.length < 2 || r.length < 2) return -1;
                u = 2, f /= 2, s /= 2, e /= 2
            }

            function h(t, r) {
                return 1 === u ? t[r] : t.readUInt16BE(r * u)
            }
            if (i) {
                var a = -1;
                for (o = e; o < f; o++)
                    if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                        if (-1 === a && (a = o), o - a + 1 === s) return a * u
                    } else -1 !== a && (o -= o - a), a = -1
            } else
                for (e + s > f && (e = f - s), o = e; o >= 0; o--) {
                    for (var c = !0, l = 0; l < s; l++)
                        if (h(t, o + l) !== h(r, l)) {
                            c = !1;
                            break
                        } if (c) return o
                }
            return -1
        }

        function A(t, r, e, n) {
            e = Number(e) || 0;
            var i = t.length - e;
            n ? (n = Number(n)) > i && (n = i) : n = i;
            var o = r.length;
            if (o % 2 != 0) throw new TypeError("Invalid hex string");
            n > o / 2 && (n = o / 2);
            for (var u = 0; u < n; ++u) {
                var f = parseInt(r.substr(2 * u, 2), 16);
                if (isNaN(f)) return u;
                t[e + u] = f
            }
            return u
        }

        function m(t, r, e, n) {
            return Q($(r, t.length - e), t, e, n)
        }

        function P(t, r, e, n) {
            return Q(G(r), t, e, n)
        }

        function T(t, r, e, n) {
            return P(t, r, e, n)
        }

        function B(t, r, e, n) {
            return Q(K(r), t, e, n)
        }

        function U(t, r, e, n) {
            return Q(H(r, t.length - e), t, e, n)
        }

        function S(t, e, n) {
            return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n))
        }

        function Y(t, r, e) {
            e = Math.min(t.length, e);
            for (var n = [], i = r; i < e;) {
                var o, u, f, s, h = t[i],
                    a = null,
                    c = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                if (i + c <= e) switch (c) {
                    case 1:
                        h < 128 && (a = h);
                        break;
                    case 2:
                        128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                        break;
                    case 3:
                        o = t[i + 1], u = t[i + 2], 128 == (192 & o) && 128 == (192 & u) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & u) > 2047 && (s < 55296 || s > 57343) && (a = s);
                        break;
                    case 4:
                        o = t[i + 1], u = t[i + 2], f = t[i + 3], 128 == (192 & o) && 128 == (192 & u) && 128 == (192 & f) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & u) << 6 | 63 & f) > 65535 && s < 1114112 && (a = s)
                }
                null === a ? (a = 65533, c = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += c
            }
            return O(n)
        }
        exports.Buffer = f, exports.SlowBuffer = d, exports.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : i(), exports.kMaxLength = o(), f.poolSize = 8192, f._augment = function(t) {
            return t.__proto__ = f.prototype, t
        }, f.from = function(t, r, e) {
            return s(null, t, r, e)
        }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, {
            value: null,
            configurable: !0
        })), f.alloc = function(t, r, e) {
            return a(null, t, r, e)
        }, f.allocUnsafe = function(t) {
            return c(null, t)
        }, f.allocUnsafeSlow = function(t) {
            return c(null, t)
        }, f.isBuffer = function(t) {
            return !(null == t || !t._isBuffer)
        }, f.compare = function(t, r) {
            if (!f.isBuffer(t) || !f.isBuffer(r)) throw new TypeError("Arguments must be Buffers");
            if (t === r) return 0;
            for (var e = t.length, n = r.length, i = 0, o = Math.min(e, n); i < o; ++i)
                if (t[i] !== r[i]) {
                    e = t[i], n = r[i];
                    break
                } return e < n ? -1 : n < e ? 1 : 0
        }, f.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        }, f.concat = function(t, r) {
            if (!n(t)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length) return f.alloc(0);
            var e;
            if (void 0 === r)
                for (r = 0, e = 0; e < t.length; ++e) r += t[e].length;
            var i = f.allocUnsafe(r),
                o = 0;
            for (e = 0; e < t.length; ++e) {
                var u = t[e];
                if (!f.isBuffer(u)) throw new TypeError('"list" argument must be an Array of Buffers');
                u.copy(i, o), o += u.length
            }
            return i
        }, f.byteLength = v, f.prototype._isBuffer = !0, f.prototype.swap16 = function() {
            var t = this.length;
            if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var r = 0; r < t; r += 2) b(this, r, r + 1);
            return this
        }, f.prototype.swap32 = function() {
            var t = this.length;
            if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var r = 0; r < t; r += 4) b(this, r, r + 3), b(this, r + 1, r + 2);
            return this
        }, f.prototype.swap64 = function() {
            var t = this.length;
            if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var r = 0; r < t; r += 8) b(this, r, r + 7), b(this, r + 1, r + 6), b(this, r + 2, r + 5), b(this, r + 3, r + 4);
            return this
        }, f.prototype.toString = function() {
            var t = 0 | this.length;
            return 0 === t ? "" : 0 === arguments.length ? Y(this, 0, t) : E.apply(this, arguments)
        }, f.prototype.equals = function(t) {
            if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === f.compare(this, t)
        }, f.prototype.inspect = function() {
            var t = "",
                r = exports.INSPECT_MAX_BYTES;
            return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">"
        }, f.prototype.compare = function(t, r, e, n, i) {
            if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length) throw new RangeError("out of range index");
            if (n >= i && r >= e) return 0;
            if (n >= i) return -1;
            if (r >= e) return 1;
            if (this === t) return 0;
            for (var o = (i >>>= 0) - (n >>>= 0), u = (e >>>= 0) - (r >>>= 0), s = Math.min(o, u), h = this.slice(n, i), a = t.slice(r, e), c = 0; c < s; ++c)
                if (h[c] !== a[c]) {
                    o = h[c], u = a[c];
                    break
                } return o < u ? -1 : u < o ? 1 : 0
        }, f.prototype.includes = function(t, r, e) {
            return -1 !== this.indexOf(t, r, e)
        }, f.prototype.indexOf = function(t, r, e) {
            return R(this, t, r, e, !0)
        }, f.prototype.lastIndexOf = function(t, r, e) {
            return R(this, t, r, e, !1)
        }, f.prototype.write = function(t, r, e, n) {
            if (void 0 === r) n = "utf8", e = this.length, r = 0;
            else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
            else {
                if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
            }
            var i = this.length - r;
            if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            for (var o = !1;;) switch (n) {
                case "hex":
                    return A(this, t, r, e);
                case "utf8":
                case "utf-8":
                    return m(this, t, r, e);
                case "ascii":
                    return P(this, t, r, e);
                case "latin1":
                case "binary":
                    return T(this, t, r, e);
                case "base64":
                    return B(this, t, r, e);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return U(this, t, r, e);
                default:
                    if (o) throw new TypeError("Unknown encoding: " + n);
                    n = ("" + n).toLowerCase(), o = !0
            }
        }, f.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };
        var I = 4096;

        function O(t) {
            var r = t.length;
            if (r <= I) return String.fromCharCode.apply(String, t);
            for (var e = "", n = 0; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += I));
            return e
        }

        function L(t, r, e) {
            var n = "";
            e = Math.min(t.length, e);
            for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
            return n
        }

        function D(t, r, e) {
            var n = "";
            e = Math.min(t.length, e);
            for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
            return n
        }

        function x(t, r, e) {
            var n = t.length;
            (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
            for (var i = "", o = r; o < e; ++o) i += Z(t[o]);
            return i
        }

        function C(t, r, e) {
            for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
            return i
        }

        function M(t, r, e) {
            if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
            if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
        }

        function k(t, r, e, n, i, o) {
            if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (r > i || r < o) throw new RangeError('"value" argument is out of bounds');
            if (e + n > t.length) throw new RangeError("Index out of range")
        }

        function N(t, r, e, n) {
            r < 0 && (r = 65535 + r + 1);
            for (var i = 0, o = Math.min(t.length - e, 2); i < o; ++i) t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i)
        }

        function z(t, r, e, n) {
            r < 0 && (r = 4294967295 + r + 1);
            for (var i = 0, o = Math.min(t.length - e, 4); i < o; ++i) t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255
        }

        function F(t, r, e, n, i, o) {
            if (e + n > t.length) throw new RangeError("Index out of range");
            if (e < 0) throw new RangeError("Index out of range")
        }

        function j(t, r, n, i, o) {
            return o || F(t, r, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), e.write(t, r, n, i, 23, 4), n + 4
        }

        function q(t, r, n, i, o) {
            return o || F(t, r, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), e.write(t, r, n, i, 52, 8), n + 8
        }
        f.prototype.slice = function(t, r) {
            var e, n = this.length;
            if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t), f.TYPED_ARRAY_SUPPORT)(e = this.subarray(t, r)).__proto__ = f.prototype;
            else {
                var i = r - t;
                e = new f(i, void 0);
                for (var o = 0; o < i; ++o) e[o] = this[o + t]
            }
            return e
        }, f.prototype.readUIntLE = function(t, r, e) {
            t |= 0, r |= 0, e || M(t, r, this.length);
            for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
            return n
        }, f.prototype.readUIntBE = function(t, r, e) {
            t |= 0, r |= 0, e || M(t, r, this.length);
            for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
            return n
        }, f.prototype.readUInt8 = function(t, r) {
            return r || M(t, 1, this.length), this[t]
        }, f.prototype.readUInt16LE = function(t, r) {
            return r || M(t, 2, this.length), this[t] | this[t + 1] << 8
        }, f.prototype.readUInt16BE = function(t, r) {
            return r || M(t, 2, this.length), this[t] << 8 | this[t + 1]
        }, f.prototype.readUInt32LE = function(t, r) {
            return r || M(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }, f.prototype.readUInt32BE = function(t, r) {
            return r || M(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }, f.prototype.readIntLE = function(t, r, e) {
            t |= 0, r |= 0, e || M(t, r, this.length);
            for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
            return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
        }, f.prototype.readIntBE = function(t, r, e) {
            t |= 0, r |= 0, e || M(t, r, this.length);
            for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
        }, f.prototype.readInt8 = function(t, r) {
            return r || M(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }, f.prototype.readInt16LE = function(t, r) {
            r || M(t, 2, this.length);
            var e = this[t] | this[t + 1] << 8;
            return 32768 & e ? 4294901760 | e : e
        }, f.prototype.readInt16BE = function(t, r) {
            r || M(t, 2, this.length);
            var e = this[t + 1] | this[t] << 8;
            return 32768 & e ? 4294901760 | e : e
        }, f.prototype.readInt32LE = function(t, r) {
            return r || M(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }, f.prototype.readInt32BE = function(t, r) {
            return r || M(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }, f.prototype.readFloatLE = function(t, r) {
            return r || M(t, 4, this.length), e.read(this, t, !0, 23, 4)
        }, f.prototype.readFloatBE = function(t, r) {
            return r || M(t, 4, this.length), e.read(this, t, !1, 23, 4)
        }, f.prototype.readDoubleLE = function(t, r) {
            return r || M(t, 8, this.length), e.read(this, t, !0, 52, 8)
        }, f.prototype.readDoubleBE = function(t, r) {
            return r || M(t, 8, this.length), e.read(this, t, !1, 52, 8)
        }, f.prototype.writeUIntLE = function(t, r, e, n) {
            (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
            var i = 1,
                o = 0;
            for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
            return r + e
        }, f.prototype.writeUIntBE = function(t, r, e, n) {
            (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
            var i = e - 1,
                o = 1;
            for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
            return r + e
        }, f.prototype.writeUInt8 = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1
        }, f.prototype.writeUInt16LE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2
        }, f.prototype.writeUInt16BE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2
        }, f.prototype.writeUInt32LE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : z(this, t, r, !0), r + 4
        }, f.prototype.writeUInt32BE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4
        }, f.prototype.writeIntLE = function(t, r, e, n) {
            if (t = +t, r |= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                k(this, t, r, e, i - 1, -i)
            }
            var o = 0,
                u = 1,
                f = 0;
            for (this[r] = 255 & t; ++o < e && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + o - 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
            return r + e
        }, f.prototype.writeIntBE = function(t, r, e, n) {
            if (t = +t, r |= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                k(this, t, r, e, i - 1, -i)
            }
            var o = e - 1,
                u = 1,
                f = 0;
            for (this[r + o] = 255 & t; --o >= 0 && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + o + 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
            return r + e
        }, f.prototype.writeInt8 = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
        }, f.prototype.writeInt16LE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2
        }, f.prototype.writeInt16BE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2
        }, f.prototype.writeInt32LE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : z(this, t, r, !0), r + 4
        }, f.prototype.writeInt32BE = function(t, r, e) {
            return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4
        }, f.prototype.writeFloatLE = function(t, r, e) {
            return j(this, t, r, !0, e)
        }, f.prototype.writeFloatBE = function(t, r, e) {
            return j(this, t, r, !1, e)
        }, f.prototype.writeDoubleLE = function(t, r, e) {
            return q(this, t, r, !0, e)
        }, f.prototype.writeDoubleBE = function(t, r, e) {
            return q(this, t, r, !1, e)
        }, f.prototype.copy = function(t, r, e, n) {
            if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0;
            if (0 === t.length || 0 === this.length) return 0;
            if (r < 0) throw new RangeError("targetStart out of bounds");
            if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds");
            if (n < 0) throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e);
            var i, o = n - e;
            if (this === t && e < r && r < n)
                for (i = o - 1; i >= 0; --i) t[i + r] = this[i + e];
            else if (o < 1e3 || !f.TYPED_ARRAY_SUPPORT)
                for (i = 0; i < o; ++i) t[i + r] = this[i + e];
            else Uint8Array.prototype.set.call(t, this.subarray(e, e + o), r);
            return o
        }, f.prototype.fill = function(t, r, e, n) {
            if ("string" == typeof t) {
                if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) {
                    var i = t.charCodeAt(0);
                    i < 256 && (t = i)
                }
                if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !f.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
            } else "number" == typeof t && (t &= 255);
            if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index");
            if (e <= r) return this;
            var o;
            if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t)
                for (o = r; o < e; ++o) this[o] = t;
            else {
                var u = f.isBuffer(t) ? t : $(new f(t, n).toString()),
                    s = u.length;
                for (o = 0; o < e - r; ++o) this[o + r] = u[o % s]
            }
            return this
        };
        var V = /[^+\/0-9A-Za-z-_]/g;

        function X(t) {
            if ((t = J(t).replace(V, "")).length < 2) return "";
            for (; t.length % 4 != 0;) t += "=";
            return t
        }

        function J(t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
        }

        function Z(t) {
            return t < 16 ? "0" + t.toString(16) : t.toString(16)
        }

        function $(t, r) {
            var e;
            r = r || 1 / 0;
            for (var n = t.length, i = null, o = [], u = 0; u < n; ++u) {
                if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
                    if (!i) {
                        if (e > 56319) {
                            (r -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (u + 1 === n) {
                            (r -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = e;
                        continue
                    }
                    if (e < 56320) {
                        (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                        continue
                    }
                    e = 65536 + (i - 55296 << 10 | e - 56320)
                } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, e < 128) {
                    if ((r -= 1) < 0) break;
                    o.push(e)
                } else if (e < 2048) {
                    if ((r -= 2) < 0) break;
                    o.push(e >> 6 | 192, 63 & e | 128)
                } else if (e < 65536) {
                    if ((r -= 3) < 0) break;
                    o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                } else {
                    if (!(e < 1114112)) throw new Error("Invalid code point");
                    if ((r -= 4) < 0) break;
                    o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                }
            }
            return o
        }

        function G(t) {
            for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
            return r
        }

        function H(t, r) {
            for (var e, n, i, o = [], u = 0; u < t.length && !((r -= 2) < 0); ++u) n = (e = t.charCodeAt(u)) >> 8, i = e % 256, o.push(i), o.push(n);
            return o
        }

        function K(t) {
            return r.toByteArray(X(t))
        }

        function Q(t, r, e, n) {
            for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
            return i
        }

        function W(t) {
            return t != t
        }
    }, {
        "base64-js": "FRly",
        "ieee754": "Quj6",
        "isarray": "aqZJ",
        "buffer": "aMB2"
    }],
    "FekA": [function(require, module, exports) {
        var Buffer = require("buffer").Buffer;
        var e = require("buffer").Buffer;
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.encodeWeights = a, exports.decodeWeights = s, exports.concatenateTypedArrays = f, exports.stringByteLength = y, exports.arrayBufferToBase64String = p, exports.base64StringToArrayBuffer = u, exports.concatenateArrayBuffers = c, exports.basename = h, exports.getModelArtifactsInfoForJSON = d, exports.getFloat16Decoder = b;
        var t = require("../ops/complex"),
            n = require("../ops/tensor"),
            r = require("../util"),
            o = require("./types");
        const i = 4;
        async function a(e, t) {
            const n = [],
                r = [],
                o = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);
            for (let a = 0; a < o.length; ++a) {
                const s = o[a],
                    f = Array.isArray(e) ? e[a].tensor : e[s];
                if ("float32" !== f.dtype && "int32" !== f.dtype && "bool" !== f.dtype && "string" !== f.dtype && "complex64" !== f.dtype) throw new Error(`Unsupported dtype in weight '${s}': ${f.dtype}`);
                const l = {
                    name: s,
                    shape: f.shape,
                    dtype: f.dtype
                };
                if ("string" === f.dtype) {
                    const e = new Promise(async e => {
                        const t = await f.bytes(),
                            n = t.reduce((e, t) => e + t.length, 0) + i * t.length,
                            r = new Uint8Array(n);
                        let o = 0;
                        for (let a = 0; a < t.length; a++) {
                            const e = t[a],
                                n = new Uint8Array(new Uint32Array([e.length]).buffer);
                            r.set(n, o), o += i, r.set(e, o), o += e.length
                        }
                        e(r)
                    });
                    r.push(e)
                } else r.push(f.data());
                null != t && (l.group = t), n.push(l)
            }
            return {
                data: f(await Promise.all(r)),
                specs: n
            }
        }

        function s(e, a) {
            const s = {};
            let f, l = 0;
            for (const y of a) {
                const a = y.name,
                    p = y.dtype,
                    u = y.shape,
                    c = (0, r.sizeFromShape)(u);
                let h;
                if ("quantization" in y) {
                    const t = y.quantization;
                    if ("uint8" === t.dtype || "uint16" === t.dtype) {
                        if (!("min" in t && "scale" in t)) throw new Error(`Weight ${y.name} with quantization ${t.dtype} ` + "doesn't have corresponding metadata min and scale.")
                    } else {
                        if ("float16" !== t.dtype) throw new Error(`Weight ${y.name} has unknown ` + `quantization dtype ${t.dtype}. ` + "Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
                        if ("float32" !== p) throw new Error(`Weight ${y.name} is quantized with ${t.dtype} ` + `which only supports weights of type float32 not ${p}.`)
                    }
                    const n = o.DTYPE_VALUE_SIZE_MAP[t.dtype],
                        r = e.slice(l, l + c * n),
                        i = "uint8" === t.dtype ? new Uint8Array(r) : new Uint16Array(r);
                    if ("float32" === p)
                        if ("uint8" === t.dtype || "uint16" === t.dtype) {
                            h = new Float32Array(i.length);
                            for (let e = 0; e < i.length; e++) {
                                const n = i[e];
                                h[e] = n * t.scale + t.min
                            }
                        } else {
                            if ("float16" !== t.dtype) throw new Error(`Unsupported quantization type ${t.dtype} ` + "for weight type float32.");
                            void 0 === f && (f = b()), h = f(i)
                        }
                    else {
                        if ("int32" !== p) throw new Error(`Unsupported dtype in weight '${a}': ${p}`);
                        if ("uint8" !== t.dtype && "uint16" !== t.dtype) throw new Error(`Unsupported quantization type ${t.dtype} ` + "for weight type int32.");
                        h = new Int32Array(i.length);
                        for (let e = 0; e < i.length; e++) {
                            const n = i[e];
                            h[e] = Math.round(n * t.scale + t.min)
                        }
                    }
                    l += c * n
                } else if ("string" === p) {
                    const t = (0, r.sizeFromShape)(y.shape);
                    h = [];
                    for (let n = 0; n < t; n++) {
                        const t = new Uint32Array(e.slice(l, l + i))[0];
                        l += i;
                        const n = new Uint8Array(e.slice(l, l + t));
                        h.push(n), l += t
                    }
                } else {
                    const r = o.DTYPE_VALUE_SIZE_MAP[p],
                        i = e.slice(l, l + c * r);
                    if ("float32" === p) h = new Float32Array(i);
                    else if ("int32" === p) h = new Int32Array(i);
                    else if ("bool" === p) h = new Uint8Array(i);
                    else {
                        if ("complex64" !== p) throw new Error(`Unsupported dtype in weight '${a}': ${p}`); {
                            h = new Float32Array(i);
                            const e = new Float32Array(h.length / 2),
                                r = new Float32Array(h.length / 2);
                            for (let t = 0; t < e.length; t++) e[t] = h[2 * t], r[t] = h[2 * t + 1];
                            const o = (0, n.tensor)(e, u, "float32"),
                                f = (0, n.tensor)(r, u, "float32");
                            s[a] = (0, t.complex)(o, f)
                        }
                    }
                    l += c * r
                }
                "complex64" !== p && (s[a] = (0, n.tensor)(h, u, p))
            }
            return s
        }

        function f(e) {
            if (null === e) throw new Error(`Invalid input value: ${JSON.stringify(e)}`);
            let t = 0;
            const n = [];
            e.forEach(e => {
                if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)
            });
            const r = new Uint8Array(t);
            let o = 0;
            return n.forEach(e => {
                r.set(new Uint8Array(e.buffer), o), o += e.byteLength
            }), r.buffer
        }
        const l = void 0 !== e && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

        function y(t) {
            return l ? e.byteLength(t) : new Blob([t]).size
        }

        function p(t) {
            if (l) return e.from(t).toString("base64");
            const n = new Uint8Array(t);
            let r = "";
            for (let e = 0, o = n.length; e < o; e++) r += String.fromCharCode(n[e]);
            return btoa(r)
        }

        function u(t) {
            if (l) {
                const n = e.from(t, "base64");
                return n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength)
            }
            const n = atob(t),
                r = new Uint8Array(n.length);
            for (let e = 0; e < n.length; ++e) r.set([n.charCodeAt(e)], e);
            return r.buffer
        }

        function c(e) {
            if (1 === e.length) return e[0];
            let t = 0;
            e.forEach(e => {
                t += e.byteLength
            });
            const n = new Uint8Array(t);
            let r = 0;
            return e.forEach(e => {
                n.set(new Uint8Array(e), r), r += e.byteLength
            }), n.buffer
        }

        function h(e) {
            for (e = e.trim(); e.endsWith("/");) e = e.slice(0, e.length - 1);
            const t = e.split("/");
            return t[t.length - 1]
        }

        function d(e) {
            if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
            return {
                dateSaved: new Date,
                modelTopologyType: "JSON",
                modelTopologyBytes: null == e.modelTopology ? 0 : y(JSON.stringify(e.modelTopology)),
                weightSpecsBytes: null == e.weightSpecs ? 0 : y(JSON.stringify(e.weightSpecs)),
                weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
            }
        }

        function w() {
            const e = e => {
                    let t = e << 13,
                        n = 0;
                    for (; 0 == (8388608 & t);) n -= 8388608, t <<= 1;
                    return (t &= -8388609) | (n += 947912704)
                },
                t = new Uint32Array(2048);
            t[0] = 0;
            for (let n = 1; n < 1024; n++) t[n] = e(n);
            for (let n = 1024; n < 2048; n++) t[n] = 939524096 + (n - 1024 << 13);
            return t
        }

        function g() {
            const e = new Uint32Array(64);
            e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;
            for (let t = 1; t < 31; t++) e[t] = t << 23;
            for (let t = 33; t < 63; t++) e[t] = 2147483648 + (t - 32 << 23);
            return e
        }

        function A() {
            const e = new Uint32Array(64);
            for (let t = 0; t < 64; t++) e[t] = 1024;
            return e[0] = e[32] = 0, e
        }

        function b() {
            const e = w(),
                t = g(),
                n = A();
            return r => {
                const o = new ArrayBuffer(4 * r.length),
                    i = new Uint32Array(o);
                for (let a = 0; a < r.length; a++) {
                    const o = r[a],
                        s = e[n[o >> 10] + (1023 & o)] + t[o >> 10];
                    i[a] = s
                }
                return new Float32Array(o)
            }
        }
    }, {
        "../ops/complex": "Iowv",
        "../ops/tensor": "P2QC",
        "../util": "P6nv",
        "./types": "annF",
        "buffer": "aMB2"
    }],
    "y7n6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getLoadHandlers = exports.getSaveHandlers = exports.registerLoadRouter = exports.registerSaveRouter = exports.IORouterRegistry = void 0;
        class e {
            constructor() {
                this.saveRouters = [], this.loadRouters = []
            }
            static getInstance() {
                return null == e.instance && (e.instance = new e), e.instance
            }
            static registerSaveRouter(t) {
                e.getInstance().saveRouters.push(t)
            }
            static registerLoadRouter(t) {
                e.getInstance().loadRouters.push(t)
            }
            static getSaveHandlers(t) {
                return e.getHandlers(t, "save")
            }
            static getLoadHandlers(t, s) {
                return e.getHandlers(t, "load", s)
            }
            static getHandlers(t, s, r) {
                const a = [];
                return ("load" === s ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach(e => {
                    const s = e(t, r);
                    null !== s && a.push(s)
                }), a
            }
        }
        exports.IORouterRegistry = e;
        const t = t => e.registerSaveRouter(t);
        exports.registerSaveRouter = t;
        const s = t => e.registerLoadRouter(t);
        exports.registerLoadRouter = s;
        const r = t => e.getSaveHandlers(t);
        exports.getSaveHandlers = r;
        const a = (t, s) => e.getLoadHandlers(t, s);
        exports.getLoadHandlers = a;
    }, {}],
    "HWNt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.moveModel = l, exports.copyModel = c, exports.removeModel = i, exports.listModels = o, exports.ModelStoreManagerRegistry = void 0;
        var e = require("../util"),
            t = require("./router_registry");
        const n = "://";
        class s {
            constructor() {
                this.managers = {}
            }
            static getInstance() {
                return null == s.instance && (s.instance = new s), s.instance
            }
            static registerManager(t, r) {
                (0, e.assert)(null != t, () => "scheme must not be undefined or null."), t.endsWith(n) && (t = t.slice(0, t.indexOf(n))), (0, e.assert)(t.length > 0, () => "scheme must not be an empty string.");
                const a = s.getInstance();
                (0, e.assert)(null == a.managers[t], () => `A model store manager is already registered for scheme '${t}'.`), a.managers[t] = r
            }
            static getManager(e) {
                const t = this.getInstance().managers[e];
                if (null == t) throw new Error(`Cannot find model manager for scheme '${e}'`);
                return t
            }
            static getSchemes() {
                return Object.keys(this.getInstance().managers)
            }
        }

        function r(e) {
            if (-1 === e.indexOf(n)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + `${s.getSchemes().join(",")}`);
            return {
                scheme: e.split(n)[0],
                path: e.split(n)[1]
            }
        }
        async function a(n, a, o = !1) {
            (0, e.assert)(n !== a, () => `Old path and new path are the same: '${n}'`);
            const i = t.IORouterRegistry.getLoadHandlers(n);
            (0, e.assert)(i.length > 0, () => `Copying failed because no load handler is found for source URL ${n}.`), (0, e.assert)(i.length < 2, () => `Copying failed because more than one (${i.length}) ` + `load handlers for source URL ${n}.`);
            const c = i[0],
                l = t.IORouterRegistry.getSaveHandlers(a);
            (0, e.assert)(l.length > 0, () => "Copying failed because no save handler is found for destination " + `URL ${a}.`), (0, e.assert)(l.length < 2, () => `Copying failed because more than one (${i.length}) ` + `save handlers for destination URL ${a}.`);
            const g = l[0],
                d = r(n).scheme,
                u = r(n).path,
                h = d === r(n).scheme,
                m = await c.load();
            o && h && await s.getManager(d).removeModel(u);
            const f = await g.save(m);
            return o && !h && await s.getManager(d).removeModel(u), f.modelArtifactsInfo
        }
        async function o() {
            const e = s.getSchemes(),
                t = {};
            for (const r of e) {
                const e = await s.getManager(r).listModels();
                for (const s in e) {
                    t[r + n + s] = e[s]
                }
            }
            return t
        }
        async function i(e) {
            const t = r(e);
            return s.getManager(t.scheme).removeModel(t.path)
        }
        async function c(e, t) {
            return a(e, t, !1)
        }
        async function l(e, t) {
            return a(e, t, !0)
        }
        exports.ModelStoreManagerRegistry = s;
    }, {
        "../util": "P6nv",
        "./router_registry": "y7n6"
    }],
    "nmFM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.deleteDatabase = l, exports.browserIndexedDB = h, exports.BrowserIndexedDBManager = exports.indexedDBRouter = exports.BrowserIndexedDB = void 0;
        var e = require("../environment"),
            o = require("./io_utils"),
            r = require("./model_management"),
            t = require("./router_registry");
        const n = "tensorflowjs",
            s = 1,
            c = "models_store",
            d = "model_info_store";
        async function l() {
            const e = a();
            return new Promise((o, r) => {
                const t = e.deleteDatabase(n);
                t.onsuccess = (() => o()), t.onerror = (e => r(e))
            })
        }

        function a() {
            if (!(0, e.env)().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
            const o = "undefined" == typeof window ? self : window,
                r = o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB || o.shimIndexedDB;
            if (null == r) throw new Error("The current browser does not appear to support IndexedDB.");
            return r
        }

        function i(e) {
            const o = e.result;
            o.createObjectStore(c, {
                keyPath: "modelPath"
            }), o.createObjectStore(d, {
                keyPath: "modelPath"
            })
        }
        class u {
            constructor(e) {
                if (this.indexedDB = a(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
                this.modelPath = e
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                return this.databaseAction(this.modelPath, e)
            }
            async load() {
                return this.databaseAction(this.modelPath)
            }
            databaseAction(e, r) {
                return new Promise((e, t) => {
                    const l = this.indexedDB.open(n, s);
                    l.onupgradeneeded = (() => i(l)), l.onsuccess = (() => {
                        const n = l.result;
                        if (null == r) {
                            const o = n.transaction(c, "readonly"),
                                r = o.objectStore(c).get(this.modelPath);
                            r.onsuccess = (() => {
                                if (null == r.result) return n.close(), t(new Error(`Cannot find model with path '${this.modelPath}' ` + "in IndexedDB."));
                                e(r.result.modelArtifacts)
                            }), r.onerror = (e => (n.close(), t(r.error))), o.oncomplete = (() => n.close())
                        } else {
                            const s = (0, o.getModelArtifactsInfoForJSON)(r),
                                l = n.transaction(d, "readwrite");
                            let a = l.objectStore(d);
                            const i = a.put({
                                modelPath: this.modelPath,
                                modelArtifactsInfo: s
                            });
                            let u;
                            i.onsuccess = (() => {
                                const o = (u = n.transaction(c, "readwrite")).objectStore(c).put({
                                    modelPath: this.modelPath,
                                    modelArtifacts: r,
                                    modelArtifactsInfo: s
                                });
                                o.onsuccess = (() => e({
                                    modelArtifactsInfo: s
                                })), o.onerror = (e => {
                                    const r = (a = l.objectStore(d)).delete(this.modelPath);
                                    r.onsuccess = (() => (n.close(), t(o.error))), r.onerror = (e => (n.close(), t(o.error)))
                                })
                            }), i.onerror = (e => (n.close(), t(i.error))), l.oncomplete = (() => {
                                null == u ? n.close() : u.oncomplete = (() => n.close())
                            })
                        }
                    }), l.onerror = (e => t(l.error))
                })
            }
        }
        exports.BrowserIndexedDB = u, u.URL_SCHEME = "indexeddb://";
        const m = o => (0, e.env)().getBool("IS_BROWSER") && !Array.isArray(o) && o.startsWith(u.URL_SCHEME) ? h(o.slice(u.URL_SCHEME.length)) : null;

        function h(e) {
            return new u(e)
        }

        function f(e) {
            return e.startsWith(u.URL_SCHEME) ? e.slice(u.URL_SCHEME.length) : e
        }
        exports.indexedDBRouter = m, t.IORouterRegistry.registerSaveRouter(m), t.IORouterRegistry.registerLoadRouter(m);
        class w {
            constructor() {
                this.indexedDB = a()
            }
            async listModels() {
                return new Promise((e, o) => {
                    const r = this.indexedDB.open(n, s);
                    r.onupgradeneeded = (() => i(r)), r.onsuccess = (() => {
                        const t = r.result,
                            n = t.transaction(d, "readonly"),
                            s = n.objectStore(d).getAll();
                        s.onsuccess = (() => {
                            const o = {};
                            for (const e of s.result) o[e.modelPath] = e.modelArtifactsInfo;
                            e(o)
                        }), s.onerror = (e => (t.close(), o(s.error))), n.oncomplete = (() => t.close())
                    }), r.onerror = (e => o(r.error))
                })
            }
            async removeModel(e) {
                return e = f(e), new Promise((o, r) => {
                    const t = this.indexedDB.open(n, s);
                    t.onupgradeneeded = (() => i(t)), t.onsuccess = (() => {
                        const n = t.result,
                            s = n.transaction(d, "readwrite"),
                            l = s.objectStore(d),
                            a = l.get(e);
                        let i;
                        a.onsuccess = (() => {
                            if (null == a.result) return n.close(), r(new Error(`Cannot find model with path '${e}' ` + "in IndexedDB.")); {
                                const t = l.delete(e),
                                    s = () => {
                                        const t = (i = n.transaction(c, "readwrite")).objectStore(c).delete(e);
                                        t.onsuccess = (() => o(a.result.modelArtifactsInfo)), t.onerror = (e => r(a.error))
                                    };
                                t.onsuccess = s, t.onerror = (e => (s(), n.close(), r(a.error)))
                            }
                        }), a.onerror = (e => (n.close(), r(a.error))), s.oncomplete = (() => {
                            null == i ? n.close() : i.oncomplete = (() => n.close())
                        })
                    }), t.onerror = (e => r(t.error))
                })
            }
        }
        if (exports.BrowserIndexedDBManager = w, (0, e.env)().getBool("IS_BROWSER")) try {
            r.ModelStoreManagerRegistry.registerManager(u.URL_SCHEME, new w)
        } catch (p) {}
    }, {
        "../environment": "Fbeg",
        "./io_utils": "FekA",
        "./model_management": "HWNt",
        "./router_registry": "y7n6"
    }],
    "TVL0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.purgeLocalStorageArtifacts = c, exports.browserLocalStorage = u, exports.BrowserLocalStorageManager = exports.localStorageRouter = exports.BrowserLocalStorage = void 0;
        var e = require("../environment"),
            t = require("../util"),
            o = require("./io_utils"),
            r = require("./model_management"),
            s = require("./router_registry");
        const i = "/",
            a = "tensorflowjs_models",
            n = "info",
            l = "model_topology",
            g = "weight_specs",
            h = "weight_data",
            d = "model_metadata";

        function c() {
            if (!(0, e.env)().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");
            const t = window.localStorage,
                o = [];
            for (let e = 0; e < t.length; ++e) {
                const r = t.key(e),
                    s = a + i;
                if (r.startsWith(s) && r.length > s.length) {
                    t.removeItem(r);
                    const e = m(r); - 1 === o.indexOf(e) && o.push(e)
                }
            }
            return o
        }

        function S(e) {
            return {
                info: [a, e, n].join(i),
                topology: [a, e, l].join(i),
                weightSpecs: [a, e, g].join(i),
                weightData: [a, e, h].join(i),
                modelMetadata: [a, e, d].join(i)
            }
        }

        function m(e) {
            const t = e.split(i);
            if (t.length < 3) throw new Error(`Invalid key format: ${e}`);
            return t.slice(1, t.length - 1).join(i)
        }

        function w(e) {
            return e.startsWith(y.URL_SCHEME) ? e.slice(y.URL_SCHEME.length) : e
        }
        class y {
            constructor(t) {
                if (!(0, e.env)().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
                if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
                this.modelPath = t, this.keys = S(this.modelPath)
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet."); {
                    const r = JSON.stringify(e.modelTopology),
                        s = JSON.stringify(e.weightSpecs),
                        i = (0, o.getModelArtifactsInfoForJSON)(e);
                    try {
                        return this.LS.setItem(this.keys.info, JSON.stringify(i)), this.LS.setItem(this.keys.topology, r), this.LS.setItem(this.keys.weightSpecs, s), this.LS.setItem(this.keys.weightData, (0, o.arrayBufferToBase64String)(e.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
                            format: e.format,
                            generatedBy: e.generatedBy,
                            convertedBy: e.convertedBy,
                            userDefinedMetadata: e.userDefinedMetadata
                        })), {
                            modelArtifactsInfo: i
                        }
                    } catch (t) {
                        throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error(`Failed to save model '${this.modelPath}' to local storage: ` + "size quota being exceeded is a possible cause of this failure: " + `modelTopologyBytes=${i.modelTopologyBytes}, ` + `weightSpecsBytes=${i.weightSpecsBytes}, ` + `weightDataBytes=${i.weightDataBytes}.`)
                    }
                }
            }
            async load() {
                const e = JSON.parse(this.LS.getItem(this.keys.info));
                if (null == e) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
                if ("JSON" !== e.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                const t = {},
                    r = JSON.parse(this.LS.getItem(this.keys.topology));
                if (null == r) throw new Error(`In local storage, the topology of model '${this.modelPath}' ` + "is missing.");
                t.modelTopology = r;
                const s = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (null == s) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' ` + "are missing.");
                t.weightSpecs = s;
                const i = this.LS.getItem(this.keys.modelMetadata);
                if (null != i) {
                    const e = JSON.parse(i);
                    t.format = e.format, t.generatedBy = e.generatedBy, t.convertedBy = e.convertedBy, t.userDefinedMetadata = e.userDefinedMetadata
                }
                const a = this.LS.getItem(this.keys.weightData);
                if (null == a) throw new Error("In local storage, the binary weight values of model " + `'${this.modelPath}' are missing.`);
                return t.weightData = (0, o.base64StringToArrayBuffer)(a), t
            }
        }
        exports.BrowserLocalStorage = y, y.URL_SCHEME = "localstorage://";
        const f = t => (0, e.env)().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(y.URL_SCHEME) ? u(t.slice(y.URL_SCHEME.length)) : null;

        function u(e) {
            return new y(e)
        }
        exports.localStorageRouter = f, s.IORouterRegistry.registerSaveRouter(f), s.IORouterRegistry.registerLoadRouter(f);
        class p {
            constructor() {
                (0, t.assert)((0, e.env)().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), (0, t.assert)("undefined" == typeof window || void 0 !== window.localStorage, () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage
            }
            async listModels() {
                const e = {},
                    t = a + i,
                    o = i + n;
                for (let r = 0; r < this.LS.length; ++r) {
                    const s = this.LS.key(r);
                    if (s.startsWith(t) && s.endsWith(o)) {
                        e[m(s)] = JSON.parse(this.LS.getItem(s))
                    }
                }
                return e
            }
            async removeModel(e) {
                const t = S(e = w(e));
                if (null == this.LS.getItem(t.info)) throw new Error(`Cannot find model at path '${e}'`);
                const o = JSON.parse(this.LS.getItem(t.info));
                return this.LS.removeItem(t.info), this.LS.removeItem(t.topology), this.LS.removeItem(t.weightSpecs), this.LS.removeItem(t.weightData), o
            }
        }
        if (exports.BrowserLocalStorageManager = p, (0, e.env)().getBool("IS_BROWSER")) try {
            r.ModelStoreManagerRegistry.registerManager(y.URL_SCHEME, new p)
        } catch (L) {}
    }, {
        "../environment": "Fbeg",
        "../util": "P6nv",
        "./io_utils": "FekA",
        "./model_management": "HWNt",
        "./router_registry": "y7n6"
    }],
    "D1db": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.browserDownloads = h, exports.browserFiles = c, exports.browserDownloadsRouter = exports.BrowserDownloads = void 0;
        var e = require("../environment"),
            t = require("./io_utils"),
            o = require("./router_registry");
        const r = "model",
            n = ".json",
            s = ".weights.bin";

        function i(e) {
            return new Promise(e => setTimeout(e)).then(e)
        }
        class a {
            constructor(t) {
                if (!(0, e.env)().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
                t.startsWith(a.URL_SCHEME) && (t = t.slice(a.URL_SCHEME.length)), null != t && 0 !== t.length || (t = r), this.modelTopologyFileName = t + n, this.weightDataFileName = t + s
            }
            async save(e) {
                if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                const o = window.URL.createObjectURL(new Blob([e.weightData], {
                    type: "application/octet-stream"
                }));
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet."); {
                    const r = [{
                            paths: ["./" + this.weightDataFileName],
                            weights: e.weightSpecs
                        }],
                        n = {
                            modelTopology: e.modelTopology,
                            format: e.format,
                            generatedBy: e.generatedBy,
                            convertedBy: e.convertedBy,
                            weightsManifest: r
                        },
                        s = window.URL.createObjectURL(new Blob([JSON.stringify(n)], {
                            type: "application/json"
                        })),
                        a = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor;
                    if (a.download = this.modelTopologyFileName, a.href = s, await i(() => a.dispatchEvent(new MouseEvent("click"))), null != e.weightData) {
                        const e = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor;
                        e.download = this.weightDataFileName, e.href = o, await i(() => e.dispatchEvent(new MouseEvent("click")))
                    }
                    return {
                        modelArtifactsInfo: (0, t.getModelArtifactsInfoForJSON)(e)
                    }
                }
            }
        }
        exports.BrowserDownloads = a, a.URL_SCHEME = "downloads://";
        class l {
            constructor(e) {
                if (null == e || e.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, " + `but received ${e}`);
                this.files = e
            }
            async load() {
                const e = this.files[0],
                    o = this.files.slice(1);
                return new Promise((r, n) => {
                    const s = new FileReader;
                    s.onload = (s => {
                        const i = JSON.parse(s.target.result),
                            a = i.modelTopology;
                        if (null == a) return void n(new Error(`modelTopology field is missing from file ${e.name}`));
                        0 === o.length && r({
                            modelTopology: a
                        });
                        const l = i.weightsManifest;
                        if (null == l) return void n(new Error(`weightManifest field is missing from file ${e.name}`));
                        let d;
                        try {
                            d = this.checkManifestAndWeightFiles(l, o)
                        } catch (w) {
                            return void n(w)
                        }
                        const h = [],
                            c = [],
                            f = [];
                        l.forEach(e => {
                            e.paths.forEach(e => {
                                c.push(e), f.push(null)
                            }), h.push(...e.weights)
                        }), l.forEach(e => {
                            e.paths.forEach(e => {
                                const o = new FileReader;
                                o.onload = (o => {
                                    const n = o.target.result,
                                        s = c.indexOf(e);
                                    f[s] = n, -1 === f.indexOf(null) && r({
                                        modelTopology: a,
                                        weightSpecs: h,
                                        weightData: (0, t.concatenateArrayBuffers)(f),
                                        format: i.format,
                                        generatedBy: i.generatedBy,
                                        convertedBy: i.convertedBy,
                                        userDefinedMetadata: i.userDefinedMetadata
                                    })
                                }), o.onerror = (t => n(`Failed to weights data from file of path '${e}'.`)), o.readAsArrayBuffer(d[e])
                            })
                        })
                    }), s.onerror = (t => n("Failed to read model topology and weights manifest JSON " + `from file '${e.name}'. BrowserFiles supports loading ` + "Keras-style tf.Model artifacts only.")), s.readAsText(e)
                })
            }
            checkManifestAndWeightFiles(e, o) {
                const r = [],
                    n = o.map(e => (0, t.basename)(e.name)),
                    s = {};
                for (const i of e) i.paths.forEach(e => {
                    const i = (0, t.basename)(e);
                    if (-1 !== r.indexOf(i)) throw new Error("Duplicate file basename found in weights manifest: " + `'${i}'`);
                    if (r.push(i), -1 === n.indexOf(i)) throw new Error(`Weight file with basename '${i}' is not provided.`);
                    s[e] = o[n.indexOf(i)]
                });
                if (r.length !== o.length) throw new Error("Mismatch in the number of files in weights manifest " + `(${r.length}) and the number of weight files provided ` + `(${o.length}).`);
                return s
            }
        }
        const d = t => (0, e.env)().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(a.URL_SCHEME) ? h(t.slice(a.URL_SCHEME.length)) : null;

        function h(e = "model") {
            return new a(e)
        }

        function c(e) {
            return new l(e)
        }
        exports.browserDownloadsRouter = d, o.IORouterRegistry.registerSaveRouter(d);
    }, {
        "../environment": "Fbeg",
        "./io_utils": "FekA",
        "./router_registry": "y7n6"
    }],
    "lqgM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.monitorPromisesProgress = r;
        var t = require("../util");

        function r(r, e, n, s) {
            ! function(r) {
                (0, t.assert)(null != r && Array.isArray(r) && r.length > 0, () => "promises must be a none empty array")
            }(r),
            function(r, e) {
                (0, t.assert)(r >= 0 && r <= 1, () => "Progress fraction must be in range [0, 1], but " + `got startFraction ${r}`), (0, t.assert)(e >= 0 && e <= 1, () => "Progress fraction must be in range [0, 1], but " + `got endFraction ${e}`), (0, t.assert)(e >= r, () => "startFraction must be no more than endFraction, but " + `got startFraction ${r} and endFraction ` + `${e}`)
            }(n = null == n ? 0 : n, s = null == s ? 1 : s);
            let o = 0;
            return Promise.all(r.map(t => (t.then(t => {
                const a = n + ++o / r.length * (s - n);
                return e(a), t
            }), t)))
        }
    }, {
        "../util": "P6nv"
    }],
    "gxqX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.loadWeightsAsArrayBuffer = a, exports.loadWeights = u, exports.weightsLoaderFactory = f;
        var e = require("../environment"),
            t = i(require("../util")),
            r = require("./io_utils"),
            n = require("./progress"),
            o = require("./types");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = s();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, o, i) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }
        async function a(t, r) {
            null == r && (r = {});
            const o = null == r.fetchFunc ? (0, e.env)().platform.fetch : r.fetchFunc,
                s = t.map(e => o(e, r.requestInit, {
                    isBinary: !0
                })),
                i = (null == r.onProgress ? await Promise.all(s) : await (0, n.monitorPromisesProgress)(s, r.onProgress, 0, .5)).map(e => e.arrayBuffer());
            return null == r.onProgress ? await Promise.all(i) : await (0, n.monitorPromisesProgress)(i, r.onProgress, .5, 1)
        }
        async function u(e, t = "", r, n) {
            return f(e => a(e, {
                requestInit: n
            }))(e, t, r)
        }

        function f(e) {
            return async (n, s = "", i) => {
                const a = n.map(() => !1),
                    u = {},
                    f = null != i ? i.map(() => !1) : [],
                    c = [];
                if (n.forEach((e, r) => {
                        let n = 0;
                        e.weights.forEach(e => {
                            const s = "quantization" in e ? e.quantization.dtype : e.dtype,
                                l = o.DTYPE_VALUE_SIZE_MAP[s] * t.sizeFromShape(e.shape),
                                p = () => {
                                    a[r] = !0, null == u[r] && (u[r] = []), u[r].push({
                                        manifestEntry: e,
                                        groupOffset: n,
                                        sizeBytes: l
                                    })
                                };
                            null != i ? i.forEach((t, r) => {
                                t === e.name && (p(), f[r] = !0)
                            }) : p(), c.push(e.name), n += l
                        })
                    }), !f.every(e => e)) {
                    const e = i.filter((e, t) => !f[t]);
                    throw new Error("Could not find weights in manifest with names: " + `${e.join(", ")}. \n` + "Manifest JSON has weights with names: " + `${c.join(", ")}.`)
                }
                const l = a.reduce((e, t, r) => (t && e.push(r), e), []),
                    p = [];
                l.forEach(e => {
                    n[e].paths.forEach(e => {
                        const t = s + (s.endsWith("/") ? "" : "/") + e;
                        p.push(t)
                    })
                });
                const h = await e(p),
                    y = {};
                let g = 0;
                return l.forEach(e => {
                    const t = n[e].paths.length;
                    let o = 0;
                    for (let r = 0; r < t; r++) o += h[g + r].byteLength;
                    const s = new ArrayBuffer(o),
                        i = new Uint8Array(s);
                    let a = 0;
                    for (let r = 0; r < t; r++) {
                        const e = new Uint8Array(h[g + r]);
                        i.set(e, a), a += e.byteLength
                    }
                    u[e].forEach(e => {
                        const t = s.slice(e.groupOffset, e.groupOffset + e.sizeBytes),
                            n = (0, r.decodeWeights)(t, [e.manifestEntry]);
                        for (const r in n) y[r] = n[r]
                    }), g += t
                }), y
            }
        }
    }, {
        "../environment": "Fbeg",
        "../util": "P6nv",
        "./io_utils": "FekA",
        "./progress": "lqgM",
        "./types": "annF"
    }],
    "qhti": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.parseUrl = h, exports.isHTTPScheme = u, exports.http = f, exports.browserHTTPRequest = c, exports.httpRouter = exports.HTTPRequest = void 0;
        var e = require("../environment"),
            t = require("../util"),
            o = require("./io_utils"),
            r = require("./router_registry"),
            s = require("./weights_loader");
        const n = "application/octet-stream",
            i = "application/json";
        class a {
            constructor(o, r) {
                if (this.DEFAULT_METHOD = "POST", null == r && (r = {}), this.weightPathPrefix = r.weightPathPrefix, this.onProgress = r.onProgress, null != r.fetchFunc ? ((0, t.assert)("function" == typeof r.fetchFunc, () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = r.fetchFunc) : this.fetch = (0, e.env)().platform.fetch, (0, t.assert)(null != o && o.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(o) && (0, t.assert)(2 === o.length, () => "URL paths for http must have a length of 2, " + `(actual length is ${o.length}).`), this.path = o, null != r.requestInit && null != r.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
                this.requestInit = r.requestInit || {}
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                const t = Object.assign({
                    method: this.DEFAULT_METHOD
                }, this.requestInit);
                t.body = new FormData;
                const r = [{
                        paths: ["./model.weights.bin"],
                        weights: e.weightSpecs
                    }],
                    s = {
                        modelTopology: e.modelTopology,
                        format: e.format,
                        generatedBy: e.generatedBy,
                        convertedBy: e.convertedBy,
                        userDefinedMetadata: e.userDefinedMetadata,
                        weightsManifest: r
                    };
                t.body.append("model.json", new Blob([JSON.stringify(s)], {
                    type: i
                }), "model.json"), null != e.weightData && t.body.append("model.weights.bin", new Blob([e.weightData], {
                    type: n
                }), "model.weights.bin");
                const a = await this.fetch(this.path, t);
                if (a.ok) return {
                    modelArtifactsInfo: (0, o.getModelArtifactsInfoForJSON)(e),
                    responses: [a]
                };
                throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + `${a.status}.`)
            }
            async load() {
                const e = await this.fetch(this.path, this.requestInit);
                if (!e.ok) throw new Error(`Request to ${this.path} failed with status code ` + `${e.status}. Please verify this URL points to ` + "the model JSON of the model to load.");
                let t;
                try {
                    t = await e.json()
                } catch (l) {
                    let e = `Failed to parse model JSON of response from ${this.path}.`;
                    throw this.path.endsWith(".pb") ? e += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : e += " Please make sure the server is serving valid JSON for this request.", new Error(e)
                }
                const o = t.modelTopology,
                    r = t.weightsManifest,
                    s = t.generatedBy,
                    n = t.convertedBy,
                    i = t.format,
                    a = t.userDefinedMetadata;
                if (null == o && null == r) throw new Error(`The JSON from HTTP path ${this.path} contains neither model ` + "topology or manifest for weights.");
                let h, u;
                if (null != r) {
                    const e = await this.loadWeights(r);
                    [h, u] = e
                }
                return {
                    modelTopology: o,
                    weightSpecs: h,
                    weightData: u,
                    userDefinedMetadata: a,
                    generatedBy: s,
                    convertedBy: n,
                    format: i
                }
            }
            async loadWeights(e) {
                const t = Array.isArray(this.path) ? this.path[1] : this.path,
                    [r, n] = h(t),
                    i = this.weightPathPrefix || r,
                    a = [];
                for (const o of e) a.push(...o.weights);
                const u = [];
                e.forEach(e => {
                    e.paths.forEach(e => {
                        u.push(i + e + n)
                    })
                });
                const l = await (0, s.loadWeightsAsArrayBuffer)(u, {
                    requestInit: this.requestInit,
                    fetchFunc: this.fetch,
                    onProgress: this.onProgress
                });
                return [a, (0, o.concatenateArrayBuffers)(l)]
            }
        }

        function h(e) {
            const t = e.lastIndexOf("/"),
                o = e.lastIndexOf("?");
            return [e.substring(0, t) + "/", o > t ? e.substring(o) : ""]
        }

        function u(e) {
            return null != e.match(a.URL_SCHEME_REGEX)
        }
        exports.HTTPRequest = a, a.URL_SCHEME_REGEX = /^https?:\/\//;
        const l = (e, t) => {
            if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null; {
                let o = !0;
                if (o = Array.isArray(e) ? e.every(e => u(e)) : u(e)) return f(e, t)
            }
            return null
        };

        function f(e, t) {
            return new a(e, t)
        }

        function c(e, t) {
            return f(e, t)
        }
        exports.httpRouter = l, r.IORouterRegistry.registerSaveRouter(l), r.IORouterRegistry.registerLoadRouter(l);
    }, {
        "../environment": "Fbeg",
        "../util": "P6nv",
        "./io_utils": "FekA",
        "./router_registry": "y7n6",
        "./weights_loader": "gxqX"
    }],
    "ulLq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fromMemory = t, exports.withSaveHandler = r;
        class e {
            constructor(e) {
                this.modelArtifacts = e
            }
            async load() {
                return this.modelArtifacts
            }
        }
        class o {
            constructor(e) {
                this.saveHandler = e
            }
            async save(e) {
                return this.saveHandler(e)
            }
        }

        function t(o, t, r, n) {
            if (1 === arguments.length) {
                return null != o.modelTopology || null != o.weightSpecs ? new e(o) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new e({
                    modelTopology: o
                }))
            }
            return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new e({
                modelTopology: o,
                weightSpecs: t,
                weightData: r,
                trainingConfig: n
            })
        }

        function r(e) {
            return new o(e)
        }
    }, {}],
    "EwEE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "browserFiles", {
            enumerable: !0,
            get: function() {
                return e.browserFiles
            }
        }), Object.defineProperty(exports, "browserHTTPRequest", {
            enumerable: !0,
            get: function() {
                return r.browserHTTPRequest
            }
        }), Object.defineProperty(exports, "http", {
            enumerable: !0,
            get: function() {
                return r.http
            }
        }), Object.defineProperty(exports, "isHTTPScheme", {
            enumerable: !0,
            get: function() {
                return r.isHTTPScheme
            }
        }), Object.defineProperty(exports, "concatenateArrayBuffers", {
            enumerable: !0,
            get: function() {
                return t.concatenateArrayBuffers
            }
        }), Object.defineProperty(exports, "decodeWeights", {
            enumerable: !0,
            get: function() {
                return t.decodeWeights
            }
        }), Object.defineProperty(exports, "encodeWeights", {
            enumerable: !0,
            get: function() {
                return t.encodeWeights
            }
        }), Object.defineProperty(exports, "getModelArtifactsInfoForJSON", {
            enumerable: !0,
            get: function() {
                return t.getModelArtifactsInfoForJSON
            }
        }), Object.defineProperty(exports, "fromMemory", {
            enumerable: !0,
            get: function() {
                return o.fromMemory
            }
        }), Object.defineProperty(exports, "withSaveHandler", {
            enumerable: !0,
            get: function() {
                return o.withSaveHandler
            }
        }), Object.defineProperty(exports, "getLoadHandlers", {
            enumerable: !0,
            get: function() {
                return n.getLoadHandlers
            }
        }), Object.defineProperty(exports, "getSaveHandlers", {
            enumerable: !0,
            get: function() {
                return n.getSaveHandlers
            }
        }), Object.defineProperty(exports, "registerLoadRouter", {
            enumerable: !0,
            get: function() {
                return n.registerLoadRouter
            }
        }), Object.defineProperty(exports, "registerSaveRouter", {
            enumerable: !0,
            get: function() {
                return n.registerSaveRouter
            }
        }), Object.defineProperty(exports, "loadWeights", {
            enumerable: !0,
            get: function() {
                return u.loadWeights
            }
        }), Object.defineProperty(exports, "weightsLoaderFactory", {
            enumerable: !0,
            get: function() {
                return u.weightsLoaderFactory
            }
        }), Object.defineProperty(exports, "copyModel", {
            enumerable: !0,
            get: function() {
                return i.copyModel
            }
        }), Object.defineProperty(exports, "listModels", {
            enumerable: !0,
            get: function() {
                return i.listModels
            }
        }), Object.defineProperty(exports, "moveModel", {
            enumerable: !0,
            get: function() {
                return i.moveModel
            }
        }), Object.defineProperty(exports, "removeModel", {
            enumerable: !0,
            get: function() {
                return i.removeModel
            }
        }), require("./indexed_db"), require("./local_storage");
        var e = require("./browser_files"),
            r = require("./http"),
            t = require("./io_utils"),
            o = require("./passthrough"),
            n = require("./router_registry"),
            u = require("./weights_loader"),
            i = require("./model_management");
    }, {
        "./indexed_db": "nmFM",
        "./local_storage": "TVL0",
        "./browser_files": "D1db",
        "./http": "qhti",
        "./io_utils": "FekA",
        "./passthrough": "ulLq",
        "./router_registry": "y7n6",
        "./weights_loader": "gxqX",
        "./model_management": "HWNt"
    }],
    "ETzZ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.oneHot = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation"),
            t = require("./reshape");

        function i(n, i, s = 1, u = 0) {
            if (i < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${i}`);
            const p = (0, o.convertToTensor)(n, "indices", "oneHot", "int32"),
                a = [...p.shape, i],
                l = {
                    indices: p
                },
                c = {
                    depth: i,
                    onValue: s,
                    offValue: u
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([p]), (0, t.reshape)(e.oneHot(p.flatten(), i, s, u), a)), l, null, r.OneHot, c)
        }
        const s = (0, n.op)({
            oneHot_: i
        });
        exports.oneHot = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "vqyG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.confusionMatrix_ = i, exports.confusionMatrix = void 0;
        var e = require("../tensor_util_env"),
            t = s(require("../util")),
            r = require("./one_hot"),
            n = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = o();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, s) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, s, i) : r[s] = e[s]
                } return r.default = e, t && t.set(e, r), r
        }

        function i(n, o, s) {
            const i = (0, e.convertToTensor)(n, "labels", "confusionMatrix"),
                a = (0, e.convertToTensor)(o, "predictions", "confusionMatrix");
            t.assert(null == s || s > 0 && Number.isInteger(s), () => "If provided, numClasses must be a positive integer, " + `but got ${s}`), t.assert(1 === i.rank, () => `Expected the rank of labels to be 1, but got ${i.rank}`), t.assert(1 === a.rank, () => "Expected the rank of predictions to be 1, " + `but got ${a.rank}`), t.assert(i.shape[0] === a.shape[0], () => "Mismatch in the number of examples: " + `${i.shape[0]} vs. ${a.shape[0]}. ` + "Labels and predictions should have the same number of elements."), t.assert(s > 0 && Number.isInteger(s), () => "numClasses is required to be a positive integer, but got " + `${s}`);
            const u = (0, r.oneHot)(i.asType("int32"), s),
                p = (0, r.oneHot)(a.asType("int32"), s);
            return u.transpose().matMul(p).asType("int32")
        }
        const a = (0, n.op)({
            confusionMatrix_: i
        });
        exports.confusionMatrix = a;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./one_hot": "ETzZ",
        "./operation": "JtaO"
    }],
    "bMAY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "confusionMatrix", {
            enumerable: !0,
            get: function() {
                return e.confusionMatrix
            }
        });
        var e = require("./ops/confusion_matrix");
    }, {
        "./ops/confusion_matrix": "vqyG"
    }],
    "v3VY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor3d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o, s) {
            if ((0, r.assertNonNull)(n), null != o && 3 !== o.length) throw new Error("tensor3d() requires shape to have three numbers");
            const u = (0, e.inferShape)(n, s);
            if (3 !== u.length && 1 !== u.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
            if (1 === u.length && null == o) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
            return (0, t.makeTensor)(n, o, u, s)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "yVDt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.toPixels = d, exports.fromPixels = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            n = require("../kernel_registry"),
            r = require("../tensor"),
            o = require("../tensor_util_env"),
            a = require("./operation"),
            s = require("./tensor3d");
        let i;

        function l(r, o = 3) {
            if (o > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
            if (null == r) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
            let a = !1,
                l = !1,
                d = !1,
                f = !1,
                u = !1;
            if (r.data instanceof Uint8Array) a = !0;
            else if ("undefined" != typeof ImageData && r instanceof ImageData) l = !0;
            else if ("undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement) d = !0;
            else if ("undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement) f = !0;
            else {
                if (null == r.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, " + `but was ${r.constructor.name}`);
                u = !0
            }
            if (d) {
                const e = 2;
                if (d && r.readyState < e) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")
            }
            if (null != (0, n.getKernel)(t.FromPixels, e.ENGINE.backendName)) {
                const n = {
                        pixels: r
                    },
                    a = {
                        numChannels: o
                    };
                return e.ENGINE.runKernel(t.FromPixels, n, a)
            }
            const [m, h] = d ? [r.videoWidth, r.videoHeight] : [r.width, r.height];
            let c, w;
            if (u ? c = r.getContext("2d").getImageData(0, 0, m, h).data : l || a ? c = r.data : (f || d) && (null == i && (i = document.createElement("canvas").getContext("2d")), i.canvas.width = m, i.canvas.height = h, i.drawImage(r, 0, 0, m, h), c = i.getImageData(0, 0, m, h).data), 4 === o) w = new Int32Array(c);
            else {
                const e = m * h;
                w = new Int32Array(e * o);
                for (let t = 0; t < e; t++)
                    for (let e = 0; e < o; ++e) w[t * o + e] = c[4 * t + e]
            }
            const p = [h, m, o];
            return (0, s.tensor3d)(w, p, "int32")
        }
        async function d(e, t) {
            let n = (0, o.convertToTensor)(e, "img", "toPixels");
            if (!(e instanceof r.Tensor)) {
                const e = n;
                n = e.toInt(), e.dispose()
            }
            if (2 !== n.rank && 3 !== n.rank) throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);
            const [a, s] = n.shape.slice(0, 2), i = 2 === n.rank ? 1 : n.shape[2];
            if (i > 4 || 2 === i) throw new Error("toPixels only supports depth of size " + `1, 3 or 4 but got ${i}`);
            const l = await n.data(),
                d = n.min(),
                f = n.max(),
                u = await Promise.all([d.data(), f.data()]),
                m = u[0],
                h = u[1],
                c = m[0],
                w = h[0];
            if (d.dispose(), f.dispose(), "float32" === n.dtype) {
                if (c < 0 || w > 1) throw new Error("Tensor values for a float32 Tensor must be in the " + `range [0 - 1] but got range [${c} - ${w}].`)
            } else {
                if ("int32" !== n.dtype) throw new Error(`Unsupported type for toPixels: ${n.dtype}.` + " Please use float32 or int32 tensors.");
                if (c < 0 || w > 255) throw new Error("Tensor values for a int32 Tensor must be in the " + `range [0 - 255] but got range [${c} - ${w}].`)
            }
            const p = "float32" === n.dtype ? 255 : 1,
                g = new Uint8ClampedArray(s * a * 4);
            for (let r = 0; r < a * s; ++r) {
                let e, t, n, o;
                1 === i ? (e = l[r] * p, t = l[r] * p, n = l[r] * p, o = 255) : 3 === i ? (e = l[3 * r] * p, t = l[3 * r + 1] * p, n = l[3 * r + 2] * p, o = 255) : 4 === i && (e = l[4 * r] * p, t = l[4 * r + 1] * p, n = l[4 * r + 2] * p, o = l[4 * r + 3] * p);
                const a = 4 * r;
                g[a + 0] = Math.round(e), g[a + 1] = Math.round(t), g[a + 2] = Math.round(n), g[a + 3] = Math.round(o)
            }
            if (null != t) {
                t.width = s, t.height = a;
                const e = t.getContext("2d"),
                    n = new ImageData(g, s, a);
                e.putImageData(n, 0, 0)
            }
            return n !== e && n.dispose(), g
        }
        const f = (0, a.op)({
            fromPixels_: l
        });
        exports.fromPixels = f;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../kernel_registry": "wJg6",
        "../tensor": "DTHt",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./tensor3d": "v3VY"
    }],
    "ZyFe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.prepareAndValidate = t;
        var e = require("../util");

        function t(t, r) {
            if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher," + ` but the rank was ${t.rank}.`);
            if (r.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher," + ` but the rank was ${r.rank}.`);
            if ("int32" !== r.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type," + ` but the dtype was ${r.dtype}.`);
            if (r.shape[r.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + `${r.shape[r.rank-1]} vs. ${t.rank}`);
            if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty." + ` Input shape: ${t.shape}.`);
            const n = r.shape,
                s = n[n.length - 1];
            let a = 1;
            for (let e = 0; e < n.length - 1; ++e) a *= n[e];
            const i = t.shape,
                o = n.slice();
            o.pop();
            let h = 1;
            for (let e = s; e < t.rank; ++e) h *= i[e], o.push(i[e]);
            const p = [...(0, e.computeStrides)(t.shape).map(e => e / h), 1].slice(0, s);
            return [o, a, h, p]
        }
    }, {
        "../util": "P6nv"
    }],
    "H15o": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateUpdateShape = t, exports.validateInput = r, exports.calculateShapes = a;
        var e = require("../util");

        function t(e, t, r) {
            const a = t.rank > 1 ? t.shape[t.rank - 1] : 1,
                s = t.rank > 1 ? t.rank - 1 : 1,
                p = "Must have updates.shape = indices.shape[:batchDim] + " + `shape[sliceDim:], got updates.shape: ${r.shape}` + `, indices.shape: ${t.shape}, shape: ${e}` + `, sliceDim: ${a}, and batchDim: ${s}.`;
            if (r.rank < s) throw new Error(p + ` update.rank < ${s}. `);
            if (e.length < a + (r.rank - s)) throw new Error(p + ` Output shape length < ${a+(r.rank-s)}`);
            if (r.rank !== s + e.length - a) throw new Error(p + ` update.rank != ${s+e.length-a}`);
            for (let h = 0; h < s; ++h)
                if (r.shape[h] !== t.shape[h]) throw new Error(p + ` updates.shape[${h}] (${r.shape[h]}) != indices.shape[${h}] (${t.shape[h]}).`);
            for (let h = 0; h < r.rank - s; ++h)
                if (r.shape[h + s] !== e[h + a]) throw new Error(p + ` updates.shape[${h+s}] (${r.shape[h+s]}) != shape[${h+s}] (${e[h+s]})`)
        }

        function r(e, r, a) {
            if (r.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher," + ` but the rank was ${r.rank}.`);
            if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher," + ` but the rank was ${e.rank}.`);
            if ("int32" !== r.dtype) throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${r.dtype}`);
            if (a.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${a}`);
            if (0 === a.length) {
                if (0 === r.size) throw new Error(`Indices specified for empty output. indices shape: ${r.shape}`);
                if (0 === e.size) throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)
            }
            t(a, r, e)
        }

        function a(t, r, a) {
            const s = r.shape.length,
                p = s > 1 ? r.shape[s - 1] : 1,
                h = a.length;
            let n = 1;
            for (let e = p; e < h; ++e) n *= a[e];
            const i = p < 1 ? 1 : p;
            return {
                sliceRank: p,
                numUpdates: (0, e.sizeFromShape)(r.shape) / i,
                sliceSize: n,
                strides: [...(0, e.computeStrides)(a.slice(0, p)), 1],
                outputSize: (0, e.sizeFromShape)(a)
            }
        }
    }, {
        "../util": "P6nv"
    }],
    "HDfU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.registerClass = t, exports.SerializationMap = exports.Serializable = void 0;
        var e = require("./util");
        class s {
            getClassName() {
                return this.constructor.className
            }
            static fromConfig(e, s) {
                return new e(s)
            }
        }
        exports.Serializable = s;
        class a {
            constructor() {
                this.classNameMap = {}
            }
            static getMap() {
                return null == a.instance && (a.instance = new a), a.instance
            }
            static register(e) {
                a.getMap().classNameMap[e.className] = [e, e.fromConfig]
            }
        }

        function t(s) {
            (0, e.assert)(null != s.className, () => "Class being registered does not have the static className property defined."), (0, e.assert)("string" == typeof s.className, () => "className is required to be a string, but got type " + typeof s.className), (0, e.assert)(s.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), a.register(s)
        }
        exports.SerializationMap = a;
    }, {
        "./util": "P6nv"
    }],
    "ip5I": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.expectArraysClose = i, exports.testEpsilon = a, exports.expectPromiseToFail = c, exports.expectArraysEqual = f, exports.expectNumbersClose = l, exports.expectValuesInRange = p, exports.expectArrayBuffersEqual = y, exports.TEST_EPSILON_FLOAT16 = void 0;
        var e = require("./engine"),
            r = require("./tensor_util_env"),
            t = require("./util");
        const n = .001,
            o = .1;

        function i(e, r, t) {
            return null == t && (t = a()), s(e, r, (e, r) => u(e, r, t))
        }

        function a() {
            return 32 === e.ENGINE.backend.floatPrecision() ? n : o
        }

        function s(e, n, o) {
            let i = !0;
            if (((0, t.isTypedArray)(e) || (0, t.isTypedArray)(n)) && (i = !1), (0, t.isTypedArray)(e) && (0, t.isTypedArray)(n) && (i = !0), i) {
                const r = e.constructor.name,
                    t = n.constructor.name;
                if (r !== t) throw new Error(`Arrays are of different type. Actual: ${r}. ` + `Expected: ${t}`)
            }
            if (Array.isArray(e) && Array.isArray(n)) {
                const o = (0, r.inferShape)(e),
                    i = (0, r.inferShape)(n);
                if (!(0, t.arraysEqual)(o, i)) throw new Error("Arrays have different shapes. " + `Actual: [${o}]. Expected: [${i}]`)
            }
            const a = (0, t.isTypedArray)(e) ? e : (0, t.flatten)(e),
                s = (0, t.isTypedArray)(n) ? n : (0, t.flatten)(n);
            if (a.length !== s.length) throw new Error(`Arrays have different lengths actual: ${a.length} vs ` + `expected: ${s.length}.\n` + `Actual:   ${a}.\n` + `Expected: ${s}.`);
            for (let r = 0; r < s.length; ++r) {
                const e = a[r],
                    t = s[r];
                if (!o(e, t)) throw new Error(`Arrays differ: actual[${r}] = ${e}, expected[${r}] = ${t}.\n` + `Actual:   ${a}.\n` + `Expected: ${s}.`)
            }
        }

        function c(e, r) {
            e().then(() => r.fail(), () => r())
        }

        function f(e, r) {
            const n = "string" == typeof r || "number" == typeof r || "boolean" == typeof r ? [r] : r;
            return (0, t.isString)(e) || (0, t.isString)(e[0]) || (0, t.isString)(r) || (0, t.isString)(r[0]) ? s(e, n, (e, r) => e == r) : s(e, r, (e, r) => u(e, r, 0))
        }

        function l(e, r, t) {
            if (null == t && (t = a()), !u(e, r, t)) throw new Error(`Numbers differ: actual === ${e}, expected === ${r}`)
        }

        function u(e, r, t) {
            return !isFinite(e) && !isFinite(r) || !(isNaN(e) || isNaN(r) || Math.abs(e - r) > t)
        }

        function p(e, r, t) {
            for (let n = 0; n < e.length; n++)
                if (e[n] < r || e[n] > t) throw new Error(`Value out of range:${e[n]} low: ${r}, high: ${t}`)
        }

        function y(e, r) {
            expect(new Float32Array(e)).toEqual(new Float32Array(r))
        }
        exports.TEST_EPSILON_FLOAT16 = o;
    }, {
        "./engine": "Nc3Y",
        "./tensor_util_env": "c6yR",
        "./util": "P6nv"
    }],
    "SdA6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.version = void 0;
        const e = "2.1.0";
        exports.version = "2.1.0";
    }, {}],
    "GWnL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.enableProdMode = o, exports.enableDebugMode = i, exports.disableDeprecationWarnings = s, exports.deprecationWarn = a, exports.disposeVariables = c, exports.engine = u, exports.memory = E, exports.profile = d, exports.tidy = N, exports.dispose = p, exports.keep = f, exports.time = x, exports.setBackend = I, exports.ready = l, exports.getBackend = G, exports.removeBackend = k, exports.findBackend = B, exports.findBackendFactory = b, exports.registerBackend = g, exports.backend = m, exports.setPlatform = v;
        var e = require("./engine"),
            n = require("./environment"),
            r = require("./tensor"),
            t = require("./tensor_util");

        function o() {
            (0, n.env)().set("PROD", !0)
        }

        function i() {
            (0, n.env)().set("DEBUG", !0)
        }

        function s() {
            (0, n.env)().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.")
        }

        function a(e) {
            (0, n.env)().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
        }

        function c() {
            e.ENGINE.disposeVariables()
        }

        function u() {
            return e.ENGINE
        }

        function E() {
            return e.ENGINE.memory()
        }

        function d(n) {
            return e.ENGINE.profile(n)
        }

        function N(n, r) {
            return e.ENGINE.tidy(n, r)
        }

        function p(e) {
            (0, t.getTensorsInContainer)(e).forEach(e => e.dispose())
        }

        function f(n) {
            return e.ENGINE.keep(n)
        }

        function x(n) {
            return e.ENGINE.time(n)
        }

        function I(n) {
            return e.ENGINE.setBackend(n)
        }

        function l() {
            return e.ENGINE.ready()
        }

        function G() {
            return e.ENGINE.backendName
        }

        function k(n) {
            e.ENGINE.removeBackend(n)
        }

        function B(n) {
            return e.ENGINE.findBackend(n)
        }

        function b(n) {
            return e.ENGINE.findBackendFactory(n)
        }

        function g(n, r, t = 1) {
            return e.ENGINE.registerBackend(n, r, t)
        }

        function m() {
            return e.ENGINE.backend
        }

        function v(e, r) {
            (0, n.env)().setPlatform(e, r)
        }(0, r.setDeprecationWarningFn)(a);
    }, {
        "./engine": "Nc3Y",
        "./environment": "Fbeg",
        "./tensor": "DTHt",
        "./tensor_util": "fpST"
    }],
    "aE3W": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.abs = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function s(o) {
            const s = (0, n.convertToTensor)(o, "x", "abs"),
                t = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([s]), "complex64" === s.dtype ? e.complexAbs(s) : e.abs(s)), t, null, r.Abs)
        }
        const t = (0, o.op)({
            abs_: s
        });
        exports.abs = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "wQJc": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.acos = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function s(n) {
            const s = (0, o.convertToTensor)(n, "x", "acos"),
                t = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.acos(s);
                return r([s]), o
            }, t, null, r.Acos)
        }
        const t = (0, n.op)({
            acos_: s
        });
        exports.acos = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "JJYu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.acosh = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function s(n) {
            const s = (0, o.convertToTensor)(n, "x", "acosh"),
                t = {
                    x: s
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.acosh(s);
                return r([s]), o
            }, t, null, r.Acosh)
        }
        const t = (0, n.op)({
            acosh_: s
        });
        exports.acosh = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "EQUq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.addN = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = a(require("../util")),
            o = require("./operation");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = s();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function u(o) {
            n.assert(Array.isArray(o), () => "The argument passed to tf.addN() must be a list of tensors"), n.assert(o.length >= 1, () => "Must pass at least one tensor to tf.addN(), but got " + `${o.length}`);
            const s = o.map((e, t) => (0, r.convertToTensor)(e, `tensors${t}`, "addN")),
                a = s[0];
            s.forEach(e => {
                if (e.dtype !== a.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
            }), s.forEach(e => {
                if (!n.arraysEqual(e.shape, a.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
            });
            const u = s;
            return e.ENGINE.runKernelFunc((e, t) => {
                const r = e.addN(s);
                return t(s), r
            }, u, null, t.AddN)
        }
        const d = (0, o.op)({
            addN_: u
        });
        exports.addN = d;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "VAUj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.all = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("../util"),
            l = require("./axis_util"),
            s = require("./operation");

        function o(s, o = null, a = !1) {
            let i = (0, n.convertToTensor)(s, "x", "all", "bool");
            const u = {
                    x: i
                },
                p = {
                    axis: o,
                    keepDims: a
                };
            return e.ENGINE.runKernelFunc(e => {
                const r = (0, t.parseAxisParam)(o, i.shape);
                let n = r;
                const s = (0, l.getAxesPermutation)(n, i.rank);
                null != s && (i = i.transpose(s), n = (0, l.getInnerMostAxes)(n.length, i.rank));
                const u = e.all(i, n);
                if (a) {
                    const e = (0, l.expandShapeToKeepDim)(u.shape, r);
                    return u.reshape(e)
                }
                return u
            }, u, null, r.All, p)
        }
        const a = (0, s.op)({
            all_: o
        });
        exports.all = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "OF1E": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.any = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("../util"),
            s = require("./axis_util"),
            o = require("./operation");

        function a(o, a = null, i = !1) {
            let u = (0, r.convertToTensor)(o, "x", "any", "bool");
            const l = {
                    x: u
                },
                p = {
                    axis: a,
                    keepDims: i
                };
            return e.ENGINE.runKernelFunc(e => {
                const n = (0, t.parseAxisParam)(a, u.shape);
                let r = n;
                const o = (0, s.getAxesPermutation)(r, u.rank);
                null != o && (u = u.transpose(o), r = (0, s.getInnerMostAxes)(r.length, u.rank));
                const l = e.any(u, r);
                if (i) {
                    const e = (0, s.expandShapeToKeepDim)(l.shape, n);
                    return l.reshape(e)
                }
                return l
            }, l, null, n.Any, p)
        }
        const i = (0, o.op)({
            any_: a
        });
        exports.any = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "wSFk": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.argMax = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            o = i(require("./axis_util")),
            a = require("./operation");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(a, u = 0) {
            let i = (0, t.convertToTensor)(a, "x", "argMax");
            const s = {
                    x: i
                },
                l = {
                    axis: u
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                r([i]);
                let t = n.parseAxisParam(u, i.shape);
                const a = o.getAxesPermutation(t, i.rank);
                return null != a && (i = i.transpose(a), t = o.getInnerMostAxes(t.length, i.rank)), e.argMax(i, t[0])
            }, s, null, r.ArgMax, l)
        }
        const l = (0, a.op)({
            argMax_: s
        });
        exports.argMax = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "Zhc7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.argMin = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = a(require("../util")),
            i = a(require("./axis_util")),
            o = require("./operation");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var o = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, i, o) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function s(o, u = 0) {
            let a = (0, t.convertToTensor)(o, "x", "argMin");
            const s = {
                    x: a
                },
                l = {
                    axis: u
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                r([a]), null == u && (u = 0);
                let t = n.parseAxisParam(u, a.shape);
                const o = i.getAxesPermutation(t, a.rank);
                return null != o && (a = a.transpose(o), t = i.getInnerMostAxes(t.length, a.rank)), e.argMin(a, t[0])
            }, s, null, r.ArgMin, l)
        }
        const l = (0, o.op)({
            argMin_: s
        });
        exports.argMin = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "pS4z": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.asin = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            s = require("./operation");

        function i(s) {
            const i = (0, r.convertToTensor)(s, "x", "asin"),
                o = {
                    x: i
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.asin(i);
                return n([i]), r
            }, o, null, n.Asin)
        }
        const o = (0, s.op)({
            asin_: i
        });
        exports.asin = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "B3dx": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.asinh = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            s = require("./operation");

        function i(s) {
            const i = (0, r.convertToTensor)(s, "x", "asinh"),
                o = {
                    x: i
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.asinh(i);
                return n([i]), r
            }, o, null, n.Asinh)
        }
        const o = (0, s.op)({
            asinh_: i
        });
        exports.asinh = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "Yh9p": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atan = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function o(t) {
            const o = (0, r.convertToTensor)(t, "x", "atan"),
                a = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.atan(o);
                return n([o]), r
            }, a, null, n.Atan)
        }
        const a = (0, t.op)({
            atan_: o
        });
        exports.atan = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "eUJw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atan2 = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util"),
            t = require("../tensor_util_env"),
            a = require("./operation");

        function o(a, o) {
            let u = (0, t.convertToTensor)(a, "a", "atan2"),
                s = (0, t.convertToTensor)(o, "b", "atan2");
            [u, s] = (0, r.makeTypesMatch)(u, s);
            const i = {
                a: u,
                b: s
            };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.atan2(u, s);
                return n([u, s]), r
            }, i, null, n.Atan2)
        }
        const u = (0, a.op)({
            atan2_: o
        });
        exports.atan2 = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "DlnE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.atanh = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function o(t) {
            const o = (0, r.convertToTensor)(t, "x", "atanh"),
                a = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.atanh(o);
                return n([o]), r
            }, a, null, n.Atanh)
        }
        const a = (0, t.op)({
            atanh_: o
        });
        exports.atanh = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "iP9e": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPool = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            o = l(require("../util")),
            n = require("./cast"),
            i = l(require("./conv_util")),
            a = require("./operation"),
            s = require("./reshape");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function l(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var i = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, n, i) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(a, u, l, p, c) {
            const d = (0, t.convertToTensor)(a, "x", "avgPool", "float32");
            o.assert(i.eitherStridesOrDilationsAreOne(l, 1), () => "Error in avgPool: Either strides or dilations must be 1. " + `Got strides ${l} and dilations '1'`);
            let f = d,
                g = !1;
            3 === d.rank && (g = !0, f = (0, s.reshape)(d, [1, d.shape[0], d.shape[1], d.shape[2]])), o.assert(4 === f.rank, () => `Error in avgPool: x must be rank 4 but got rank ${f.rank}.`), null != c && o.assert(o.isInt(p), () => "Error in avgPool: pad must be an integer when using, " + `dimRoundingMode ${c} but got pad ${p}.`);
            const v = {
                    x: f
                },
                h = {
                    filterSize: u,
                    strides: l,
                    pad: p,
                    dimRoundingMode: c
                };
            let P = e.ENGINE.runKernelFunc((e, r) => {
                const t = i.computePool2DInfo(f.shape, u, l, 1, p, c);
                return r([f]), 1 === t.filterWidth && 1 === t.filterHeight && o.arraysEqual(t.inShape, t.outShape) ? f.clone() : e.avgPool(f, t)
            }, v, null, r.AvgPool, h);
            return P = (0, n.cast)(P, d.dtype), g ? P.as3D(P.shape[1], P.shape[2], P.shape[3]) : P
        }
        const c = (0, a.op)({
            avgPool_: p
        });
        exports.avgPool = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./cast": "qqq3",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "df2t": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.avgPool3d = void 0;
        var e = require("../engine"),
            r = require("../globals"),
            t = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = d(require("../util")),
            a = require("./cast"),
            i = d(require("./conv_util")),
            s = require("./operation"),
            u = require("./reshape");

        function l() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return l = function() {
                return e
            }, e
        }

        function d(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = l();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, n, a) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(s, l, d, p, c, f = "NDHWC", g) {
            null == g ? g = [1, 1, 1] : (0, r.deprecationWarn)("dilations is deprecated, this field will be gone in v3.0.0.");
            const v = (0, o.convertToTensor)(s, "x", "avgPool3d", "float32");
            let h = v,
                P = !1;
            4 === v.rank && (P = !0, h = (0, u.reshape)(v, [1, v.shape[0], v.shape[1], v.shape[2], v.shape[3]])), n.assert(5 === h.rank, () => `Error in avgPool3d: x must be rank 5 but got rank ${h.rank}.`), n.assert("NDHWC" === f, () => "Error in avgPool3d: Only NDHWC is currently supported, " + `but got dataFormat of ${f}`), n.assert(i.eitherStridesOrDilationsAreOne(d, g), () => "Error in avgPool3d: Either strides or dilations must be 1. " + `Got strides ${d} and dilations '${g}'`), null != c && n.assert(n.isInt(p), () => "Error in avgPool3d: pad must be an integer when using, " + `dimRoundingMode ${c} but got pad ${p}.`);
            const b = {
                    x: h
                },
                y = {
                    filterSize: l,
                    strides: d,
                    pad: p,
                    dimRoundingMode: c,
                    dataFormat: f,
                    dilations: g
                };
            let O = e.ENGINE.runKernelFunc((e, r) => {
                null == g && (g = [1, 1, 1]);
                const t = i.computePool3DInfo(h.shape, l, d, g, p, c, f);
                return r([h]), e.avgPool3d(h, t)
            }, b, null, t.AvgPool3D, y);
            return O = (0, a.cast)(O, h.dtype), P ? O.as4D(O.shape[1], O.shape[2], O.shape[3], O.shape[4]) : O
        }
        const c = (0, s.op)({
            avgPool3d_: p
        });
        exports.avgPool3d = c;
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./cast": "qqq3",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "ZRNG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tanh = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function o(t) {
            const o = (0, r.convertToTensor)(t, "x", "tanh"),
                u = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.tanh(o);
                return n([r]), r
            }, u, null, n.Tanh)
        }
        const u = (0, t.op)({
            tanh_: o
        });
        exports.tanh = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "yZSA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.basicLSTMCell = void 0;
        var e = require("../tensor_util_env"),
            r = require("./add"),
            i = require("./concat"),
            s = require("./mat_mul"),
            o = require("./mul"),
            l = require("./operation"),
            t = require("./sigmoid"),
            c = require("./slice"),
            a = require("./tanh");

        function n(l, n, u, T, d, m) {
            const M = (0, e.convertToTensor)(l, "forgetBias", "basicLSTMCell"),
                b = (0, e.convertToTensor)(n, "lstmKernel", "basicLSTMCell"),
                v = (0, e.convertToTensor)(u, "lstmBias", "basicLSTMCell"),
                q = (0, e.convertToTensor)(T, "data", "basicLSTMCell"),
                C = (0, e.convertToTensor)(d, "c", "basicLSTMCell"),
                L = (0, e.convertToTensor)(m, "h", "basicLSTMCell"),
                S = (0, i.concat)([q, L], 1),
                p = (0, s.matMul)(S, b),
                h = (0, r.add)(p, v),
                _ = h.shape[0],
                g = h.shape[1] / 4,
                f = [_, g],
                x = (0, c.slice)(h, [0, 0], f),
                B = (0, c.slice)(h, [0, g], f),
                j = (0, c.slice)(h, [0, 2 * g], f),
                y = (0, c.slice)(h, [0, 3 * g], f),
                K = (0, r.add)((0, o.mul)((0, t.sigmoid)(x), (0, a.tanh)(B)), (0, o.mul)(C, (0, t.sigmoid)((0, r.add)(M, j))));
            return [K, (0, o.mul)((0, a.tanh)(K), (0, t.sigmoid)(y))]
        }
        const u = (0, l.op)({
            basicLSTMCell_: n
        });
        exports.basicLSTMCell = u;
    }, {
        "../tensor_util_env": "c6yR",
        "./add": "ZDFV",
        "./concat": "dDdq",
        "./mat_mul": "mMWq",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./sigmoid": "yARQ",
        "./slice": "zP07",
        "./tanh": "ZRNG"
    }],
    "ONs6": [function(require, module, exports) {
        "use strict";

        function e(e) {
            let s;
            return s = 0 === e.rank || 1 === e.rank ? e.as4D(1, 1, 1, e.size) : 2 === e.rank ? e.as4D(1, 1, e.shape[0], e.shape[1]) : 3 === e.rank ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.xAs4D = e;
    }, {}],
    "qqTf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchNorm = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            a = i(require("../util")),
            t = require("./batchnorm_util"),
            o = require("./operation"),
            s = require("./reshape");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                a = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var t in e)
                if (Object.prototype.hasOwnProperty.call(e, t)) {
                    var o = a ? Object.getOwnPropertyDescriptor(e, t) : null;
                    o && (o.get || o.set) ? Object.defineProperty(n, t, o) : n[t] = e[t]
                } return n.default = e, r && r.set(e, n), n
        }

        function c(o, u, i, c, p, f) {
            null == f && (f = .001);
            const h = (0, n.convertToTensor)(o, "x", "batchNorm"),
                v = (0, n.convertToTensor)(u, "mean", "batchNorm"),
                m = (0, n.convertToTensor)(i, "variance", "batchNorm");
            let b, k;
            null != p && (b = (0, n.convertToTensor)(p, "scale", "batchNorm")), null != c && (k = (0, n.convertToTensor)(c, "offset", "batchNorm")), a.assert(v.rank === m.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), a.assert(null == k || v.rank === k.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), a.assert(null == b || v.rank === b.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
            const d = (0, t.xAs4D)(h),
                q = {
                    x: d,
                    scale: b,
                    offset: k,
                    mean: v,
                    variance: m
                },
                N = {
                    varianceEpsilon: f
                },
                y = e.ENGINE.runKernelFunc((e, r) => (r([d, v, m, b]), e.batchNorm(d, l(v), l(m), l(k), l(b), f)), q, null, r.FusedBatchNorm, N);
            return (0, s.reshape)(y, h.shape)
        }

        function l(e) {
            return null == e ? null : 0 === e.rank ? e.as1D() : 1 === e.rank ? e : 2 === e.rank ? e.as4D(1, 1, e.shape[0], e.shape[1]) : 3 === e.rank ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e
        }
        const p = (0, o.op)({
            batchNorm_: c
        });
        exports.batchNorm = p;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./batchnorm_util": "ONs6",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "fmF3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchNorm2d = void 0;
        var r = require("../tensor_util_env"),
            t = a(require("../util")),
            e = require("./batchnorm"),
            n = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return o = function() {
                return r
            }, r
        }

        function a(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var t = o();
            if (t && t.has(r)) return t.get(r);
            var e = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in r)
                if (Object.prototype.hasOwnProperty.call(r, a)) {
                    var c = n ? Object.getOwnPropertyDescriptor(r, a) : null;
                    c && (c.get || c.set) ? Object.defineProperty(e, a, c) : e[a] = r[a]
                } return e.default = r, t && t.set(r, e), e
        }

        function c(n, o, a, c, u, s) {
            const i = (0, r.convertToTensor)(n, "x", "batchNorm"),
                b = (0, r.convertToTensor)(o, "mean", "batchNorm"),
                k = (0, r.convertToTensor)(a, "variance", "batchNorm");
            let l, f;
            return null != u && (l = (0, r.convertToTensor)(u, "scale", "batchNorm")), null != c && (f = (0, r.convertToTensor)(c, "offset", "batchNorm")), t.assert(2 === i.rank, () => "Error in batchNorm3D: x must be rank 3 but got rank " + `${i.rank}.`), t.assert(2 === b.rank || 1 === b.rank, () => "Error in batchNorm2D: mean must be rank 2 or rank 1 but " + `got rank ${b.rank}.`), t.assert(2 === k.rank || 1 === k.rank, () => "Error in batchNorm2D: variance must be rank 2 or rank 1 " + `but got rank ${k.rank}.`), null != l && t.assert(2 === l.rank || 1 === l.rank, () => "Error in batchNorm2D: scale must be rank 2 or rank 1 " + `but got rank ${l.rank}.`), null != f && t.assert(2 === f.rank || 1 === f.rank, () => "Error in batchNorm2D: offset must be rank 2 or rank 1 " + `but got rank ${f.rank}.`), (0, e.batchNorm)(i, b, k, f, l, s)
        }
        const u = (0, n.op)({
            batchNorm2d_: c
        });
        exports.batchNorm2d = u;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./batchnorm": "qqTf",
        "./operation": "JtaO"
    }],
    "seIf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchNorm3d = void 0;
        var r = require("../tensor_util_env"),
            t = a(require("../util")),
            e = require("./batchnorm"),
            n = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return o = function() {
                return r
            }, r
        }

        function a(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var t = o();
            if (t && t.has(r)) return t.get(r);
            var e = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in r)
                if (Object.prototype.hasOwnProperty.call(r, a)) {
                    var c = n ? Object.getOwnPropertyDescriptor(r, a) : null;
                    c && (c.get || c.set) ? Object.defineProperty(e, a, c) : e[a] = r[a]
                } return e.default = r, t && t.set(r, e), e
        }

        function c(n, o, a, c, u, s) {
            const i = (0, r.convertToTensor)(n, "x", "batchNorm"),
                b = (0, r.convertToTensor)(o, "mean", "batchNorm"),
                k = (0, r.convertToTensor)(a, "variance", "batchNorm");
            let l, f;
            return null != u && (l = (0, r.convertToTensor)(u, "scale", "batchNorm")), null != c && (f = (0, r.convertToTensor)(c, "offset", "batchNorm")), t.assert(3 === i.rank, () => "Error in batchNorm3D: x must be rank 3 but got rank " + `${i.rank}.`), t.assert(3 === b.rank || 1 === b.rank, () => "Error in batchNorm3D: mean must be rank 3 or rank 1 but " + `got rank ${b.rank}.`), t.assert(3 === k.rank || 1 === k.rank, () => "Error in batchNorm3D: variance must be rank 3 or rank 1 " + `but got rank ${k.rank}.`), null != l && t.assert(3 === l.rank || 1 === l.rank, () => "Error in batchNorm3D: scale must be rank 3 or rank 1 " + `but got rank ${l.rank}.`), null != f && t.assert(3 === f.rank || 1 === f.rank, () => "Error in batchNorm3D: offset must be rank 3 or rank 1 " + `but got rank ${f.rank}.`), (0, e.batchNorm)(i, b, k, f, l, s)
        }
        const u = (0, n.op)({
            batchNorm3d_: c
        });
        exports.batchNorm3d = u;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./batchnorm": "qqTf",
        "./operation": "JtaO"
    }],
    "REgA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.batchNorm4d = void 0;
        var r = require("../tensor_util_env"),
            t = a(require("../util")),
            e = require("./batchnorm"),
            n = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return o = function() {
                return r
            }, r
        }

        function a(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var t = o();
            if (t && t.has(r)) return t.get(r);
            var e = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in r)
                if (Object.prototype.hasOwnProperty.call(r, a)) {
                    var c = n ? Object.getOwnPropertyDescriptor(r, a) : null;
                    c && (c.get || c.set) ? Object.defineProperty(e, a, c) : e[a] = r[a]
                } return e.default = r, t && t.set(r, e), e
        }

        function c(n, o, a, c, u, s) {
            const i = (0, r.convertToTensor)(n, "x", "batchNorm"),
                b = (0, r.convertToTensor)(o, "mean", "batchNorm"),
                k = (0, r.convertToTensor)(a, "variance", "batchNorm");
            let l, f;
            return null != u && (l = (0, r.convertToTensor)(u, "scale", "batchNorm")), null != c && (f = (0, r.convertToTensor)(c, "offset", "batchNorm")), t.assert(4 === i.rank, () => "Error in batchNorm4D: x must be rank 4 but got rank " + `${i.rank}.`), t.assert(4 === b.rank || 1 === b.rank, () => "Error in batchNorm4D: mean must be rank 4 or rank 1 but " + `got rank ${b.rank}.`), t.assert(4 === k.rank || 1 === k.rank, () => "Error in batchNorm4D: variance must be rank 4 or rank 1 " + `but got rank ${k.rank}.`), null != l && t.assert(4 === l.rank || 1 === l.rank, () => "Error in batchNorm4D: scale must be rank 4 or rank 1 " + `but got rank ${l.rank}.`), null != f && t.assert(4 === f.rank || 1 === f.rank, () => "Error in batchNorm4D: offset must be rank 4 or rank 1 " + `but got rank ${f.rank}.`), (0, e.batchNorm)(i, b, k, f, l, s)
        }
        const u = (0, n.op)({
            batchNorm4d_: c
        });
        exports.batchNorm4d = u;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./batchnorm": "qqTf",
        "./operation": "JtaO"
    }],
    "qUV0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.broadcastTo = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = require("./clone"),
            n = require("./operation"),
            a = require("./reshape");

        function s(n, s) {
            let i = (0, o.convertToTensor)(n, "broadcastTo", "x");
            const c = i.shape;
            if (s.some(e => !(e > 0) || e % 1 != 0)) throw new Error(`broadcastTo(): Invalid broadcast shape [${s}].`);
            if (s.length < i.rank) throw new Error(`broadcastTo(): shape.length=${s.length} < input.rank=${i.rank}.`);
            if (s.length > i.rank) {
                const e = i.shape.slice();
                for (; e.length < s.length;) e.unshift(1);
                i = (0, a.reshape)(i, e)
            }
            const l = i.shape,
                h = Array.from(s);
            for (let e = s.length - 1; e >= 0; e--)
                if (l[e] === s[e]) h[e] = 1;
                else if (1 !== i.shape[e]) throw new Error(`broadcastTo(): [${c}] cannot be broadcast to [${s}].`);
            if (0 === h.map((e, r) => e > 1 ? r : -1).filter(e => e >= 0).length) return (0, t.clone)(i);
            const p = {
                    x: i
                },
                u = {
                    shape: s,
                    inputShape: l
                };
            return e.ENGINE.runKernelFunc(e => e.tile(i, h), p, null, r.BroadcastTo, u)
        }
        const i = (0, n.op)({
            broadcastTo_: s
        });
        exports.broadcastTo = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./clone": "F06q",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "WyiN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.buffer = o;
        var e = require("../tensor"),
            r = n(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function n(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var f = o ? Object.getOwnPropertyDescriptor(e, u) : null;
                    f && (f.get || f.set) ? Object.defineProperty(n, u, f) : n[u] = e[u]
                } return n.default = e, r && r.set(e, n), n
        }

        function o(t, n = "float32", o) {
            return n = n || "float32", r.assertNonNegativeIntegerDimensions(t), new e.TensorBuffer(t, n, o)
        }
    }, {
        "../tensor": "DTHt",
        "../util": "P6nv"
    }],
    "S70G": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ceil = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            i = require("./operation");

        function o(i) {
            const o = (0, n.convertToTensor)(i, "x", "ceil"),
                t = {
                    x: o
                };
            return e.ENGINE.runKernelFunc(e => e.ceil(o), t, null, r.Ceil)
        }
        const t = (0, i.op)({
            ceil_: o
        });
        exports.ceil = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "VfEE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.clipByValue = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            u = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(u, o, i) {
            const l = (0, t.convertToTensor)(u, "x", "clipByValue");
            n.assert(o <= i, () => `Error in clip: min (${o}) must be ` + `less than or equal to max (${i}).`);
            const c = {
                    x: l
                },
                a = {
                    clipValueMin: o,
                    clipValueMax: i
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.clip(l, o, i);
                return r([l]), t
            }, c, null, r.ClipByValue, a)
        }
        const c = (0, u.op)({
            clipByValue_: l
        });
        exports.clipByValue = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "J9se": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concat1d = void 0;
        var e = require("./concat"),
            o = require("./operation");

        function t(o) {
            return (0, e.concat)(o, 0)
        }
        const c = (0, o.op)({
            concat1d_: t
        });
        exports.concat1d = c;
    }, {
        "./concat": "dDdq",
        "./operation": "JtaO"
    }],
    "Y6Ad": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concat2d = void 0;
        var e = require("./concat"),
            o = require("./operation");

        function t(o, t) {
            return (0, e.concat)(o, t)
        }
        const c = (0, o.op)({
            concat2d_: t
        });
        exports.concat2d = c;
    }, {
        "./concat": "dDdq",
        "./operation": "JtaO"
    }],
    "NSM9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concat3d = void 0;
        var e = require("./concat"),
            o = require("./operation");

        function t(o, t) {
            return (0, e.concat)(o, t)
        }
        const c = (0, o.op)({
            concat3d_: t
        });
        exports.concat3d = c;
    }, {
        "./concat": "dDdq",
        "./operation": "JtaO"
    }],
    "Yjfb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.concat4d = void 0;
        var e = require("./concat"),
            o = require("./operation");

        function t(o, t) {
            return (0, e.concat)(o, t)
        }
        const c = (0, o.op)({
            concat4d_: t
        });
        exports.concat4d = c;
    }, {
        "./concat": "dDdq",
        "./operation": "JtaO"
    }],
    "n3wz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv1d = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./conv2d"),
            n = i(require("./conv_util")),
            o = require("./operation"),
            s = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, o, s) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(o, a, i, p, u = "NWC", c = 1, d) {
            const h = (0, e.convertToTensor)(o, "x", "conv1d"),
                l = (0, e.convertToTensor)(a, "filter", "conv1d");
            let f = h,
                v = !1;
            2 === h.rank && (v = !0, f = (0, s.reshape)(h, [1, h.shape[0], h.shape[1]])), r.assert(3 === f.rank, () => `Error in conv1d: input must be rank 3, but got rank ${f.rank}.`), r.assert(3 === l.rank, () => "Error in conv1d: filter must be rank 3, but got rank " + `${l.rank}.`), null != d && r.assert(r.isInt(p), () => "Error in conv1d: pad must be an integer when using, " + `dimRoundingMode ${d} but got pad ${p}.`), r.assert(f.shape[2] === l.shape[1], () => `Error in conv1d: depth of input (${f.shape[2]}) must match ` + `input depth for filter ${l.shape[1]}.`), r.assert(n.eitherStridesOrDilationsAreOne(i, c), () => "Error in conv1D: Either stride or dilation must be 1. " + `Got stride ${i} and dilation '${c}'`), r.assert("NWC" === u, () => `Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`);
            const b = (0, s.reshape)(l, [1, l.shape[0], l.shape[1], l.shape[2]]),
                y = (0, s.reshape)(f, [f.shape[0], 1, f.shape[1], f.shape[2]]),
                g = [1, i],
                k = [1, c],
                O = (0, t.conv2d)(y, b, g, p, "NHWC", k, d);
            return v ? (0, s.reshape)(O, [O.shape[2], O.shape[3]]) : (0, s.reshape)(O, [O.shape[0], O.shape[2], O.shape[3]])
        }
        const u = (0, o.op)({
            conv1d_: p
        });
        exports.conv1d = u;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv2d": "oJQk",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "GCOF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2dTranspose = void 0;
        var o = require("../tensor_util_env"),
            e = require("./conv2d_backprop_input"),
            r = require("./operation");

        function n(r, n, s, t, p, c) {
            const v = (0, o.convertToTensor)(r, "x", "conv2dTranspose"),
                i = (0, o.convertToTensor)(n, "filter", "conv2dTranspose");
            return (0, e.conv2DBackpropInput)(s, v, i, t, p, "NHWC", c)
        }
        const s = (0, r.op)({
            conv2dTranspose_: n
        });
        exports.conv2dTranspose = s;
    }, {
        "../tensor_util_env": "c6yR",
        "./conv2d_backprop_input": "GLx7",
        "./operation": "JtaO"
    }],
    "VJ2T": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv3d = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            o = u(require("./conv_util")),
            s = require("./operation"),
            a = require("./reshape");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = i();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, o, s) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(s, i, u, p, c = "NDHWC", d = [1, 1, 1]) {
            const l = (0, t.convertToTensor)(s, "x", "conv3d"),
                f = (0, t.convertToTensor)(i, "filter", "conv3d");
            let v = l,
                h = !1;
            4 === l.rank && (h = !0, v = (0, a.reshape)(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]])), n.assert(5 === v.rank, () => `Error in conv3d: input must be rank 5, but got rank ${v.rank}.`), n.assert(5 === f.rank, () => "Error in conv3d: filter must be rank 5, but got rank " + `${f.rank}.`), n.assert(v.shape[4] === f.shape[3], () => `Error in conv3d: depth of input (${v.shape[4]}) must match ` + `input depth for filter ${f.shape[3]}.`), n.assert((0, o.eitherStridesOrDilationsAreOne)(u, d), () => "Error in conv3D: Either strides or dilations must be 1. " + `Got strides ${u} and dilations '${d}'`), n.assert("NDHWC" === c, () => `Error in conv3d: got dataFormat of ${c} but only NDHWC is currently supported.`);
            const b = {
                    x: v,
                    filter: f
                },
                k = {
                    strides: u,
                    pad: p,
                    dataFormat: c,
                    dilations: d
                },
                y = e.ENGINE.runKernelFunc((e, r) => {
                    const t = o.computeConv3DInfo(v.shape, f.shape, u, d, p),
                        n = e.conv3d(v, f, t);
                    return r([v, f]), n
                }, b, null, r.Conv3D, k);
            return h ? y.as4D(y.shape[1], y.shape[2], y.shape[3], y.shape[4]) : y
        }
        const c = (0, s.op)({
            conv3d_: p
        });
        exports.conv3d = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "fQzO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv3dTranspose = void 0;
        var o = require("../tensor_util_env"),
            e = require("./conv3d_backprop_input"),
            r = require("./operation");

        function n(r, n, s, t, p) {
            const c = (0, o.convertToTensor)(r, "x", "conv3dTranspose"),
                v = (0, o.convertToTensor)(n, "filter", "conv3dTranspose");
            return (0, e.conv3DBackpropInput)(s, c, v, t, p)
        }
        const s = (0, r.op)({
            conv3dTranspose_: n
        });
        exports.conv3dTranspose = s;
    }, {
        "../tensor_util_env": "c6yR",
        "./conv3d_backprop_input": "bEFz",
        "./operation": "JtaO"
    }],
    "U4UL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthToSpace = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = i(require("../util")),
            o = require("./operation");

        function p() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return p = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = p();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, o, i) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function a(o, p, i = "NHWC") {
            const a = (0, r.convertToTensor)(o, "x", "depthToSpace"),
                s = "NHWC" === i ? a.shape[1] : a.shape[2],
                u = "NHWC" === i ? a.shape[2] : a.shape[3],
                c = "NHWC" === i ? a.shape[3] : a.shape[1];
            n.assert(s * p >= 0, () => `Negative dimension size caused by overflow when multiplying\n    ${s} and ${p}  for depthToSpace with input shape\n    ${a.shape}`), n.assert(u * p >= 0, () => `Negative dimension size caused by overflow when multiplying\n    ${u} and ${p} for depthToSpace with input shape\n        ${a.shape}`), n.assert(c % (p * p) == 0, () => `Dimension size must be evenly divisible by ${p*p} but is ${c} for depthToSpace with input shape ${a.shape}`);
            const h = {
                    x: a
                },
                l = {
                    blockSize: p,
                    dataFormat: i
                };
            return e.ENGINE.runKernelFunc(e => e.depthToSpace(a, p, i), h, null, t.DepthToSpace, l)
        }
        const s = (0, o.op)({
            depthToSpace_: a
        });
        exports.depthToSpace = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "Kahd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthwiseConv2d = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            i = u(require("./conv_util")),
            s = require("./operation"),
            o = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, i, s) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function p(s, a, u, p, d = "NHWC", h = [1, 1], l) {
            const c = (0, t.convertToTensor)(s, "x", "depthwiseConv2d"),
                f = (0, t.convertToTensor)(a, "filter", "depthwiseConv2d");
            let v = c,
                w = !1;
            3 === c.rank && (w = !0, v = (0, o.reshape)(c, [1, c.shape[0], c.shape[1], c.shape[2]])), n.assert(4 === v.rank, () => "Error in depthwiseConv2d: input must be rank 4, but got " + `rank ${v.rank}.`), n.assert(4 === f.rank, () => "Error in depthwiseConv2d: filter must be rank 4, but got rank " + `${f.rank}.`), n.assert(v.shape[3] === f.shape[2], () => "Error in depthwiseConv2d: number of input channels " + `(${v.shape[3]}) must match the inChannels dimension in ` + `filter ${f.shape[2]}.`), null != l && n.assert(n.isInt(p), () => "Error in depthwiseConv2d: pad must be an integer when using, " + `dimRoundingMode ${l} but got pad ${p}.`);
            const b = {
                    x: v,
                    filter: f
                },
                C = {
                    strides: u,
                    pad: p,
                    dataFormat: d,
                    dilations: h,
                    dimRoundingMode: l
                },
                m = e.ENGINE.runKernelFunc((e, r) => {
                    null == h && (h = [1, 1]), n.assert(i.eitherStridesOrDilationsAreOne(u, h), () => "Error in depthwiseConv2d: Either strides or dilations must be " + `1. Got strides ${u} and dilations '${h}'`);
                    const t = i.computeConv2DInfo(v.shape, f.shape, u, h, p, l, !0),
                        s = e.depthwiseConv2D(v, f, t);
                    return r([v, f]), s
                }, b, null, r.DepthwiseConv2dNative, C);
            return w ? (0, o.reshape)(m, [m.shape[1], m.shape[2], m.shape[3]]) : m
        }
        const d = (0, s.op)({
            depthwiseConv2d_: p
        });
        exports.depthwiseConv2d = d;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "B6ot": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.diag = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("./operation"),
            i = require("./reshape");

        function o(t) {
            const o = (0, n.convertToTensor)(t, "x", "diag").flatten(),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc(e => {
                const r = e.diag(o),
                    n = [...t.shape, ...t.shape];
                return (0, i.reshape)(r, n)
            }, s, null, r.Diag)
        }
        const s = (0, t.op)({
            diag_: o
        });
        exports.diag = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "q2Zv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.dilation2d = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = s(require("../util")),
            o = require("./operation"),
            i = require("./reshape");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(o, a, s, u, l = [1, 1], p = "NHWC") {
            const d = (0, t.convertToTensor)(o, "x", "dilation2d"),
                f = (0, t.convertToTensor)(a, "filter", "dilation2d");
            n.assert(3 === d.rank || 4 === d.rank, () => "Error in dilation2d: input must be rank 3 or 4, but got rank " + `${d.rank}.`), n.assert(3 === f.rank, () => "Error in dilation2d: filter must be rank 3, but got rank " + `${f.rank}.`), n.assert("NHWC" === p, () => "Error in dilation2d: Only NHWC is currently supported, " + `but got dataFormat of ${p}`);
            let c = d,
                k = !1;
            3 === d.rank && (c = (0, i.reshape)(d, [1, d.shape[0], d.shape[1], d.shape[2]]), k = !0);
            const b = {
                    x: c,
                    filter: f
                },
                y = {
                    strides: s,
                    pad: u,
                    dilations: l
                },
                h = e.ENGINE.runKernel(r.Dilation2D, b, y);
            return k ? (0, i.reshape)(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
        }
        const l = (0, o.op)({
            dilation2d_: u
        });
        exports.dilation2d = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "mdNH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.divNoNan = void 0;
        var e = require("../tensor_util"),
            r = require("../tensor_util_env"),
            o = require("./div"),
            i = require("./operation"),
            t = require("./where"),
            n = require("./zeros_like");

        function s(i, s) {
            let u = (0, r.convertToTensor)(i, "a", "div"),
                v = (0, r.convertToTensor)(s, "b", "div");
            [u, v] = (0, e.makeTypesMatch)(u, v);
            const a = (0, o.div)(u, v),
                d = (0, n.zerosLike)(a),
                c = v.equal(d);
            return (0, t.where)(c, d, a)
        }
        const u = (0, i.op)({
            divNoNan_: s
        });
        exports.divNoNan = u;
    }, {
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./div": "D8Fc",
        "./operation": "JtaO",
        "./where": "BsuI",
        "./zeros_like": "PDcB"
    }],
    "bUs4": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.dot = void 0;
        var e = require("../tensor_util_env"),
            r = s(require("../util")),
            t = require("./mat_mul"),
            n = require("./operation"),
            a = require("./reshape");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, a) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, a, s) : t[a] = e[a]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(n, o) {
            const s = (0, e.convertToTensor)(n, "t1", "dot"),
                u = (0, e.convertToTensor)(o, "t2", "dot");
            r.assert(!(1 !== s.rank && 2 !== s.rank || 1 !== u.rank && 2 !== u.rank), () => "Error in dot: inputs must all be rank 1 or 2, but got ranks " + `${s.rank} and ${u.rank}.`);
            const i = 1 === s.rank ? s.size : s.shape[1],
                p = 1 === u.rank ? u.size : u.shape[0];
            if (r.assert(i === p, () => "Error in dot: inner dimensions of inputs must match, but got " + `${i} and ${p}.`), 1 === s.rank && 1 === u.rank) {
                const e = (0, a.reshape)(s, [1, -1]),
                    r = (0, a.reshape)(u, [-1, 1]),
                    n = (0, t.matMul)(e, r);
                return (0, a.reshape)(n, [])
            }
            if (1 === s.rank && 2 === u.rank) {
                const e = (0, a.reshape)(s, [1, -1]),
                    r = (0, a.reshape)(u, [u.shape[0], u.shape[1]]),
                    n = (0, t.matMul)(e, r);
                return (0, a.reshape)(n, [n.size])
            }
            if (2 === s.rank && 1 === u.rank) {
                const e = (0, a.reshape)(u, [-1, 1]),
                    r = (0, t.matMul)(s, e);
                return (0, a.reshape)(r, [r.size])
            } {
                const e = (0, a.reshape)(u, [u.shape[0], u.shape[1]]);
                return (0, t.matMul)(s, e)
            }
        }
        const i = (0, n.op)({
            dot_: u
        });
        exports.dot = i;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./mat_mul": "mMWq",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "a7Il": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.elu = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            u = require("./operation");

        function o(u) {
            const o = (0, n.convertToTensor)(u, "x", "elu"),
                t = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.elu(o);
                return r([n]), n
            }, t, null, r.Elu)
        }
        const t = (0, u.op)({
            elu_: o
        });
        exports.elu = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "roFm": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.erf = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            o = require("./operation");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function f(o) {
            let u = (0, t.convertToTensor)(o, "x", "erf");
            n.assert("int32" === u.dtype || "float32" === u.dtype, () => "Input dtype must be `int32` or `float32`."), "int32" === u.dtype && (u = u.toFloat());
            const i = {
                x: u
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = e.erf(u);
                return r([u]), t
            }, i, null, r.Erf)
        }
        const p = (0, o.op)({
            erf_: f
        });
        exports.erf = p;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "ntzg": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.expm1 = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function t(o) {
            const t = (0, n.convertToTensor)(o, "x", "expm1"),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.expm1(t);
                return r([t]), n
            }, u, null, r.Expm1)
        }
        const u = (0, o.op)({
            expm1_: t
        });
        exports.expm1 = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "HzEj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.eye = void 0;
        var e = require("./buffer"),
            r = require("./expand_dims"),
            t = require("./operation"),
            n = require("./tile");

        function i(t, i, s, o = "float32") {
            null == i && (i = t);
            const u = (0, e.buffer)([t, i], o),
                l = t <= i ? t : i;
            for (let e = 0; e < l; ++e) u.set(1, e, e);
            const p = u.toTensor().as2D(t, i);
            if (null == s) return p;
            if (1 === s.length) return (0, n.tile)((0, r.expandDims)(p, 0), [s[0], 1, 1]);
            if (2 === s.length) return (0, n.tile)((0, r.expandDims)((0, r.expandDims)(p, 0), 0), [s[0], s[1], 1, 1]);
            if (3 === s.length) return (0, n.tile)((0, r.expandDims)((0, r.expandDims)((0, r.expandDims)(p, 0), 0), 0), [s[0], s[1], s[2], 1, 1]);
            throw new Error("eye() currently supports only 1D and 2D " + `batchShapes, but received ${s.length}D.`)
        }
        const s = (0, t.op)({
            eye_: i
        });
        exports.eye = s;
    }, {
        "./buffer": "WyiN",
        "./expand_dims": "XF6l",
        "./operation": "JtaO",
        "./tile": "mfii"
    }],
    "lSPP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fft = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../ops/operation"),
            s = require("../util");

        function n(r) {
            (0, s.assert)("complex64" === r.dtype, () => "The dtype for tf.spectral.fft() must be complex64 " + `but got ${r.dtype}.`);
            const n = {
                input: r
            };
            return e.ENGINE.runKernelFunc(e => {
                const t = r.shape[r.shape.length - 1],
                    s = r.size / t,
                    n = r.as2D(s, t);
                return e.fft(n).reshape(r.shape)
            }, n, null, t.FFT)
        }
        const o = (0, r.op)({
            fft_: n
        });
        exports.fft = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../ops/operation": "JtaO",
        "../util": "P6nv"
    }],
    "e6pp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fill = l;
        var e = require("../engine"),
            r = require("../kernel_names");

        function l(l, n, u) {
            const t = {
                shape: l,
                value: n,
                dtype: u
            };
            return e.ENGINE.runKernelFunc(e => e.fill(l, n, u), {}, null, r.Fill, t)
        }
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "fGYa": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ifft = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../ops/operation"),
            s = require("../util");

        function n(r) {
            (0, s.assert)("complex64" === r.dtype, () => "The dtype for tf.spectral.ifft() must be complex64 " + `but got ${r.dtype}.`);
            const n = {
                input: r
            };
            return e.ENGINE.runKernelFunc(e => {
                const t = r.shape[r.shape.length - 1],
                    s = r.size / t,
                    n = r.as2D(s, t);
                return e.ifft(n).reshape(r.shape)
            }, n, null, t.IFFT)
        }
        const i = (0, r.op)({
            ifft_: n
        });
        exports.ifft = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../ops/operation": "JtaO",
        "../util": "P6nv"
    }],
    "C5d3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.imag = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            i = require("./operation");

        function t(i) {
            const t = (0, n.convertToTensor)(i, "input", "imag"),
                o = {
                    input: t
                };
            return e.ENGINE.runKernelFunc(e => e.imag(t), o, null, r.Imag)
        }
        const o = (0, i.op)({
            imag_: t
        });
        exports.imag = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "cKEu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.real = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("./operation");

        function o(t) {
            const o = (0, n.convertToTensor)(t, "input", "real"),
                u = {
                    input: o
                };
            return e.ENGINE.runKernelFunc(e => e.real(o), u, null, r.Real)
        }
        const u = (0, t.op)({
            real_: o
        });
        exports.real = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "SM4c": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.irfft = void 0;
        var e = require("../ops/complex"),
            r = require("../ops/imag"),
            s = require("../ops/operation"),
            i = require("../ops/real"),
            a = require("./concat"),
            t = require("./ifft"),
            o = require("./mul"),
            p = require("./reshape"),
            c = require("./reverse"),
            u = require("./scalar"),
            l = require("./slice");

        function f(s) {
            const f = s.shape[s.shape.length - 1],
                n = s.size / f;
            let h;
            if (f <= 2) {
                const e = (0, p.reshape)(s, [n, f]);
                h = (0, t.ifft)(e)
            } else {
                const q = [n, 2 * (f - 1)],
                    m = (0, p.reshape)((0, i.real)(s), [n, f]),
                    v = (0, p.reshape)((0, r.imag)(s), [n, f]),
                    x = (0, c.reverse)((0, l.slice)(m, [0, 1], [n, f - 2]), 1),
                    d = (0, o.mul)((0, c.reverse)((0, l.slice)(v, [0, 1], [n, f - 2]), 1), (0, u.scalar)(-1)),
                    g = (0, a.concat)([m, x], 1),
                    _ = (0, a.concat)([v, d], 1),
                    b = (0, p.reshape)((0, e.complex)(g, _), [q[0], q[1]]);
                h = (0, t.ifft)(b)
            }
            if (h = (0, i.real)(h), 3 === s.rank && 0 !== s.shape[0]) {
                const e = h,
                    r = s.shape[0];
                h = (0, p.reshape)(h, [r, h.shape[0] / r, h.shape[1]]), e.dispose()
            }
            return h
        }
        const n = (0, s.op)({
            irfft_: f
        });
        exports.irfft = n;
    }, {
        "../ops/complex": "Iowv",
        "../ops/imag": "C5d3",
        "../ops/operation": "JtaO",
        "../ops/real": "cKEu",
        "./concat": "dDdq",
        "./ifft": "fGYa",
        "./mul": "k2PI",
        "./reshape": "QI4k",
        "./reverse": "SxGN",
        "./scalar": "Ay42",
        "./slice": "zP07"
    }],
    "JMGA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isFinite = void 0;
        var e = require("../engine"),
            i = require("../kernel_names"),
            n = require("../tensor_util_env"),
            r = require("./operation");

        function t(r) {
            const t = (0, n.convertToTensor)(r, "x", "isFinite"),
                s = {
                    x: t
                };
            return e.ENGINE.runKernelFunc(e => e.isFinite(t), s, null, i.IsFinite)
        }
        const s = (0, r.op)({
            isFinite_: t
        });
        exports.isFinite = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "PwB1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isInf = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            s = require("./operation");

        function i(s) {
            const i = (0, r.convertToTensor)(s, "x", "isInf"),
                o = {
                    x: i
                };
            return e.ENGINE.runKernelFunc(e => e.isInf(i), o, null, n.IsInf)
        }
        const o = (0, s.op)({
            isInf_: i
        });
        exports.isInf = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "LVjE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.isNaN = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            s = require("./operation");

        function i(s) {
            const i = (0, n.convertToTensor)(s, "x", "isNaN"),
                o = {
                    x: i
                };
            return e.ENGINE.runKernelFunc(e => e.isNaN(i), o, null, r.IsNan)
        }
        const o = (0, s.op)({
            isNaN_: i
        });
        exports.isNaN = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "hUKE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.leakyRelu = void 0;
        var e = require("../tensor_util_env"),
            r = require("./maximum"),
            u = require("./mul"),
            o = require("./operation"),
            l = require("./scalar");

        function t(o, t = .2) {
            const a = (0, e.convertToTensor)(o, "x", "leakyRelu");
            return (0, r.maximum)((0, u.mul)((0, l.scalar)(t), a), a)
        }
        const a = (0, o.op)({
            leakyRelu_: t
        });
        exports.leakyRelu = a;
    }, {
        "../tensor_util_env": "c6yR",
        "./maximum": "X5MV",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./scalar": "Ay42"
    }],
    "encs": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.linspace = n;
        var e = require("../engine"),
            r = require("../kernel_names");

        function n(n, s, t) {
            if (t <= 0) throw new Error("The number of values should be positive.");
            const u = {
                start: n,
                stop: s,
                num: t
            };
            return e.ENGINE.runKernelFunc(e => e.linspace(n, s, t), {}, null, r.LinSpace, u)
        }
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe"
    }],
    "wFSX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.localResponseNormalization = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            o = require("./operation"),
            a = require("./reshape");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(o, s = 5, i = 1, l = 1, u = .5) {
            const p = (0, t.convertToTensor)(o, "x", "localResponseNormalization");
            n.assert(4 === p.rank || 3 === p.rank, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${p.rank}.`), n.assert(n.isInt(s), () => "Error in localResponseNormalization: depthRadius must be an " + `integer but got depthRadius ${s}.`);
            let c = p,
                f = !1;
            3 === p.rank && (f = !0, c = (0, a.reshape)(p, [1, p.shape[0], p.shape[1], p.shape[2]]));
            const d = {
                    x: c
                },
                h = {
                    depthRadius: s,
                    bias: i,
                    alpha: l,
                    beta: u
                },
                b = e.ENGINE.runKernelFunc((e, r) => {
                    const t = e.localResponseNormalization4D(c, s, i, l, u);
                    return r([c, t]), t
                }, d, null, r.LRN, h);
            return f ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b
        }
        const u = (0, o.op)({
            localResponseNormalization_: l
        });
        exports.localResponseNormalization = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "PxfL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.log1p = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function t(n) {
            const t = (0, o.convertToTensor)(n, "x", "log1p"),
                u = {
                    x: t
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.log1p(t);
                return r([t]), o
            }, u, null, r.Log1p)
        }
        const u = (0, n.op)({
            log1p_: t
        });
        exports.log1p = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "yPDw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.customGrad = f, exports.variableGrads = d, exports.valueAndGrad = i, exports.valueAndGrads = l, exports.grad = o, exports.grads = u;
        var e = require("./engine"),
            r = require("./tensor"),
            a = require("./tensor_util_env"),
            s = n(require("./util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function n(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var a = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var o = s ? Object.getOwnPropertyDescriptor(e, n) : null;
                    o && (o.get || o.set) ? Object.defineProperty(a, n, o) : a[n] = e[n]
                } return a.default = e, r && r.set(e, a), a
        }

        function o(r) {
            return s.assert(s.isFunction(r), () => "The f passed in grad(f) must be a function"), (t, n) => {
                const o = (0, a.convertToTensor)(t, "x", "tf.grad", null),
                    u = null != n ? (0, a.convertToTensor)(n, "dy", "tf.grad") : null;
                return e.ENGINE.tidy(() => {
                    const {
                        value: a,
                        grads: t
                    } = e.ENGINE.gradients(() => r(o), [o], u);
                    return null != u && s.assertShapesMatch(a.shape, u.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), c(t), t[0]
                })
            }
        }

        function u(r) {
            return s.assert(s.isFunction(r), () => "The f passed in grads(f) must be a function"), (t, n) => {
                s.assert(Array.isArray(t), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
                const o = (0, a.convertToTensorArray)(t, "args", "tf.grads", null),
                    u = null != n ? (0, a.convertToTensor)(n, "dy", "tf.grads") : null;
                return e.ENGINE.tidy(() => {
                    const {
                        value: a,
                        grads: t
                    } = e.ENGINE.gradients(() => r(...o), o, u);
                    return null != u && s.assertShapesMatch(a.shape, u.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), c(t), t
                })
            }
        }

        function i(a) {
            return s.assert(s.isFunction(a), () => "The f passed in valueAndGrad(f) must be a function"), (t, n) => {
                s.assert(t instanceof r.Tensor, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), s.assert(null == n || n instanceof r.Tensor, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
                const {
                    grads: o,
                    value: u
                } = e.ENGINE.gradients(() => a(t), [t], n);
                return c(o), {
                    grad: o[0],
                    value: u
                }
            }
        }

        function l(a) {
            return s.assert(s.isFunction(a), () => "The f passed in valueAndGrads(f) must be a function"), (t, n) => {
                s.assert(Array.isArray(t) && t.every(e => e instanceof r.Tensor), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), s.assert(null == n || n instanceof r.Tensor, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
                const o = e.ENGINE.gradients(() => a(...t), t, n);
                return null != n && s.assertShapesMatch(o.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), c(o.grads), o
            }
        }

        function d(a, t) {
            s.assert(s.isFunction(a), () => "The f passed in variableGrads(f) must be a function"), s.assert(null == t || Array.isArray(t) && t.every(e => e instanceof r.Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
            const n = null != t;
            if (!n) {
                t = [];
                for (const r in e.ENGINE.registeredVariables) t.push(e.ENGINE.registeredVariables[r])
            }
            const o = n ? t.filter(e => !e.trainable) : null,
                u = t.length;
            t = t.filter(e => e.trainable), s.assert(t.length > 0, () => "variableGrads() expects at least one of the input variables to " + `be trainable, but none of the ${u} variables is ` + "trainable.");
            const {
                value: i,
                grads: l
            } = e.ENGINE.gradients(a, t, null, !0);
            s.assert(l.some(e => null != e), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), s.assert(0 === i.rank, () => "The f passed in variableGrads(f) must return a scalar, but it " + `returned a rank-${i.rank} tensor`);
            const d = {};
            return t.forEach((e, r) => {
                null != l[r] && (d[e.name] = l[r])
            }), null != o && o.forEach(e => d[e.name] = null), {
                value: i,
                grads: d
            }
        }

        function f(r) {
            return e.ENGINE.customGrad(r)
        }

        function c(e) {
            if (e.filter(e => null == e).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
        }
    }, {
        "./engine": "Nc3Y",
        "./tensor": "DTHt",
        "./tensor_util_env": "c6yR",
        "./util": "P6nv"
    }],
    "lXsJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logSigmoid = void 0;
        var e = require("../gradients"),
            r = require("../tensor_util_env"),
            o = require("./mul"),
            i = require("./neg"),
            t = require("./operation"),
            u = require("./sigmoid");

        function n(t) {
            const n = (0, r.convertToTensor)(t, "x", "logSigmoid");
            return (0, e.customGrad)(e => {
                return {
                    value: (0, i.neg)((0, i.neg)(e).softplus()),
                    gradFunc: r => {
                        return (0, o.mul)(r, (0, u.sigmoid)((0, i.neg)(e)))
                    }
                }
            })(n)
        }
        const g = (0, t.op)({
            logSigmoid_: n
        });
        exports.logSigmoid = g;
    }, {
        "../gradients": "yPDw",
        "../tensor_util_env": "c6yR",
        "./mul": "k2PI",
        "./neg": "iGYA",
        "./operation": "JtaO",
        "./sigmoid": "yARQ"
    }],
    "iipD": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.max = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = p(require("../util")),
            o = p(require("./axis_util")),
            s = require("./operation"),
            a = require("./reshape"),
            i = require("./transpose");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(t, o, s) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(s, u = null, p = !1) {
            const l = (0, t.convertToTensor)(s, "x", "max"),
                c = {
                    x: l
                },
                f = {
                    reductionIndices: u,
                    keepDims: p
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                let t = n.parseAxisParam(u, l.shape);
                const s = o.getAxesPermutation(t, l.rank);
                let c = l;
                null != s && (c = (0, i.transpose)(l, s), t = o.getInnerMostAxes(t.length, c.rank));
                const f = e.max(c, t);
                null != s && c.dispose();
                let x = f;
                if (p) {
                    const e = o.expandShapeToKeepDim(x.shape, n.parseAxisParam(u, l.shape));
                    x = (0, a.reshape)(x, e), f.dispose()
                }
                return r([l, x]), x
            }, c, null, r.Max, f)
        }
        const c = (0, s.op)({
            max_: l
        });
        exports.max = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./transpose": "uQkx"
    }],
    "I1du": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logSoftmax = void 0;
        var o = require("../engine"),
            e = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./max"),
            n = require("./operation"),
            s = require("./sub");

        function a(n, a = -1) {
            const i = (0, r.convertToTensor)(n, "logits", "logSoftmax");
            if (-1 === a && (a = i.rank - 1), a !== i.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. " + `Logits was rank ${i.rank} and axis was ${a}`);
            const u = {
                    logits: i
                },
                l = {
                    axis: a
                };
            return o.ENGINE.runKernelFunc((o, e) => {
                const r = (0, t.max)(n, a, !0),
                    i = (0, s.sub)(n, r),
                    u = i.toFloat().sub(i.exp().sum(a, !0).log());
                return e([u]), u
            }, u, null, e.LogSoftmax, l)
        }
        const i = (0, n.op)({
            logSoftmax_: a
        });
        exports.logSoftmax = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./max": "iipD",
        "./operation": "JtaO",
        "./sub": "dGex"
    }],
    "MQ55": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logSumExp = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            u = require("./add"),
            o = require("./axis_util"),
            s = require("./exp"),
            i = require("./log"),
            p = require("./max"),
            a = require("./operation"),
            t = require("./reshape"),
            n = require("./sub"),
            x = require("./sum");

        function l(a, l = null, q = !1) {
            const m = (0, e.convertToTensor)(a, "x", "logSumExp"),
                d = (0, r.parseAxisParam)(l, m.shape),
                c = (0, p.max)(m, d, !0),
                h = (0, n.sub)(m, c),
                g = (0, s.exp)(h),
                _ = (0, x.sum)(g, d),
                v = (0, i.log)(_),
                S = (0, u.add)((0, t.reshape)(c, v.shape), v);
            if (q) {
                const e = (0, o.expandShapeToKeepDim)(S.shape, d);
                return (0, t.reshape)(S, e)
            }
            return S
        }
        const q = (0, a.op)({
            logSumExp_: l
        });
        exports.logSumExp = q;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./axis_util": "DsMP",
        "./exp": "zsk9",
        "./log": "vwHA",
        "./max": "iipD",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./sub": "dGex",
        "./sum": "ITAy"
    }],
    "HD5h": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logicalOr = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            l = require("./broadcast_util"),
            n = require("./operation");

        function t(n, t) {
            const a = (0, o.convertToTensor)(n, "a", "logicalOr", "bool"),
                i = (0, o.convertToTensor)(t, "b", "logicalOr", "bool");
            (0, l.assertAndGetBroadcastShape)(a.shape, i.shape);
            const s = {
                a: a,
                b: i
            };
            return e.ENGINE.runKernelFunc(e => e.logicalOr(a, i), s, null, r.LogicalOr)
        }
        const a = (0, n.op)({
            logicalOr_: t
        });
        exports.logicalOr = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "FEKV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logicalXor = void 0;
        var o = require("../tensor_util_env"),
            r = require("./broadcast_util"),
            e = require("./logical_and"),
            l = require("./logical_not"),
            a = require("./logical_or"),
            i = require("./operation");

        function t(i, t) {
            const c = (0, o.convertToTensor)(i, "a", "logicalXor", "bool"),
                n = (0, o.convertToTensor)(t, "b", "logicalXor", "bool");
            return (0, r.assertAndGetBroadcastShape)(c.shape, n.shape), (0, e.logicalAnd)((0, a.logicalOr)(i, t), (0, l.logicalNot)((0, e.logicalAnd)(i, t)))
        }
        const c = (0, i.op)({
            logicalXor_: t
        });
        exports.logicalXor = c;
    }, {
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./logical_and": "lYzt",
        "./logical_not": "XZse",
        "./logical_or": "HD5h",
        "./operation": "JtaO"
    }],
    "hJeZ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPool = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = u(require("../util")),
            o = u(require("./conv_util")),
            i = require("./operation"),
            a = require("./reshape");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(i, s, u, l, p) {
            const c = (0, t.convertToTensor)(i, "x", "maxPool");
            let d = c,
                f = !1;
            3 === c.rank && (f = !0, d = (0, a.reshape)(c, [1, c.shape[0], c.shape[1], c.shape[2]])), n.assert(4 === d.rank, () => `Error in maxPool: input must be rank 4 but got rank ${d.rank}.`), n.assert(o.eitherStridesOrDilationsAreOne(u, 1), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${u} and dilations '1'`), null != p && n.assert(n.isInt(l), () => "Error in maxPool: pad must be an integer when using, " + `dimRoundingMode ${p} but got pad ${l}.`);
            const h = {
                    x: d
                },
                P = {
                    filterSize: s,
                    strides: u,
                    pad: l,
                    dimRoundingMode: p
                },
                m = e.ENGINE.runKernelFunc((e, r) => {
                    const t = o.computePool2DInfo(d.shape, s, u, 1, l, p);
                    let i;
                    return i = 1 === t.filterWidth && 1 === t.filterHeight && n.arraysEqual(t.inShape, t.outShape) ? d.clone() : e.maxPool(d, t), r([d, i]), i
                }, h, null, r.MaxPool, P);
            return f ? (0, a.reshape)(m, [m.shape[1], m.shape[2], m.shape[3]]) : m
        }
        const p = (0, i.op)({
            maxPool_: l
        });
        exports.maxPool = p;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "Cet1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPool3d = void 0;
        var e = require("../engine"),
            r = require("../globals"),
            t = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = l(require("../util")),
            a = l(require("./conv_util")),
            i = require("./operation"),
            s = require("./reshape");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function l(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = u();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, n, a) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }

        function d(i, u = [1, 1, 1], l, d, p, c = "NDHWC", f) {
            null == f ? f = [1, 1, 1] : (0, r.deprecationWarn)("dilations is deprecated, this field will be gone in v3.0.0.");
            const m = (0, o.convertToTensor)(i, "x", "maxPool3d");
            let h = m,
                P = !1;
            4 === m.rank && (P = !0, h = m.as5D(1, m.shape[0], m.shape[1], m.shape[2], m.shape[3])), n.assert(5 === h.rank, () => `Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`), n.assert("NDHWC" === c, () => "Error in maxPool3d: Only NDHWC is currently supported, " + `but got dataFormat of ${c}`), n.assert(a.eitherStridesOrDilationsAreOne(l, f), () => "Error in maxPool3d: Either strides or dilations must be 1. " + `Got strides ${l} and dilations '${f}'`), null != p && n.assert(n.isInt(d), () => "Error in maxPool3d: pad must be an integer when using, " + `dimRoundingMode ${p} but got pad ${d}.`);
            const x = {
                    x: h
                },
                b = {
                    filterSize: u,
                    strides: l,
                    pad: d,
                    dimRoundingMode: p,
                    dataFormat: c,
                    dilations: f
                },
                g = e.ENGINE.runKernelFunc((e, r) => {
                    null == f && (f = [1, 1, 1]);
                    const t = a.computePool3DInfo(h.shape, u, l, f, d, p, c),
                        o = e.maxPool3d(h, t);
                    return r([h, o]), o
                }, x, null, t.MaxPool3D, b);
            return P ? (0, s.reshape)(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g
        }
        const p = (0, i.op)({
            maxPool3d_: d
        });
        exports.maxPool3d = p;
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv_util": "Evju",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "gxl3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPoolWithArgmax = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            t = require("./operation");

        function i(t, i, n, x, a = !1) {
            const s = {
                    x: (0, o.convertToTensor)(t, "x", "maxPoolWithArgmax")
                },
                l = {
                    filterSize: i,
                    strides: n,
                    pad: x,
                    includeBatchInIndex: a
                },
                u = e.ENGINE.runKernel(r.MaxPoolWithArgmax, s, l);
            return {
                result: u[0],
                indexes: u[1]
            }
        }
        const n = (0, t.op)({
            maxPoolWithArgmax_: i
        });
        exports.maxPoolWithArgmax = n;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "jwZo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.mean = void 0;
        var e = require("../gradients"),
            r = require("../tensor_util_env"),
            s = require("../util"),
            u = require("./axis_util"),
            t = require("./cast"),
            a = require("./div"),
            i = require("./mul"),
            n = require("./ones"),
            o = require("./operation"),
            c = require("./reshape"),
            p = require("./scalar"),
            d = require("./sum");

        function l(o, l = null, m = !1) {
            const q = (0, r.convertToTensor)(o, "x", "mean"),
                h = (0, s.parseAxisParam)(l, q.shape),
                v = (0, u.computeOutAndReduceShapes)(q.shape, h)[1],
                x = (0, s.sizeFromShape)(v);
            return (0, e.customGrad)(e => {
                const r = (0, p.scalar)(x),
                    s = r.dtype === e.dtype ? e : (0, t.cast)(e, r.dtype),
                    u = (0, a.div)(s, r);
                return {
                    value: (0, d.sum)(u, l, m),
                    gradFunc: r => {
                        const s = e.shape.slice();
                        h.forEach(e => {
                            s[e] = 1
                        });
                        const u = (0, c.reshape)(r, s);
                        return (0, a.div)((0, i.mul)(u, (0, n.ones)(e.shape, "float32")), x)
                    }
                }
            })(q)
        }
        const m = (0, o.op)({
            mean_: l
        });
        exports.mean = m;
    }, {
        "../gradients": "yPDw",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./cast": "qqq3",
        "./div": "D8Fc",
        "./mul": "k2PI",
        "./ones": "POxQ",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./scalar": "Ay42",
        "./sum": "ITAy"
    }],
    "w9We": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.min = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = require("../util"),
            i = p(require("./axis_util")),
            o = require("./operation"),
            s = require("./reshape"),
            u = require("./transpose");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var o = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, i, o) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(o, a = null, p = !1) {
            const l = (0, t.convertToTensor)(o, "x", "min"),
                c = {
                    x: l
                },
                f = {
                    axis: a,
                    keepDims: p
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const t = (0, n.parseAxisParam)(a, l.shape);
                let o = t;
                const c = i.getAxesPermutation(o, l.rank);
                let f = l;
                null != c && (f = (0, u.transpose)(l, c), o = i.getInnerMostAxes(o.length, l.rank));
                const d = e.min(f, o);
                null != c && f.dispose();
                let x = d;
                if (p) {
                    const e = i.expandShapeToKeepDim(x.shape, t);
                    x = (0, s.reshape)(d, e), d.dispose()
                }
                return r([l, x]), x
            }, c, null, r.Min, f)
        }
        const c = (0, o.op)({
            min_: l
        });
        exports.min = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./transpose": "uQkx"
    }],
    "crIr": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.minimum = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            t = require("../tensor_util_env"),
            i = require("./broadcast_util"),
            u = require("./cast"),
            o = require("./operation");

        function s(o, s) {
            let m = (0, t.convertToTensor)(o, "a", "minimum"),
                a = (0, t.convertToTensor)(s, "b", "minimum");
            [m, a] = (0, n.makeTypesMatch)(m, a), "bool" === m.dtype && (m = (0, u.cast)(m, "int32"), a = (0, u.cast)(a, "int32")), (0, i.assertAndGetBroadcastShape)(m.shape, a.shape);
            const c = {
                a: m,
                b: a
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.minimum(m, a);
                return r([m, a]), n
            }, c, null, r.Minimum)
        }
        const m = (0, o.op)({
            minimum_: s
        });
        exports.minimum = m;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./cast": "qqq3",
        "./operation": "JtaO"
    }],
    "lYF1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.mod = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util"),
            n = require("../tensor_util_env"),
            t = require("./operation");

        function u(t, u) {
            let s = (0, n.convertToTensor)(t, "a", "mod"),
                i = (0, n.convertToTensor)(u, "b", "mod");
            [s, i] = (0, o.makeTypesMatch)(s, i);
            const c = {
                a: s,
                b: i
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.mod(s, i);
                return r([s, i]), o
            }, c, null, r.Mod)
        }
        const s = (0, t.op)({
            mod_: u
        });
        exports.mod = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "rBcz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.moments = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            s = require("./axis_util"),
            t = require("./cast"),
            a = require("./mean"),
            n = require("./operation"),
            o = require("./reshape"),
            u = require("./square"),
            i = require("./sub");

        function p(n, p = null, m = !1) {
            n = (0, e.convertToTensor)(n, "x", "moments");
            const q = (0, r.parseAxisParam)(p, n.shape),
                c = (0, a.mean)(n, q, m);
            let l = c.shape;
            m || (l = (0, s.expandShapeToKeepDim)(c.shape, q));
            const x = (0, u.square)((0, i.sub)((0, t.cast)(n, "float32"), (0, o.reshape)(c, l)));
            return {
                mean: c,
                variance: (0, a.mean)(x, q, m)
            }
        }
        const m = (0, n.op)({
            moments_: p
        });
        exports.moments = m;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./cast": "qqq3",
        "./mean": "jwZo",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./square": "mJRX",
        "./sub": "dGex"
    }],
    "V2Xb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.multiRNNCell = void 0;
        var e = require("../tensor_util_env"),
            t = require("./operation");

        function o(t, o, r, l) {
            const n = (0, e.convertToTensor)(o, "data", "multiRNNCell"),
                s = (0, e.convertToTensorArray)(r, "c", "multiRNNCell"),
                u = (0, e.convertToTensorArray)(l, "h", "multiRNNCell");
            let i = n;
            const c = [];
            for (let e = 0; e < t.length; e++) {
                const o = t[e](i, s[e], u[e]);
                c.push(o[0]), c.push(o[1]), i = o[1]
            }
            const N = [],
                p = [];
            for (let e = 0; e < c.length; e += 2) N.push(c[e]), p.push(c[e + 1]);
            return [N, p]
        }
        const r = (0, t.op)({
            multiRNNCell_: o
        });
        exports.multiRNNCell = r;
    }, {
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "GA9C": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.multinomial = void 0;
        var o = require("../engine"),
            e = require("../tensor_util_env"),
            r = require("./operation");

        function t(r, t, i, n = !1) {
            const u = (0, e.convertToTensor)(r, "logits", "multinomial"),
                s = u.size,
                l = u.rank;
            if (s < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + `${s}.`);
            if (l > 2) throw new Error(`Rank of probabilities must be 1 or 2, but is ${l}`);
            i = i || Math.random();
            const a = 1 === l ? u.as2D(1, -1) : u,
                m = o.ENGINE.runKernelFunc(o => o.multinomial(a, n, t, i), {
                    logits2D: a
                });
            return 1 === l ? m.as1D() : m
        }
        const i = (0, r.op)({
            multinomial_: t
        });
        exports.multinomial = i;
    }, {
        "../engine": "Nc3Y",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "jVu5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.notEqual = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util"),
            n = require("../tensor_util_env"),
            o = require("./broadcast_util"),
            u = require("./operation");

        function a(u, a) {
            let s = (0, n.convertToTensor)(u, "a", "notEqual"),
                l = (0, n.convertToTensor)(a, "b", "notEqual");
            [s, l] = (0, t.makeTypesMatch)(s, l), (0, o.assertAndGetBroadcastShape)(s.shape, l.shape);
            const i = {
                a: s,
                b: l
            };
            return e.ENGINE.runKernelFunc(e => e.notEqual(s, l), i, null, r.NotEqual)
        }
        const s = (0, u.op)({
            notEqual_: a
        });
        exports.notEqual = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "VzlV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.onesLike = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./complex"),
            i = require("./imag"),
            s = require("./operation"),
            t = require("./real"),
            u = require("./zeros_like");

        function l(s) {
            const l = (0, n.convertToTensor)(s, "x", "onesLike"),
                p = {
                    x: l
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                if ("complex64" === l.dtype) {
                    const e = c((0, t.real)(l)),
                        r = (0, u.zerosLike)((0, i.imag)(l));
                    return (0, o.complex)(e, r)
                }
                return e.onesLike(l)
            }, p, null, r.OnesLike)
        }
        const c = (0, s.op)({
            onesLike_: l
        });
        exports.onesLike = c;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./complex": "Iowv",
        "./imag": "C5d3",
        "./operation": "JtaO",
        "./real": "cKEu",
        "./zeros_like": "PDcB"
    }],
    "lKlD": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.outerProduct = void 0;
        var r = require("../tensor_util_env"),
            e = a(require("../util")),
            t = require("./mat_mul"),
            o = require("./operation"),
            n = require("./reshape");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return u = function() {
                return r
            }, r
        }

        function a(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var e = u();
            if (e && e.has(r)) return e.get(r);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in r)
                if (Object.prototype.hasOwnProperty.call(r, n)) {
                    var a = o ? Object.getOwnPropertyDescriptor(r, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, n, a) : t[n] = r[n]
                } return t.default = r, e && e.set(r, t), t
        }

        function i(o, u) {
            const a = (0, r.convertToTensor)(o, "v1", "outerProduct"),
                i = (0, r.convertToTensor)(u, "v2", "outerProduct");
            e.assert(1 === a.rank && 1 === i.rank, () => "Error in outerProduct: inputs must be rank 1, but got ranks " + `${a.rank} and ${i.rank}.`);
            const c = (0, n.reshape)(a, [-1, 1]),
                s = (0, n.reshape)(i, [1, -1]);
            return (0, t.matMul)(c, s)
        }
        const c = (0, o.op)({
            outerProduct_: i
        });
        exports.outerProduct = c;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./mat_mul": "mMWq",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "aLXo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pad1d = void 0;
        var e = require("../util"),
            r = require("./operation"),
            t = require("./pad");

        function d(r, d, o = 0) {
            return (0, e.assert)(2 === d.length, () => "Invalid number of paddings. Must be length of 2."), (0, t.pad)(r, [d], o)
        }
        const o = (0, r.op)({
            pad1d_: d
        });
        exports.pad1d = o;
    }, {
        "../util": "P6nv",
        "./operation": "JtaO",
        "./pad": "hajs"
    }],
    "OUX7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pad2d = void 0;
        var e = require("../util"),
            r = require("./operation"),
            t = require("./pad");

        function d(r, d, n = 0) {
            return (0, e.assert)(2 === d.length && 2 === d[0].length && 2 === d[1].length, () => "Invalid number of paddings. Must be length of 2 each."), (0, t.pad)(r, d, n)
        }
        const n = (0, r.op)({
            pad2d_: d
        });
        exports.pad2d = n;
    }, {
        "../util": "P6nv",
        "./operation": "JtaO",
        "./pad": "hajs"
    }],
    "Exwp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pad3d = void 0;
        var e = require("../util"),
            t = require("./operation"),
            r = require("./pad");

        function d(t, d, n = 0) {
            return (0, e.assert)(3 === d.length && 2 === d[0].length && 2 === d[1].length && 2 === d[2].length, () => "Invalid number of paddings. Must be length of 2 each."), (0, r.pad)(t, d, n)
        }
        const n = (0, t.op)({
            pad3d_: d
        });
        exports.pad3d = n;
    }, {
        "../util": "P6nv",
        "./operation": "JtaO",
        "./pad": "hajs"
    }],
    "HxGt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pad4d = void 0;
        var e = require("../util"),
            t = require("./operation"),
            r = require("./pad");

        function n(t, n, d = 0) {
            return (0, e.assert)(4 === n.length && 2 === n[0].length && 2 === n[1].length && 2 === n[2].length && 2 === n[3].length, () => "Invalid number of paddings. Must be length of 2 each."), (0, r.pad)(t, n, d)
        }
        const d = (0, t.op)({
            pad4d_: n
        });
        exports.pad4d = d;
    }, {
        "../util": "P6nv",
        "./operation": "JtaO",
        "./pad": "hajs"
    }],
    "T3We": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pool = void 0;
        var e = require("../tensor_util_env"),
            t = l(require("../util")),
            r = require("./avg_pool"),
            o = require("./batch_to_space_nd"),
            n = l(require("./conv_util")),
            a = require("./max_pool"),
            i = require("./operation"),
            p = require("./reshape"),
            s = require("./space_to_batch_nd");

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function l(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = u();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n]
                } return r.default = e, t && t.set(e, r), r
        }

        function c(i, u, l, c, d, m) {
            null == d && (d = [1, 1]), null == m && (m = 1), 0 === c && (c = "valid");
            const v = (0, e.convertToTensor)(i, "x", "maxPool");
            let _ = v,
                b = !1;
            3 === v.rank && (b = !0, _ = (0, p.reshape)(v, [1, v.shape[0], v.shape[1], v.shape[2]])), t.assert(n.eitherStridesOrDilationsAreOne(m, d), () => "Error in pool: Either strides or dilations must be 1. " + `Got strides ${m} and dilations '${d}'`);
            const O = n.computePool2DInfo(_.shape, u, m, d, c),
                g = [O.dilationHeight, O.dilationWidth];
            let y;
            y = "same" === c ? h([O.filterHeight, O.filterWidth], g) : [
                [0, 0],
                [0, 0]
            ];
            const P = 1 === g[0] && 1 === g[1],
                [q, j] = f([O.inHeight, O.inWidth], g, y),
                x = P ? c : "valid",
                D = P ? _ : (0, s.spaceToBatchND)(_, g, q),
                M = ("avg" === l ? () => (0, r.avgPool)(D, u, m, x) : () => (0, a.maxPool)(D, u, m, x))(),
                W = P ? M : (0, o.batchToSpaceND)(M, g, j);
            return b ? (0, p.reshape)(W, [W.shape[1], W.shape[2], W.shape[3]]) : W
        }

        function f(e, t, r) {
            const o = r.map(e => e[0]),
                n = r.map(e => e[1]),
                a = e.concat(o, n),
                i = t.map((e, t) => (e - a[t] % e) % e),
                p = n.map((e, t) => e + i[t]);
            return [t.map((e, t) => [o[t], p[t]]), t.map((e, t) => [0, i[t]])]
        }

        function h(e, t) {
            const r = e.map((e, r) => e + (e - 1) * (t[r] - 1)).map(e => e - 1),
                o = r.map(e => Math.floor(e / 2)),
                n = r.map((e, t) => e - o[t]);
            return r.map((e, t) => [o[t], n[t]])
        }
        const d = (0, i.op)({
            pool_: c
        });
        exports.pool = d;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./avg_pool": "iP9e",
        "./batch_to_space_nd": "Q9gF",
        "./conv_util": "Evju",
        "./max_pool": "hJeZ",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./space_to_batch_nd": "rWul"
    }],
    "mkuj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.prelu = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            u = require("./operation");

        function o(u, o) {
            const t = (0, n.convertToTensor)(u, "x", "prelu"),
                l = (0, n.convertToTensor)(o, "alpha", "prelu"),
                p = {
                    x: t,
                    alpha: l
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.prelu(t, l);
                return r([t, l]), n
            }, p, null, r.Prelu)
        }
        const t = (0, u.op)({
            prelu_: o
        });
        exports.prelu = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "xBTU": [function(require, module, exports) {
        "use strict";

        function e(e, t = !1) {
            console.log(e.toString(t))
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.print = e;
    }, {}],
    "pvB6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.prod = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("../util"),
            o = require("./axis_util"),
            s = require("./operation");

        function i(s, i = null, p = !1) {
            let u = (0, n.convertToTensor)(s, "x", "prod");
            const a = {
                    x: u
                },
                l = {
                    axis: i,
                    keepDims: p
                };
            return e.ENGINE.runKernelFunc(e => {
                "bool" === u.dtype && (u = u.toInt());
                const r = (0, t.parseAxisParam)(i, u.shape),
                    n = (0, o.getAxesPermutation)(r, u.rank);
                let s = r,
                    a = u;
                null != n && (a = u.transpose(n), s = (0, o.getInnerMostAxes)(s.length, u.rank));
                let l = e.prod(a, s);
                if (p) {
                    const e = (0, o.expandShapeToKeepDim)(l.shape, r);
                    l = l.reshape(e)
                }
                return l
            }, a, null, r.Prod, l)
        }
        const p = (0, s.op)({
            prod_: i
        });
        exports.prod = p;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./axis_util": "DsMP",
        "./operation": "JtaO"
    }],
    "WpBM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rand = void 0;
        var e = require("../engine"),
            r = require("../util"),
            n = require("./operation");

        function t(n, t, o) {
            const i = (0, r.sizeFromShape)(n);
            let a = null;
            if (null == o || "float32" === o) a = new Float32Array(i);
            else if ("int32" === o) a = new Int32Array(i);
            else {
                if ("bool" !== o) throw new Error(`Unknown data type ${o}`);
                a = new Uint8Array(i)
            }
            for (let e = 0; e < i; e++) a[e] = t();
            return e.ENGINE.makeTensor(a, n, o)
        }
        const o = (0, n.op)({
            rand_: t
        });
        exports.rand = o;
    }, {
        "../engine": "Nc3Y",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "uCqK": [function(require, module, exports) {
        var define;
        var t;
        ! function(t, n, e) {
            function s(t) {
                var n, e = this,
                    s = (n = 4022871197, function(t) {
                        t = t.toString();
                        for (var e = 0; e < t.length; e++) {
                            var s = .02519603282416938 * (n += t.charCodeAt(e));
                            s -= n = s >>> 0, n = (s *= n) >>> 0, n += 4294967296 * (s -= n)
                        }
                        return 2.3283064365386963e-10 * (n >>> 0)
                    });
                e.next = function() {
                    var t = 2091639 * e.s0 + 2.3283064365386963e-10 * e.c;
                    return e.s0 = e.s1, e.s1 = e.s2, e.s2 = t - (e.c = 0 | t)
                }, e.c = 1, e.s0 = s(" "), e.s1 = s(" "), e.s2 = s(" "), e.s0 -= s(t), e.s0 < 0 && (e.s0 += 1), e.s1 -= s(t), e.s1 < 0 && (e.s1 += 1), e.s2 -= s(t), e.s2 < 0 && (e.s2 += 1), s = null
            }

            function r(t, n) {
                return n.c = t.c, n.s0 = t.s0, n.s1 = t.s1, n.s2 = t.s2, n
            }

            function o(t, n) {
                var e = new s(t),
                    o = n && n.state,
                    u = e.next;
                return u.int32 = function() {
                    return 4294967296 * e.next() | 0
                }, u.double = function() {
                    return u() + 1.1102230246251565e-16 * (2097152 * u() | 0)
                }, u.quick = u, o && ("object" == typeof o && r(o, e), u.state = function() {
                    return r(e, {})
                }), u
            }
            n && n.exports ? n.exports = o : e && e.amd ? e(function() {
                return o
            }) : this.alea = o
        }(0, "object" == typeof module && module, "function" == typeof t && t);
    }, {}],
    "w3Ll": [function(require, module, exports) {
        var define;
        var t;
        ! function(t, n, e) {
            function r(t) {
                var n = this,
                    e = "";
                n.x = 0, n.y = 0, n.z = 0, n.w = 0, n.next = function() {
                    var t = n.x ^ n.x << 11;
                    return n.x = n.y, n.y = n.z, n.z = n.w, n.w ^= n.w >>> 19 ^ t ^ t >>> 8
                }, t === (0 | t) ? n.x = t : e += t;
                for (var r = 0; r < e.length + 64; r++) n.x ^= 0 | e.charCodeAt(r), n.next()
            }

            function o(t, n) {
                return n.x = t.x, n.y = t.y, n.z = t.z, n.w = t.w, n
            }

            function u(t, n) {
                var e = new r(t),
                    u = n && n.state,
                    x = function() {
                        return (e.next() >>> 0) / 4294967296
                    };
                return x.double = function() {
                    do {
                        var t = ((e.next() >>> 11) + (e.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === t);
                    return t
                }, x.int32 = e.next, x.quick = x, u && ("object" == typeof u && o(u, e), x.state = function() {
                    return o(e, {})
                }), x
            }
            n && n.exports ? n.exports = u : e && e.amd ? e(function() {
                return u
            }) : this.xor128 = u
        }(0, "object" == typeof module && module, "function" == typeof t && t);
    }, {}],
    "OwKO": [function(require, module, exports) {
        var define;
        var t;
        ! function(t, n, e) {
            function o(t) {
                var n = this,
                    e = "";
                n.next = function() {
                    var t = n.x ^ n.x >>> 2;
                    return n.x = n.y, n.y = n.z, n.z = n.w, n.w = n.v, (n.d = n.d + 362437 | 0) + (n.v = n.v ^ n.v << 4 ^ t ^ t << 1) | 0
                }, n.x = 0, n.y = 0, n.z = 0, n.w = 0, n.v = 0, t === (0 | t) ? n.x = t : e += t;
                for (var o = 0; o < e.length + 64; o++) n.x ^= 0 | e.charCodeAt(o), o == e.length && (n.d = n.x << 10 ^ n.x >>> 4), n.next()
            }

            function r(t, n) {
                return n.x = t.x, n.y = t.y, n.z = t.z, n.w = t.w, n.v = t.v, n.d = t.d, n
            }

            function u(t, n) {
                var e = new o(t),
                    u = n && n.state,
                    x = function() {
                        return (e.next() >>> 0) / 4294967296
                    };
                return x.double = function() {
                    do {
                        var t = ((e.next() >>> 11) + (e.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === t);
                    return t
                }, x.int32 = e.next, x.quick = x, u && ("object" == typeof u && r(u, e), x.state = function() {
                    return r(e, {})
                }), x
            }
            n && n.exports ? n.exports = u : e && e.amd ? e(function() {
                return u
            }) : this.xorwow = u
        }(0, "object" == typeof module && module, "function" == typeof t && t);
    }, {}],
    "OrVu": [function(require, module, exports) {
        var define;
        var n;
        ! function(n, t, e) {
            function r(n) {
                var t = this;
                t.next = function() {
                        var n, e, r = t.x,
                            o = t.i;
                        return n = r[o], e = (n ^= n >>> 7) ^ n << 24, e ^= (n = r[o + 1 & 7]) ^ n >>> 10, e ^= (n = r[o + 3 & 7]) ^ n >>> 3, e ^= (n = r[o + 4 & 7]) ^ n << 7, n = r[o + 7 & 7], e ^= (n ^= n << 13) ^ n << 9, r[o] = e, t.i = o + 1 & 7, e
                    },
                    function(n, t) {
                        var e, r = [];
                        if (t === (0 | t)) r[0] = t;
                        else
                            for (t = "" + t, e = 0; e < t.length; ++e) r[7 & e] = r[7 & e] << 15 ^ t.charCodeAt(e) + r[e + 1 & 7] << 13;
                        for (; r.length < 8;) r.push(0);
                        for (e = 0; e < 8 && 0 === r[e]; ++e);
                        for (8 == e ? r[7] = -1 : r[e], n.x = r, n.i = 0, e = 256; e > 0; --e) n.next()
                    }(t, n)
            }

            function o(n, t) {
                return t.x = n.x.slice(), t.i = n.i, t
            }

            function i(n, t) {
                null == n && (n = +new Date);
                var e = new r(n),
                    i = t && t.state,
                    u = function() {
                        return (e.next() >>> 0) / 4294967296
                    };
                return u.double = function() {
                    do {
                        var n = ((e.next() >>> 11) + (e.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === n);
                    return n
                }, u.int32 = e.next, u.quick = u, i && (i.x && o(i, e), u.state = function() {
                    return o(e, {})
                }), u
            }
            t && t.exports ? t.exports = i : e && e.amd ? e(function() {
                return i
            }) : this.xorshift7 = i
        }(0, "object" == typeof module && module, "function" == typeof n && n);
    }, {}],
    "DrnH": [function(require, module, exports) {
        var define;
        var n;
        ! function(n, t, e) {
            function r(n) {
                var t = this;
                t.next = function() {
                        var n, e, r = t.w,
                            o = t.X,
                            u = t.i;
                        return t.w = r = r + 1640531527 | 0, e = o[u + 34 & 127], n = o[u = u + 1 & 127], e ^= e << 13, n ^= n << 17, e ^= e >>> 15, n ^= n >>> 12, e = o[u] = e ^ n, t.i = u, e + (r ^ r >>> 16) | 0
                    },
                    function(n, t) {
                        var e, r, o, u, i, c = [],
                            f = 128;
                        for (t === (0 | t) ? (r = t, t = null) : (t += "\0", r = 0, f = Math.max(f, t.length)), o = 0, u = -32; u < f; ++u) t && (r ^= t.charCodeAt((u + 32) % t.length)), 0 === u && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, u >= 0 && (i = i + 1640531527 | 0, o = 0 == (e = c[127 & u] ^= r + i) ? o + 1 : 0);
                        for (o >= 128 && (c[127 & (t && t.length || 0)] = -1), o = 127, u = 512; u > 0; --u) r = c[o + 34 & 127], e = c[o = o + 1 & 127], r ^= r << 13, e ^= e << 17, r ^= r >>> 15, e ^= e >>> 12, c[o] = r ^ e;
                        n.w = i, n.X = c, n.i = o
                    }(t, n)
            }

            function o(n, t) {
                return t.i = n.i, t.w = n.w, t.X = n.X.slice(), t
            }

            function u(n, t) {
                null == n && (n = +new Date);
                var e = new r(n),
                    u = t && t.state,
                    i = function() {
                        return (e.next() >>> 0) / 4294967296
                    };
                return i.double = function() {
                    do {
                        var n = ((e.next() >>> 11) + (e.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === n);
                    return n
                }, i.int32 = e.next, i.quick = i, u && (u.X && o(u, e), i.state = function() {
                    return o(e, {})
                }), i
            }
            t && t.exports ? t.exports = u : e && e.amd ? e(function() {
                return u
            }) : this.xor4096 = u
        }(0, "object" == typeof module && module, "function" == typeof n && n);
    }, {}],
    "yIlK": [function(require, module, exports) {
        var define;
        var t;
        ! function(t, n, e) {
            function o(t) {
                var n = this,
                    e = "";
                n.next = function() {
                    var t = n.b,
                        e = n.c,
                        o = n.d,
                        r = n.a;
                    return t = t << 25 ^ t >>> 7 ^ e, e = e - o | 0, o = o << 24 ^ o >>> 8 ^ r, r = r - t | 0, n.b = t = t << 20 ^ t >>> 12 ^ e, n.c = e = e - o | 0, n.d = o << 16 ^ e >>> 16 ^ r, n.a = r - t | 0
                }, n.a = 0, n.b = 0, n.c = -1640531527, n.d = 1367130551, t === Math.floor(t) ? (n.a = t / 4294967296 | 0, n.b = 0 | t) : e += t;
                for (var o = 0; o < e.length + 20; o++) n.b ^= 0 | e.charCodeAt(o), n.next()
            }

            function r(t, n) {
                return n.a = t.a, n.b = t.b, n.c = t.c, n.d = t.d, n
            }

            function u(t, n) {
                var e = new o(t),
                    u = n && n.state,
                    c = function() {
                        return (e.next() >>> 0) / 4294967296
                    };
                return c.double = function() {
                    do {
                        var t = ((e.next() >>> 11) + (e.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === t);
                    return t
                }, c.int32 = e.next, c.quick = c, u && ("object" == typeof u && r(u, e), c.state = function() {
                    return r(e, {})
                }), c
            }
            n && n.exports ? n.exports = u : e && e.amd ? e(function() {
                return u
            }) : this.tychei = u
        }(0, "object" == typeof module && module, "function" == typeof t && t);
    }, {}],
    "D1cN": [function(require, module, exports) {
        var global = arguments[3];
        var define;
        var r, n = arguments[3];
        ! function(n, t) {
            var e, o = this,
                u = 256,
                i = 6,
                a = "random",
                c = t.pow(u, i),
                f = t.pow(2, 52),
                s = 2 * f,
                l = u - 1;

            function p(r, l, p) {
                var m = [],
                    v = h(function r(n, t) {
                        var e, o = [],
                            u = typeof n;
                        if (t && "object" == u)
                            for (e in n) try {
                                o.push(r(n[e], t - 1))
                            } catch (i) {}
                        return o.length ? o : "string" == u ? n : n + "\0"
                    }((l = 1 == l ? {
                        entropy: !0
                    } : l || {}).entropy ? [r, d(n)] : null == r ? function() {
                        try {
                            var r;
                            return e && (r = e.randomBytes) ? r = r(u) : (r = new Uint8Array(u), (o.crypto || o.msCrypto).getRandomValues(r)), d(r)
                        } catch (a) {
                            var t = o.navigator,
                                i = t && t.plugins;
                            return [+new Date, o, i, o.screen, d(n)]
                        }
                    }() : r, 3), m),
                    j = new g(m),
                    S = function() {
                        for (var r = j.g(i), n = c, t = 0; r < f;) r = (r + t) * u, n *= u, t = j.g(1);
                        for (; r >= s;) r /= 2, n /= 2, t >>>= 1;
                        return (r + t) / n
                    };
                return S.int32 = function() {
                    return 0 | j.g(4)
                }, S.quick = function() {
                    return j.g(4) / 4294967296
                }, S.double = S, h(d(j.S), n), (l.pass || p || function(r, n, e, o) {
                    return o && (o.S && y(o, j), r.state = function() {
                        return y(j, {})
                    }), e ? (t[a] = r, n) : r
                })(S, v, "global" in l ? l.global : this == t, l.state)
            }

            function g(r) {
                var n, t = r.length,
                    e = this,
                    o = 0,
                    i = e.i = e.j = 0,
                    a = e.S = [];
                for (t || (r = [t++]); o < u;) a[o] = o++;
                for (o = 0; o < u; o++) a[o] = a[i = l & i + r[o % t] + (n = a[o])], a[i] = n;
                (e.g = function(r) {
                    for (var n, t = 0, o = e.i, i = e.j, a = e.S; r--;) n = a[o = l & o + 1], t = t * u + a[l & (a[o] = a[i = l & i + n]) + (a[i] = n)];
                    return e.i = o, e.j = i, t
                })(u)
            }

            function y(r, n) {
                return n.i = r.i, n.j = r.j, n.S = r.S.slice(), n
            }

            function h(r, n) {
                for (var t, e = r + "", o = 0; o < e.length;) n[l & o] = l & (t ^= 19 * n[l & o]) + e.charCodeAt(o++);
                return d(n)
            }

            function d(r) {
                return String.fromCharCode.apply(0, r)
            }
            if (t["seed" + a] = p, h(t.random(), n), "object" == typeof module && module.exports) {
                module.exports = p;
                try {
                    e = require("crypto")
                } catch (m) {}
            } else "function" == typeof r && r.amd && r(function() {
                return p
            })
        }([], Math);
    }, {
        "crypto": "sC8V"
    }],
    "Kwju": [function(require, module, exports) {
        var r = require("./lib/alea"),
            e = require("./lib/xor128"),
            i = require("./lib/xorwow"),
            o = require("./lib/xorshift7"),
            l = require("./lib/xor4096"),
            x = require("./lib/tychei"),
            u = require("./seedrandom");
        u.alea = r, u.xor128 = e, u.xorwow = i, u.xorshift7 = o, u.xor4096 = l, u.tychei = x, module.exports = u;
    }, {
        "./lib/alea": "uCqK",
        "./lib/xor128": "w3Ll",
        "./lib/xorwow": "OwKO",
        "./lib/xorshift7": "OrVu",
        "./lib/xor4096": "DrnH",
        "./lib/tychei": "yIlK",
        "./seedrandom": "D1cN"
    }],
    "jZqu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.jarqueBeraNormalityTest = i, exports.expectArrayInMeanStdRange = h, exports.UniformRandom = exports.RandGamma = exports.MPRandGauss = void 0;
        var t = r(require("seedrandom")),
            e = require("../test_util");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return n = function() {
                return t
            }, t
        }

        function r(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var e = n();
            if (e && e.has(t)) return e.get(t);
            var r = {},
                a = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in t)
                if (Object.prototype.hasOwnProperty.call(t, s)) {
                    var o = a ? Object.getOwnPropertyDescriptor(t, s) : null;
                    o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = t[s]
                } return r.default = t, e && e.set(t, r), r
        }
        class a {
            constructor(e, n, r, a, s) {
                this.mean = e, this.stdDev = n, this.dtype = r, this.nextVal = NaN, this.truncated = a, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
                const o = s || Math.random();
                this.random = t.alea(o.toString())
            }
            nextValue() {
                if (!isNaN(this.nextVal)) {
                    const t = this.nextVal;
                    return this.nextVal = NaN, t
                }
                let t, e, n = !1;
                for (; !n;) {
                    let r, a, s;
                    do {
                        s = (r = 2 * this.random() - 1) * r + (a = 2 * this.random() - 1) * a
                    } while (s >= 1 || 0 === s);
                    const o = Math.sqrt(-2 * Math.log(s) / s);
                    t = this.mean + this.stdDev * r * o, e = this.mean + this.stdDev * a * o, this.truncated && !this.isValidTruncated(t) || (n = !0)
                }
                return this.truncated && !this.isValidTruncated(e) || (this.nextVal = this.convertValue(e)), this.convertValue(t)
            }
            convertValue(t) {
                return null == this.dtype || "float32" === this.dtype ? t : Math.round(t)
            }
            isValidTruncated(t) {
                return t <= this.upper && t >= this.lower
            }
        }
        exports.MPRandGauss = a;
        class s {
            constructor(e, n, r, s) {
                this.alpha = e, this.beta = 1 / n, this.dtype = r;
                const o = s || Math.random();
                this.randu = t.alea(o.toString()), this.randn = new a(0, 1, r, !1, this.randu()), this.d = e < 1 ? e + 2 / 3 : e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
            }
            nextValue() {
                let t, e, n, r, a, s;
                for (;;) {
                    do {
                        r = this.randn.nextValue(), s = 1 + this.c * r
                    } while (s <= 0);
                    if (s *= s * s, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - s + Math.log(s)), (a = this.randu()) < e || Math.log(a) < n) break
                }
                return s = 1 / this.beta * this.d * s, this.alpha < 1 && (s *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(s)
            }
            convertValue(t) {
                return "float32" === this.dtype ? t : Math.round(t)
            }
        }
        exports.RandGamma = s;
        class o {
            constructor(e = 0, n = 1, r, a) {
                if (this.canReturnFloat = (() => null == this.dtype || "float32" === this.dtype), this.min = e, this.range = n - e, this.dtype = r, null == a && (a = Math.random()), "number" == typeof a && (a = a.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);
                this.random = t.alea(a)
            }
            convertValue(t) {
                return this.canReturnFloat() ? t : Math.round(t)
            }
            nextValue() {
                return this.convertValue(this.min + this.range * this.random())
            }
        }

        function i(t) {
            const e = t.length,
                n = c(t),
                r = d(t),
                a = e / 6 * (Math.pow(n, 2) + .25 * Math.pow(r - 3, 2));
            if (a > 5.991) throw new Error(`Invalid p-value for JB: ${a}`)
        }

        function h(t, n, r, a) {
            null == a && (a = (0, e.testEpsilon)());
            const s = l(t);
            (0, e.expectNumbersClose)(s, n, a), (0, e.expectNumbersClose)(u(t, s), r, a)
        }

        function l(t) {
            let e = 0;
            for (let n = 0; n < t.length; n++) e += t[n];
            return e / t.length
        }

        function u(t, e) {
            let n = 0;
            for (let r = 0; r < t.length; r++) {
                const a = t[r] - e;
                n += a * a
            }
            return Math.sqrt(n / t.length)
        }

        function d(t) {
            const e = l(t),
                n = t.length;
            let r = 0,
                a = 0;
            for (let s = 0; s < n; s++) {
                const n = t[s] - e;
                r += Math.pow(n, 2), a += Math.pow(n, 4)
            }
            return 1 / n * a / Math.pow(1 / n * r, 2)
        }

        function c(t) {
            const e = l(t),
                n = t.length;
            let r = 0,
                a = 0;
            for (let s = 0; s < n; s++) {
                const n = t[s] - e;
                r += Math.pow(n, 2), a += Math.pow(n, 3)
            }
            return 1 / n * a / Math.pow(1 / (n - 1) * r, 1.5)
        }
        exports.UniformRandom = o;
    }, {
        "seedrandom": "Kwju",
        "../test_util": "ip5I"
    }],
    "fM99": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.randomGamma = void 0;
        var e = require("./buffer"),
            r = require("./operation"),
            t = require("./rand_util");

        function a(r, a, o = 1, n = "float32", u) {
            if (null == o && (o = 1), null == n && (n = "float32"), "float32" !== n && "int32" !== n) throw new Error(`Unsupported data type ${n}`);
            const l = new t.RandGamma(a, o, n, u),
                s = (0, e.buffer)(r, n);
            for (let e = 0; e < s.values.length; e++) s.values[e] = l.nextValue();
            return s.toTensor()
        }
        const o = (0, r.op)({
            randomGamma_: a
        });
        exports.randomGamma = o;
    }, {
        "./buffer": "WyiN",
        "./operation": "JtaO",
        "./rand_util": "jZqu"
    }],
    "gSkF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.randomNormal = void 0;
        var e = require("./buffer"),
            r = require("./operation"),
            o = require("./rand_util");

        function t(r, t = 0, n = 1, a, u) {
            if (null != a && "bool" === a) throw new Error(`Unsupported data type ${a}`);
            const l = new o.MPRandGauss(t, n, a, !1, u),
                s = (0, e.buffer)(r, a);
            for (let e = 0; e < s.values.length; e++) s.values[e] = l.nextValue();
            return s.toTensor()
        }
        const n = (0, r.op)({
            randomNormal_: t
        });
        exports.randomNormal = n;
    }, {
        "./buffer": "WyiN",
        "./operation": "JtaO",
        "./rand_util": "jZqu"
    }],
    "yl8A": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.randomUniform = void 0;
        var e = require("./buffer"),
            r = require("./operation"),
            o = require("./rand_util");

        function n(r, n = 0, t = 1, u = "float32", i) {
            const a = (0, e.buffer)(r, u),
                f = new o.UniformRandom(n, t, null, i);
            for (let e = 0; e < a.values.length; e++) a.values[e] = f.nextValue();
            return a.toTensor()
        }
        const t = (0, r.op)({
            randomUniform_: n
        });
        exports.randomUniform = t;
    }, {
        "./buffer": "WyiN",
        "./operation": "JtaO",
        "./rand_util": "jZqu"
    }],
    "pBg9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor1d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o) {
            (0, r.assertNonNull)(n);
            const s = (0, e.inferShape)(n, o);
            if (1 !== s.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
            return (0, t.makeTensor)(n, null, s, o)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "gc29": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.range = s;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../util"),
            n = require("./tensor1d"),
            o = require("./zeros");

        function s(s, u, a = 1, i = "float32") {
            if (0 === a) throw new Error("Cannot have a step of zero");
            const l = {
                start: s,
                stop: u,
                step: a,
                dtype: i
            };
            return e.ENGINE.runKernelFunc(() => {
                if (s === u || s < u && a < 0 || u < s && a > 1) return (0, o.zeros)([0], i);
                const e = Math.abs(Math.ceil((u - s) / a)),
                    r = (0, t.makeZerosTypedArray)(e, i);
                u < s && 1 === a && (a = -1), r[0] = s;
                for (let t = 1; t < r.length; t++) r[t] = r[t - 1] + a;
                return (0, n.tensor1d)(r, i)
            }, {}, null, r.Range, l)
        }
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../util": "P6nv",
        "./tensor1d": "pBg9",
        "./zeros": "R5fo"
    }],
    "w0Wv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reciprocal = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            n = require("./operation");

        function c(n) {
            const c = (0, o.convertToTensor)(n, "x", "reciprocal"),
                i = {
                    x: c
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.reciprocal(c);
                return r([c]), o
            }, i, null, r.Reciprocal)
        }
        const i = (0, n.op)({
            reciprocal_: c
        });
        exports.reciprocal = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "SJP3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.relu = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function u(o) {
            const u = (0, n.convertToTensor)(o, "x", "relu"),
                t = {
                    x: u
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([u]), "bool" === u.dtype ? u.toInt() : e.relu(u)), t, null, r.Relu)
        }
        const t = (0, o.op)({
            relu_: u
        });
        exports.relu = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "MNkg": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.relu6 = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            u = require("./cast"),
            t = require("./operation");

        function o(t) {
            const o = (0, n.convertToTensor)(t, "x", "relu6"),
                l = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, r) => (r([o]), "bool" === o.dtype ? (0, u.cast)(o, "int32") : e.relu6(o)), l, null, r.Relu6)
        }
        const l = (0, t.op)({
            relu6_: o
        });
        exports.relu6 = l;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./cast": "qqq3",
        "./operation": "JtaO"
    }],
    "dTCT": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverse1d = void 0;
        var e = require("../tensor_util_env"),
            r = u(require("../util")),
            t = require("./operation"),
            n = require("./reverse");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(t) {
            const o = (0, e.convertToTensor)(t, "x", "reverse");
            return r.assert(1 === o.rank, () => `Error in reverse1D: x must be rank 1 but got rank ${o.rank}.`), (0, n.reverse)(o, 0)
        }
        const s = (0, t.op)({
            reverse1d_: i
        });
        exports.reverse1d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reverse": "SxGN"
    }],
    "jAVH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverse2d = void 0;
        var e = require("../tensor_util_env"),
            r = u(require("../util")),
            t = require("./operation"),
            n = require("./reverse");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(t, o) {
            const u = (0, e.convertToTensor)(t, "x", "reverse");
            return r.assert(2 === u.rank, () => `Error in reverse2D: x must be rank 2 but got rank ${u.rank}.`), (0, n.reverse)(u, o)
        }
        const s = (0, t.op)({
            reverse2d_: i
        });
        exports.reverse2d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reverse": "SxGN"
    }],
    "fmHW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverse3d = void 0;
        var e = require("../tensor_util_env"),
            r = u(require("../util")),
            t = require("./operation"),
            n = require("./reverse");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(t, o) {
            const u = (0, e.convertToTensor)(t, "x", "reverse");
            return r.assert(3 === u.rank, () => `Error in reverse3D: x must be rank 3 but got rank ${u.rank}.`), (0, n.reverse)(u, o)
        }
        const s = (0, t.op)({
            reverse3d_: i
        });
        exports.reverse3d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reverse": "SxGN"
    }],
    "CaS6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reverse4d = void 0;
        var e = require("../tensor_util_env"),
            r = u(require("../util")),
            t = require("./operation"),
            n = require("./reverse");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(t, o) {
            const u = (0, e.convertToTensor)(t, "x", "reverse");
            return r.assert(4 === u.rank, () => `Error in reverse4D: x must be rank 4 but got rank ${u.rank}.`), (0, n.reverse)(u, o)
        }
        const s = (0, t.op)({
            reverse4d_: i
        });
        exports.reverse4d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reverse": "SxGN"
    }],
    "WiyN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rfft = void 0;
        var e = require("../ops/complex"),
            r = require("../ops/imag"),
            s = require("../ops/operation"),
            t = require("../ops/real"),
            p = require("../util"),
            l = require("./concat"),
            o = require("./fft"),
            a = require("./reshape"),
            i = require("./slice"),
            h = require("./split"),
            u = require("./zeros"),
            n = require("./zeros_like");

        function f(s, f) {
            (0, p.assert)("float32" === s.dtype, () => `The dtype for rfft() must be real value but got ${s.dtype}`);
            let c = s.shape[s.shape.length - 1];
            const q = s.size / c;
            let g;
            if (null != f && f < c) {
                const e = s.shape.map(e => 0),
                    r = s.shape.map(e => e);
                r[s.shape.length - 1] = f, g = (0, i.slice)(s, e, r), c = f
            } else if (null != f && f > c) {
                const e = s.shape.map(e => e);
                e[s.shape.length - 1] = f - c, g = (0, l.concat)([s, (0, u.zeros)(e)], s.shape.length - 1), c = f
            } else g = s;
            const m = (0, n.zerosLike)(g),
                d = (0, a.reshape)((0, e.complex)(g, m), [q, c]),
                x = (0, o.fft)(d),
                z = Math.floor(c / 2) + 1,
                v = (0, t.real)(x),
                y = (0, r.imag)(x),
                _ = (0, h.split)(v, [z, c - z], v.shape.length - 1),
                b = (0, h.split)(y, [z, c - z], y.shape.length - 1),
                k = g.shape.slice();
            return k[g.shape.length - 1] = z, (0, a.reshape)((0, e.complex)(_[0], b[0]), k)
        }
        const c = (0, s.op)({
            rfft_: f
        });
        exports.rfft = c;
    }, {
        "../ops/complex": "Iowv",
        "../ops/imag": "C5d3",
        "../ops/operation": "JtaO",
        "../ops/real": "cKEu",
        "../util": "P6nv",
        "./concat": "dDdq",
        "./fft": "lSPP",
        "./reshape": "QI4k",
        "./slice": "zP07",
        "./split": "VA1I",
        "./zeros": "R5fo",
        "./zeros_like": "PDcB"
    }],
    "J1Ke": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.round = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            o = require("./operation");

        function u(o) {
            const u = (0, n.convertToTensor)(o, "x", "round"),
                t = {
                    x: u
                };
            return e.ENGINE.runKernelFunc(e => e.round(u), t, null, r.Round)
        }
        const t = (0, o.op)({
            round_: u
        });
        exports.round = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "nLmU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.selu = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            u = require("./operation");

        function o(u) {
            const o = (0, n.convertToTensor)(u, "x", "selu"),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.selu(o);
                return r([o]), n
            }, s, null, r.Selu)
        }
        const s = (0, u.op)({
            selu_: o
        });
        exports.selu = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "M7Hy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.separableConv2d = void 0;
        var e = require("../tensor_util_env"),
            r = a(require("../util")),
            t = require("./conv2d"),
            n = require("./depthwise_conv2d"),
            o = require("./operation");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(o, s, a, i, p, u = [1, 1], l = "NHWC") {
            const d = (0, e.convertToTensor)(o, "x", "separableConv2d"),
                b = (0, e.convertToTensor)(s, "depthwiseFilter", "separableConv2d"),
                f = (0, e.convertToTensor)(a, "pointwiseFilter", "separableConv2d");
            let v = d,
                c = !1;
            if (3 === d.rank && (c = !0, v = d.as4D(1, d.shape[0], d.shape[1], d.shape[2])), "NCHW" === l) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
            r.assert(4 === v.rank, () => "Error in separableConv2d: input must be rank 4, but got " + `rank ${v.rank}.`), r.assert(4 === b.rank, () => "Error in separableConv2d: depthwise filter must be rank 4, but " + `got rank ${b.rank}.`), r.assert(4 === f.rank, () => "Error in separableConv2d: pointwise filter must be rank 4, but " + `got rank ${b.rank}.`), r.assert(1 === f.shape[0], () => "Error in separableConv2d: the first dimension of pointwise filter " + ` must be 1, but got ${f.shape[0]}.`), r.assert(1 === f.shape[1], () => "Error in separableConv2d: the second dimension of pointwise " + `filter must be 1, but got ${f.shape[1]}.`);
            const h = b.shape[2],
                C = b.shape[3];
            r.assert(f.shape[2] === h * C, () => "Error in separableConv2d: the third dimension of pointwise filter " + `must be ${h*C}, ` + `but got ${f.shape[2]}.`);
            const k = (0, n.depthwiseConv2d)(v, b, i, p, l, u),
                w = (0, t.conv2d)(k, f, 1, "valid", l);
            return c ? w.as3D(w.shape[1], w.shape[2], w.shape[3]) : w
        }
        const p = (0, o.op)({
            separableConv2d_: i
        });
        exports.separableConv2d = p;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./conv2d": "oJQk",
        "./depthwise_conv2d": "Kahd",
        "./operation": "JtaO"
    }],
    "cgP9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.setdiff1dAsync = void 0;
        var e = require("../tensor"),
            t = require("../tensor_util_env"),
            r = o(require("../util"));

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, s, a) : r[s] = e[s]
                } return r.default = e, t && t.set(e, r), r
        }
        async function s(n, o) {
            const s = (0, t.convertToTensor)(n, "x", "setdiff1d"),
                a = (0, t.convertToTensor)(o, "y", "setdiff1d");
            r.assert(s.dtype === a.dtype, () => `x and y should have the same dtype, but got x (${s.dtype}) and y (${a.dtype}).`), r.assert(1 === s.rank, () => `x should be 1D tensor, but got x (${s.shape}).`), r.assert(1 === a.rank, () => `y should be 1D tensor, but got y (${a.shape}).`);
            const u = await s.data(),
                f = await a.data(),
                i = new Set(f);
            let d = 0;
            for (let e = 0; e < u.length; e++) i.has(u[e]) || d++;
            const c = new e.TensorBuffer([d], s.dtype),
                p = new e.TensorBuffer([d], "int32");
            for (let e = 0, t = 0; e < u.length; e++) i.has(u[e]) || (c.values[t] = u[e], p.values[t] = e, t++);
            return [c.toTensor(), p.toTensor()]
        }
        const a = s;
        exports.setdiff1dAsync = a;
    }, {
        "../tensor": "DTHt",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv"
    }],
    "cGq1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sign = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            i = require("./operation");

        function o(i) {
            const o = (0, r.convertToTensor)(i, "x", "sign"),
                s = {
                    x: o
                };
            return e.ENGINE.runKernelFunc(e => e.sign(o), s, null, n.Sign)
        }
        const s = (0, i.op)({
            sign_: o
        });
        exports.sign = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "lQVK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slice1d = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./operation"),
            n = require("./slice");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, i, u) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(t, o, i) {
            const u = (0, e.convertToTensor)(t, "x", "slice1d");
            return r.assert(1 === u.rank, () => `slice1d expects a rank-1 tensor, but got a rank-${u.rank} tensor`), (0, n.slice)(u, [o], [i])
        }
        const s = (0, t.op)({
            slice1d_: u
        });
        exports.slice1d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./slice": "zP07"
    }],
    "r8xQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slice2d = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./operation"),
            n = require("./slice");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, i, u) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(t, o, i) {
            const u = (0, e.convertToTensor)(t, "x", "slice2d");
            return r.assert(2 === u.rank, () => `slice2d expects a rank-2 tensor, but got a rank-${u.rank} tensor`), (0, n.slice)(u, o, i)
        }
        const s = (0, t.op)({
            slice2d_: u
        });
        exports.slice2d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./slice": "zP07"
    }],
    "jraI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slice3d = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./operation"),
            n = require("./slice");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, i, u) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(t, o, i) {
            const u = (0, e.convertToTensor)(t, "x", "slice3d");
            return r.assert(3 === u.rank, () => `slice3d expects a rank-3 tensor, but got a rank-${u.rank} tensor`), (0, n.slice)(u, o, i)
        }
        const s = (0, t.op)({
            slice3d_: u
        });
        exports.slice3d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./slice": "zP07"
    }],
    "r60P": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slice4d = void 0;
        var e = require("../tensor_util_env"),
            r = i(require("../util")),
            t = require("./operation"),
            n = require("./slice");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, i, u) : t[i] = e[i]
                } return t.default = e, r && r.set(e, t), t
        }

        function u(t, o, i) {
            const u = (0, e.convertToTensor)(t, "x", "slice4d");
            return r.assert(4 === u.rank, () => `slice4d expects a rank-4 tensor, but got a rank-${u.rank} tensor`), (0, n.slice)(u, o, i)
        }
        const s = (0, t.op)({
            slice4d_: u
        });
        exports.slice4d = s;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./slice": "zP07"
    }],
    "xLGH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.softmax = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function n(t, n = -1) {
            const s = (0, r.convertToTensor)(t, "logits", "softmax", "float32");
            if (-1 === n && (n = s.rank - 1), n !== s.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. " + `Logits was rank ${s.rank} and dim was ${n}`);
            const a = {
                    logits: s
                },
                i = {
                    dim: n
                };
            return e.ENGINE.runKernelFunc((e, o) => {
                const r = e.softmax(s, n);
                return o([r]), r
            }, a, null, o.Softmax, i)
        }
        const s = (0, t.op)({
            softmax_: n
        });
        exports.softmax = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "eE4m": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.softplus = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            o = require("../tensor_util_env"),
            s = require("./operation");

        function t(s) {
            const t = (0, o.convertToTensor)(s, "x", "softplus"),
                n = {
                    x: t
                };
            return e.ENGINE.runKernelFunc((e, r) => {
                const o = e.softplus(t);
                return r([t]), o
            }, n, null, r.Softplus)
        }
        const n = (0, s.op)({
            softplus_: t
        });
        exports.softplus = n;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "gsmP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squaredDifference = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            s = require("../tensor_util_env"),
            t = require("./broadcast_util"),
            u = require("./operation");

        function a(u, a) {
            let o = (0, s.convertToTensor)(u, "a", "squaredDifference"),
                i = (0, s.convertToTensor)(a, "b", "squaredDifference");
            [o, i] = (0, n.makeTypesMatch)(o, i), (0, t.assertAndGetBroadcastShape)(o.shape, i.shape);
            const c = {
                a: o,
                b: i
            };
            return e.ENGINE.runKernelFunc((e, r) => {
                const n = e.squaredDifference(o, i);
                return r([o, i]), n
            }, c, null, r.SquaredDifference, {})
        }
        const o = (0, u.op)({
            squaredDifference_: a
        });
        exports.squaredDifference = o;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "./broadcast_util": "Xh9J",
        "./operation": "JtaO"
    }],
    "ZVMV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squeeze = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            s = require("./operation"),
            o = require("./reshape");

        function t(s, t) {
            const u = (0, e.convertToTensor)(s, "x", "squeeze");
            return (0, o.reshape)(u, (0, r.squeezeShape)(u.shape, t).newShape)
        }
        const u = (0, s.op)({
            squeeze_: t
        });
        exports.squeeze = u;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "Q58L": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.stridedSlice = void 0;
        var e = require("../engine"),
            s = require("../kernel_names"),
            i = require("../tensor_util_env"),
            r = require("./operation"),
            t = require("./reshape"),
            n = require("./slice"),
            o = require("./slice_util");

        function l(r, l, a, d, p = 0, c = 0, h = 0, u = 0, k = 0) {
            null == d && (d = new Array(l.length));
            let x = (0, i.convertToTensor)(r, "x", "stridedSlice");
            const f = {
                    x: x
                },
                A = {
                    begin: l,
                    end: a,
                    strides: d,
                    beginMask: p,
                    endMask: c,
                    ellipsisMask: h,
                    newAxisMask: u,
                    shrinkAxisMask: k
                };
            return e.ENGINE.runKernelFunc(e => {
                const s = (0, o.maskToAxes)(h);
                if (s.length > 1) throw new Error("Multiple ellipses in slice is not allowed.");
                if (0 !== h && 0 !== u) throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
                if (0 !== h && 0 !== k) throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
                const i = x.rank - l.length,
                    r = (0, o.maskToAxes)(u),
                    f = x.shape.slice();
                if (r.forEach(e => {
                        l[e] = 0, a[e] = 1, f.splice(e, 0, 1)
                    }), x = (0, t.reshape)(x, f), s.length && i > 0) {
                    const e = s[0],
                        r = i + 1;
                    l = (0, o.startIndicesWithElidedDims)(p, e, r, l, x.shape), a = (0, o.stopIndicesWithElidedDims)(c, e, r, a, x.shape), d = (0, o.stridesWithElidedDims)(d, e, r, x.shape)
                } else
                    for (let t = 0; t < x.rank; t++) l[t] = (0, o.startForAxis)(p, l, d, x.shape, t, h), a[t] = (0, o.stopForAxis)(c, a, d, x.shape, t, h), d[t] = (0, o.stridesForAxis)(d, t, h);
                const A = (0, o.maskToAxes)(k);
                A.forEach(e => {
                    a[e] = l[e] + 1, d[e] = 1
                });
                const M = (0, o.computeOutShape)(l, a, d),
                    w = M.filter((e, s) => -1 === A.indexOf(s));
                return d.every(e => 1 === e) ? (0, t.reshape)((0, n.slice)(x, l, M), w) : e.stridedSlice(x, l, a, d).reshape(w)
            }, f, null, s.StridedSlice, A)
        }
        const a = (0, r.op)({
            stridedSlice_: l
        });
        exports.stridedSlice = a;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./slice": "zP07",
        "./slice_util": "Quoj"
    }],
    "DosY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tan = void 0;
        var e = require("../engine"),
            n = require("../kernel_names"),
            r = require("../tensor_util_env"),
            t = require("./operation");

        function o(t) {
            const o = (0, r.convertToTensor)(t, "x", "tan"),
                u = {
                    x: o
                };
            return e.ENGINE.runKernelFunc((e, n) => {
                const r = e.tan(o);
                return n([o]), r
            }, u, null, n.Tan)
        }
        const u = (0, t.op)({
            tan_: o
        });
        exports.tan = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "WnBr": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor2d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o, s) {
            if ((0, r.assertNonNull)(n), null != o && 2 !== o.length) throw new Error("tensor2d() requires shape to have two numbers");
            const u = (0, e.inferShape)(n, s);
            if (2 !== u.length && 1 !== u.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
            if (1 === u.length && null == o) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
            return (0, t.makeTensor)(n, o, u, s)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "VxHJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor4d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o, s) {
            if ((0, r.assertNonNull)(n), null != o && 4 !== o.length) throw new Error("tensor4d() requires shape to have four numbers");
            const u = (0, e.inferShape)(n, s);
            if (4 !== u.length && 1 !== u.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
            if (1 === u.length && null == o) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
            return (0, t.makeTensor)(n, o, u, s)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "qXmw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor5d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o, s) {
            if ((0, r.assertNonNull)(n), null != o && 5 !== o.length) throw new Error("tensor5d() requires shape to have five numbers");
            const u = (0, e.inferShape)(n, s);
            if (5 !== u.length && 1 !== u.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
            if (1 === u.length && null == o) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
            return (0, t.makeTensor)(n, o, u, s)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "GISR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tensor6d = n;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            t = require("./tensor_ops_util");

        function n(n, o, s) {
            if ((0, r.assertNonNull)(n), null != o && 6 !== o.length) throw new Error("tensor6d() requires shape to have six numbers");
            const u = (0, e.inferShape)(n, s);
            if (6 !== u.length && 1 !== u.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
            if (1 === u.length && null == o) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
            return o = o || u, (0, t.makeTensor)(n, o, u, s)
        }
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor_ops_util": "m0jF"
    }],
    "GNrW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.topk = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            o = require("../tensor_util_env"),
            r = require("./operation");

        function n(r, n = 1, s = !0) {
            const i = (0, o.convertToTensor)(r, "x", "topk");
            if (0 === i.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
            const p = i.shape[i.shape.length - 1];
            if (n > p) throw new Error(`'k' passed to topk() must be <= the last dimension (${p}) ` + `but got ${n}`);
            const u = {
                    x: i
                },
                k = {
                    k: n,
                    sorted: s
                },
                [a, c] = e.ENGINE.runKernelFunc(e => e.topk(i, n, s), u, null, t.TopK, k);
            return {
                values: a,
                indices: c
            }
        }
        const s = (0, r.op)({
            topk_: n
        });
        exports.topk = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "njSi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.truncatedNormal = void 0;
        var e = require("./buffer"),
            r = require("./operation"),
            t = require("./rand_util");

        function o(r, o = 0, u = 1, n, a) {
            if (null != n && "bool" === n) throw new Error("Unsupported data type $ { dtype }");
            const l = new t.MPRandGauss(o, u, n, !0, a),
                s = (0, e.buffer)(r, n);
            for (let e = 0; e < s.values.length; e++) s.values[e] = l.nextValue();
            return s.toTensor()
        }
        const u = (0, r.op)({
            truncatedNormal_: o
        });
        exports.truncatedNormal = u;
    }, {
        "./buffer": "WyiN",
        "./operation": "JtaO",
        "./rand_util": "jZqu"
    }],
    "JDMu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.unstack = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = s(require("../util")),
            u = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = o();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, u, s) : r[u] = e[u]
                } return r.default = e, t && t.set(e, r), r
        }

        function a(u, o = 0) {
            const s = (0, r.convertToTensor)(u, "x", "unstack");
            n.assert(o >= -s.shape.length && o < s.shape.length, () => `Axis = ${o} is not in [-${s.shape.length}, ${s.shape.length})`), o < 0 && (o += s.shape.length);
            const a = {
                    value: s
                },
                i = {
                    axis: o
                };
            return e.ENGINE.runKernelFunc(e => e.unstack(s, o), a, null, t.Unpack, i)
        }
        const i = (0, u.op)({
            unstack_: a
        });
        exports.unstack = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "oIio": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.variable = r;
        var e = require("../engine");

        function r(r, t = !0, a, i) {
            return e.ENGINE.makeVariable(r, t, a, i)
        }
    }, {
        "../engine": "Nc3Y"
    }],
    "tgEp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.whereImpl = t;
        var e = require("../ops/buffer");

        function t(t, r) {
            const n = [];
            for (let e = 0; e < r.length; e++) r[e] && n.push(e);
            const o = (0, e.buffer)(t, "int32"),
                s = (0, e.buffer)([n.length, t.length], "int32");
            for (let e = 0; e < n.length; e++) {
                const r = o.indexToLoc(n[e]),
                    l = e * t.length;
                s.values.set(r, l)
            }
            return s.toTensor()
        }
    }, {
        "../ops/buffer": "WyiN"
    }],
    "md2p": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.whereAsync = void 0;
        var e = require("../backends/where_impl"),
            r = require("../tensor_util_env");
        async function o(o) {
            const s = (0, r.convertToTensor)(o, "condition", "whereAsync", "bool"),
                n = await s.data(),
                t = (0, e.whereImpl)(s.shape, n);
            return o !== s && s.dispose(), t
        }
        const s = o;
        exports.whereAsync = s;
    }, {
        "../backends/where_impl": "tgEp",
        "../tensor_util_env": "c6yR"
    }],
    "hPEM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.booleanMaskAsync = void 0;
        var e = require("../tensor_util_env"),
            r = n(require("../util")),
            t = require("./gather"),
            s = require("./where_async");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function n(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var a = s ? Object.getOwnPropertyDescriptor(e, n) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, n, a) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }
        async function a(o, n, a) {
            const i = (0, e.convertToTensor)(o, "tensor", "boolMask"),
                c = (0, e.convertToTensor)(n, "mask", "boolMask", "bool"),
                u = null == a ? 0 : a,
                p = c.rank,
                l = i.shape;
            r.assert(p > 0, () => "mask cannot be scalar"), r.assertShapesMatch(l.slice(u, u + p), c.shape, "mask's shape must match the first K dimensions of tensor's shape,");
            let f = 1;
            for (let e = u; e < u + p; e++) f *= l[e];
            const h = l.slice(0, u).concat([f], l.slice(u + p)),
                d = i.reshape(h),
                y = c.reshape([-1]),
                b = await (0, s.whereAsync)(y),
                v = b.squeeze([1]),
                k = (0, t.gather)(d, v, u);
            return o !== i && i.dispose(), n !== c && c.dispose(), v.dispose(), d.dispose(), y.dispose(), b.dispose(), k
        }
        const i = a;
        exports.booleanMaskAsync = i;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./gather": "ESvM",
        "./where_async": "md2p"
    }],
    "M0Xr": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.notEqualStrict = exports.lessStrict = exports.lessEqualStrict = exports.greaterStrict = exports.greaterEqualStrict = exports.equalStrict = void 0;
        var e = require("../globals"),
            t = require("../tensor_util_env"),
            r = require("../util"),
            a = require("./operation");

        function s(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "notEqualStrict"),
                n = (0, t.convertToTensor)(s, "b", "notEqualStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in notEqualStrict: "), o.notEqual(n)
        }

        function o(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "lessStrict"),
                n = (0, t.convertToTensor)(s, "b", "lessStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in lessStrict: "), o.less(n)
        }

        function n(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "equalStrict"),
                n = (0, t.convertToTensor)(s, "b", "equalStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in equalStrict: "), o.equal(n)
        }

        function c(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "lessEqualStrict"),
                n = (0, t.convertToTensor)(s, "b", "lessEqualStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in lessEqualStrict: "), o.lessEqual(n)
        }

        function i(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "greaterStrict"),
                n = (0, t.convertToTensor)(s, "b", "greaterStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in greaterStrict: "), o.greater(n)
        }

        function u(a, s) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const o = (0, t.convertToTensor)(a, "a", "greaterEqualStrict"),
                n = (0, t.convertToTensor)(s, "b", "greaterEqualStrict");
            return (0, r.assertShapesMatch)(o.shape, n.shape, "Error in greaterEqualStrict: "), o.greaterEqual(n)
        }
        const l = (0, a.op)({
            equalStrict_: n
        });
        exports.equalStrict = l;
        const p = (0, a.op)({
            greaterEqualStrict_: u
        });
        exports.greaterEqualStrict = p;
        const S = (0, a.op)({
            greaterStrict_: i
        });
        exports.greaterStrict = S;
        const v = (0, a.op)({
            lessEqualStrict_: c
        });
        exports.lessEqualStrict = v;
        const d = (0, a.op)({
            lessStrict_: o
        });
        exports.lessStrict = d;
        const q = (0, a.op)({
            notEqualStrict_: s
        });
        exports.notEqualStrict = q;
    }, {
        "../globals": "GWnL",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "V7h5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.subStrict = exports.squaredDifferenceStrict = exports.powStrict = exports.mulStrict = exports.modStrict = exports.minimumStrict = exports.maximumStrict = exports.divStrict = exports.addStrict = void 0;
        var e = require("../globals"),
            t = require("../tensor_util_env"),
            r = i(require("../util")),
            o = require("./operation");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var a = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, i, a) : r[i] = e[i]
                } return r.default = e, t && t.set(e, r), r
        }

        function a(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "addStrict"),
                a = (0, t.convertToTensor)(n, "b", "addStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in addStrict: "), i.add(a)
        }

        function s(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "subStrict"),
                a = (0, t.convertToTensor)(n, "b", "subStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in subStrict: "), i.sub(a)
        }

        function c(t, o) {
            return (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future"), r.assertShapesMatch(t.shape, o.shape, "Error in powStrict: "), t.pow(o)
        }

        function p(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "mul"),
                a = (0, t.convertToTensor)(n, "b", "mul");
            return r.assertShapesMatch(i.shape, a.shape, "Error in multiplyStrict: "), i.mul(a)
        }

        function u(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "div"),
                a = (0, t.convertToTensor)(n, "b", "div");
            return r.assertShapesMatch(i.shape, a.shape, "Error in divideStrict: "), i.div(a)
        }

        function d(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "modStrict"),
                a = (0, t.convertToTensor)(n, "b", "modStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in modStrict: "), i.mod(a)
        }

        function m(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "minimumStrict"),
                a = (0, t.convertToTensor)(n, "b", "minimumStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in minimumStrict: "), i.minimum(a)
        }

        function f(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "maximumStrict"),
                a = (0, t.convertToTensor)(n, "b", "maximumStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in maximumStrict: "), i.maximum(a)
        }

        function v(o, n) {
            (0, e.deprecationWarn)("strict variants of ops have been deprecated and will be removed in future");
            const i = (0, t.convertToTensor)(o, "a", "squaredDifferenceStrict"),
                a = (0, t.convertToTensor)(n, "b", "squaredDifferenceStrict");
            return r.assertShapesMatch(i.shape, a.shape, "Error in squaredDifferenceStrict: "), i.squaredDifference(a)
        }
        const S = (0, o.op)({
            addStrict_: a
        });
        exports.addStrict = S;
        const h = (0, o.op)({
            divStrict_: u
        });
        exports.divStrict = h;
        const l = (0, o.op)({
            maximumStrict_: f
        });
        exports.maximumStrict = l;
        const b = (0, o.op)({
            minimumStrict_: m
        });
        exports.minimumStrict = b;
        const T = (0, o.op)({
            modStrict_: d
        });
        exports.modStrict = T;
        const x = (0, o.op)({
            mulStrict_: p
        });
        exports.mulStrict = x;
        const w = (0, o.op)({
            powStrict_: c
        });
        exports.powStrict = w;
        const _ = (0, o.op)({
            squaredDifferenceStrict_: v
        });
        exports.squaredDifferenceStrict = _;
        const M = (0, o.op)({
            subStrict_: s
        });
        exports.subStrict = M;
    }, {
        "../globals": "GWnL",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "Twvf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.norm = void 0;
        var r = require("../tensor_util_env"),
            e = require("../util"),
            n = require("./abs"),
            t = q(require("./axis_util")),
            i = require("./max"),
            u = require("./min"),
            a = require("./operation"),
            o = require("./pow"),
            s = require("./reshape"),
            f = require("./scalar"),
            l = require("./sqrt"),
            p = require("./square"),
            c = require("./sum");

        function m() {
            if ("function" != typeof WeakMap) return null;
            var r = new WeakMap;
            return m = function() {
                return r
            }, r
        }

        function q(r) {
            if (r && r.__esModule) return r;
            if (null === r || "object" != typeof r && "function" != typeof r) return {
                default: r
            };
            var e = m();
            if (e && e.has(r)) return e.get(r);
            var n = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in r)
                if (Object.prototype.hasOwnProperty.call(r, i)) {
                    var u = t ? Object.getOwnPropertyDescriptor(r, i) : null;
                    u && (u.get || u.set) ? Object.defineProperty(n, i, u) : n[i] = r[i]
                } return n.default = r, e && e.set(r, n), n
        }

        function b(n, i = "euclidean", u = null, a = !1) {
            const o = d(n = (0, r.convertToTensor)(n, "x", "norm"), i, u);
            let s = o.shape;
            if (a) {
                const r = (0, e.parseAxisParam)(u, n.shape);
                s = t.expandShapeToKeepDim(o.shape, r)
            }
            return o.reshape(s)
        }

        function d(r, e, t = null) {
            if (0 === r.rank) return (0, n.abs)(r);
            if (1 !== r.rank && null === t) return d((0, s.reshape)(r, [-1]), e, t);
            if (1 === r.rank || "number" == typeof t || Array.isArray(t) && 1 === t.length) {
                if (1 === e) return (0, c.sum)((0, n.abs)(r), t);
                if (e === 1 / 0) return (0, i.max)((0, n.abs)(r), t);
                if (e === -1 / 0) return (0, u.min)((0, n.abs)(r), t);
                if ("euclidean" === e || 2 === e) return (0, l.sqrt)((0, c.sum)((0, o.pow)((0, n.abs)(r), (0, f.scalar)(2, "int32")), t));
                throw new Error(`Error in norm: invalid ord value: ${e}`)
            }
            if (Array.isArray(t) && 2 === t.length) {
                if (1 === e) return (0, i.max)((0, c.sum)((0, n.abs)(r), t[0]), t[1] - 1);
                if (e === 1 / 0) return (0, i.max)((0, c.sum)((0, n.abs)(r), t[1]), t[0]);
                if (e === -1 / 0) return (0, u.min)((0, c.sum)((0, n.abs)(r), t[1]), t[0]);
                if ("fro" === e || "euclidean" === e) return (0, l.sqrt)((0, c.sum)((0, p.square)(r), t));
                throw new Error(`Error in norm: invalid ord value: ${e}`)
            }
            throw new Error(`Error in norm: invalid axis: ${t}`)
        }
        const v = (0, a.op)({
            norm_: b
        });
        exports.norm = v;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./abs": "aE3W",
        "./axis_util": "DsMP",
        "./max": "iipD",
        "./min": "w9We",
        "./operation": "JtaO",
        "./pow": "vt1B",
        "./reshape": "QI4k",
        "./scalar": "Ay42",
        "./sqrt": "iJpu",
        "./square": "mJRX",
        "./sum": "ITAy"
    }],
    "HWJh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.movingAverage = void 0;
        var e = require("../tensor_util"),
            r = require("../tensor_util_env"),
            t = p(require("../util")),
            n = require("./add"),
            o = require("./div"),
            i = require("./mul"),
            u = require("./operation"),
            s = require("./pow"),
            a = require("./scalar"),
            v = require("./sub");

        function c() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return c = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = c();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(u, c, p, l, f = !0) {
            const g = (0, r.convertToTensor)(u, "v", "movingAverage"),
                d = (0, r.convertToTensor)(c, "x", "movingAverage"),
                y = (0, r.convertToTensor)(p, "decay", "movingAverage");
            (0, e.assertTypesMatch)(g, d), t.assert(t.arraysEqual(g.shape, d.shape), () => "Shape mismatch in v and x");
            const b = (0, a.scalar)(1),
                q = (0, v.sub)(b, y);
            let m = (0, i.mul)((0, v.sub)(d, g), q);
            if (f) {
                t.assert(null != l, () => "When using zeroDebias: true, step is required.");
                const e = (0, r.convertToTensor)(l, "step", "movingAverage");
                m = (0, o.div)(m, (0, v.sub)(b, (0, s.pow)(y, e)))
            }
            return (0, n.add)(g, m)
        }
        const f = (0, u.op)({
            movingAverage_: l
        });
        exports.movingAverage = f;
    }, {
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./div": "D8Fc",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./pow": "vt1B",
        "./scalar": "Ay42",
        "./sub": "dGex"
    }],
    "QGqq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.scatterND = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = require("./operation"),
            o = i(require("./scatter_nd_util"));

        function u() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return u = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = u();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, o, i) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function c(n, u, i) {
            const c = (0, r.convertToTensor)(n, "indices", "scatterND", "int32"),
                s = (0, r.convertToTensor)(u, "updates", "scatterND");
            o.validateInput(s, c, i);
            const a = {
                    indices: c,
                    updates: s
                },
                p = {
                    shape: i
                };
            return e.ENGINE.runKernelFunc(e => e.scatterND(c, s, i), a, null, t.ScatterNd, p)
        }
        const s = (0, n.op)({
            scatterND_: c
        });
        exports.scatterND = s;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO",
        "./scatter_nd_util": "H15o"
    }],
    "wfit": [function(require, module, exports) {
        "use strict";

        function e(e, t, r, s) {
            if ("int32" !== e.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type," + ` but the dtype was ${e.dtype}.`);
            if (e.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix," + ` but got shape ${e.shape}.`);
            const a = e.rank > 0 ? e.shape[0] : 1,
                o = e.rank > 1 ? e.shape[1] : 1;
            if (r.length !== o) throw new Error("outputShape has incorrect number of elements:," + ` ${r.length}, should be: ${o}.`);
            const n = t.size;
            if (0 !== t.rank && (1 !== t.rank || n !== a)) throw new Error("sparseValues has incorrect shape " + `${t.shape}, should be [] or [${a}]`);
            if (t.dtype !== s.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateInput = e;
    }, {}],
    "vYKY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sparseToDense = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = u(require("../ops/sparse_to_dense_util")),
            n = require("../tensor_util_env"),
            s = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function u(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, s) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, s, u) : t[s] = e[s]
                } return t.default = e, r && r.set(e, t), t
        }

        function a(s, o, u, a = 0) {
            const p = (0, n.convertToTensor)(s, "sparseIndices", "sparseToDense", "int32"),
                i = (0, n.convertToTensor)(o, "sparseValues", "sparseToDense"),
                c = (0, n.convertToTensor)(a, "defaultValue", "sparseToDense", i.dtype);
            t.validateInput(p, i, u, c);
            const l = {
                    sparseIndices: p,
                    sparseValues: i,
                    defaultValue: c
                },
                f = {
                    outputShape: u
                };
            return e.ENGINE.runKernelFunc(e => e.sparseToDense(p, i, u, c), l, null, r.SparseToDense, f)
        }
        const p = (0, s.op)({
            sparseToDense_: a
        });
        exports.sparseToDense = p;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../ops/sparse_to_dense_util": "wfit",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "UkmN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.gatherND = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = require("./operation");

        function o(t, o) {
            const i = (0, n.convertToTensor)(o, "indices", "gatherND", "int32"),
                s = (0, n.convertToTensor)(t, "x", "gatherND"),
                a = {
                    params: s,
                    indices: i
                };
            return e.ENGINE.runKernelFunc(e => e.gatherND(s, i), a, null, r.GatherNd)
        }
        const i = (0, t.op)({
            gatherND_: o
        });
        exports.gatherND = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./operation": "JtaO"
    }],
    "I4lK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getNoiseShape = n;
        var e = r(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = u ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o]
                } return n.default = e, r && r.set(e, n), n
        }

        function n(t, r) {
            if (null == r) return t.shape.slice();
            if (e.arraysEqual(t.shape, r)) return r;
            if (t.shape.length === r.length) {
                const e = [];
                for (let n = 0; n < t.shape.length; n++) null == r[n] && null != t.shape[n] ? e.push(t.shape[n]) : e.push(r[n]);
                return e
            }
            return r
        }
    }, {
        "../util": "P6nv"
    }],
    "sFBi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.dropout = void 0;
        var e = require("../tensor"),
            t = require("../tensor_util_env"),
            r = a(require("../util")),
            o = require("./dropout_util"),
            n = require("./operation"),
            u = require("./random_uniform");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = i();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var u = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    u && (u.get || u.set) ? Object.defineProperty(r, n, u) : r[n] = e[n]
                } return r.default = e, t && t.set(e, r), r
        }

        function s(n, i, a, s) {
            const f = (0, t.convertToTensor)(n, "x", "dropout");
            if (r.assert("float32" === f.dtype, () => "x has to be a floating point tensor since it's going to be " + `scaled, but got a ${f.dtype} tensor instead.`), r.assert(i >= 0 && i < 1, () => `rate must be a float in the range [0, 1), but got ${i}.`), 0 === i) return n instanceof e.Tensor ? f.clone() : f;
            const p = (0, o.getNoiseShape)(f, a),
                c = 1 - i,
                l = (0, u.randomUniform)(p, 0, 1, "float32", s).add(c).floor().div(c);
            return f.mul(l)
        }
        const f = (0, n.op)({
            dropout_: s
        });
        exports.dropout = f;
    }, {
        "../tensor": "DTHt",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./dropout_util": "I4lK",
        "./operation": "JtaO",
        "./random_uniform": "yl8A"
    }],
    "A6ms": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.enclosingPowerOfTwo = t, exports.cosineWindow = e;
        var o = require("./tensor1d");

        function t(o) {
            return Math.floor(Math.pow(2, Math.ceil(Math.log(o) / Math.log(2))))
        }

        function e(t, e, r) {
            const n = 1 - t % 2,
                s = new Float32Array(t);
            for (let o = 0; o < t; ++o) {
                const a = 2 * Math.PI * o / (t + n - 1);
                s[o] = e - r * Math.cos(a)
            }
            return (0, o.tensor1d)(s, "float32")
        }
    }, {
        "./tensor1d": "pBg9"
    }],
    "JOMU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.inTopKAsync = void 0;
        var e = require("../tensor_util_env"),
            t = require("../util"),
            s = require("./tensor");
        async function r(r, n, o = 1) {
            const a = (0, e.convertToTensor)(r, "predictions", "inTopK"),
                i = (0, e.convertToTensor)(n, "targets", "inTopK");
            (0, t.assert)(a.rank > 1, () => "inTopK() expects the predictions to be of rank 2 or higher, " + `but got ${a.rank}`), (0, t.assert)(a.rank - 1 === i.rank, () => "predictions rank should be 1 larger than targets rank, but got predictions rank " + `${a.rank} and targets rank ${i.rank}`), (0, t.assertShapesMatch)(a.shape.slice(0, a.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
            const p = a.shape[a.shape.length - 1];
            (0, t.assert)(o > 0 && o <= p, () => "'k' passed to inTopK() must be > 0 && <= the predictions last " + `dimension (${p}), but got ${o}`);
            const h = await a.data(),
                c = await i.data(),
                [l, d] = [h.length / p, p],
                u = (0, t.getTypedArrayFromDType)("bool", l);
            for (let e = 0; e < l; e++) {
                const t = e * d,
                    s = h.subarray(t, t + d),
                    r = [];
                for (let e = 0; e < s.length; e++) r.push({
                    value: s[e],
                    index: e
                });
                r.sort((e, t) => t.value - e.value), u[e] = 0;
                for (let n = 0; n < o; n++)
                    if (r[n].index === c[e]) {
                        u[e] = 1;
                        break
                    }
            }
            return r !== a && a.dispose(), n !== i && i.dispose(), (0, s.tensor)(u, i.shape, "bool")
        }
        const n = r;
        exports.inTopKAsync = n;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./tensor": "P2QC"
    }],
    "mypO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getFusedDyActivation = l, exports.getFusedBiasGradient = a, exports.applyActivation = s, exports.shouldFuse = void 0;
        var e = i(require("./broadcast_util")),
            r = require("./elu"),
            t = require("./prelu"),
            u = require("./relu"),
            n = require("./relu6");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var i = u ? Object.getOwnPropertyDescriptor(e, n) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, n, i) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }

        function l(e, r, t) {
            if (null == t || "linear" === t) return e;
            if ("relu" === t) return e.mul(r.step());
            throw new Error(`Cannot compute gradient for fused activation ${t}.`)
        }

        function a(r, t) {
            let u = t;
            const n = e.getReductionAxes(r.shape, t.shape);
            return n.length > 0 && (u = u.sum(n)), u.reshape(r.shape)
        }

        function s(e, o, i) {
            if ("linear" === o) return e;
            if ("relu" === o) return (0, u.relu)(e);
            if ("elu" === o) return (0, r.elu)(e);
            if ("relu6" === o) return (0, n.relu6)(e);
            if ("prelu" === o) return (0, t.prelu)(e, i);
            throw new Error(`Unknown fused activation ${o}.`)
        }
        const f = (e, r) => {
            return !(e > 0) || "linear" === r
        };
        exports.shouldFuse = f;
    }, {
        "./broadcast_util": "Xh9J",
        "./elu": "a7Il",
        "./prelu": "mkuj",
        "./relu": "SJP3",
        "./relu6": "MNkg"
    }],
    "C813": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.conv2d = void 0;
        var e = require("../engine"),
            r = require("../gradients"),
            t = require("../kernel_names"),
            n = require("../ops/conv2d_backprop_filter"),
            o = require("../ops/conv2d_backprop_input"),
            a = require("../tensor_util"),
            i = require("../tensor_util_env"),
            s = h(require("../util")),
            u = require("./add"),
            d = h(require("./broadcast_util")),
            p = require("./conv2d"),
            c = h(require("./conv_util")),
            l = require("./fused_util"),
            v = require("./operation");

        function f() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return f = function() {
                return e
            }, e
        }

        function h(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = f();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function g({
            x: v,
            filter: f,
            strides: h,
            pad: g,
            dataFormat: b = "NHWC",
            dilations: k = [1, 1],
            dimRoundingMode: m,
            bias: y,
            activation: _ = "linear",
            preluActivationWeights: D
        }) {
            if (_ = _ || "linear", !1 === (0, l.shouldFuse)(e.ENGINE.state.gradientDepth, _)) {
                let e = (0, p.conv2d)(v, f, h, g, b, k, m);
                return null != y && (e = (0, u.add)(e, y)), (0, l.applyActivation)(e, _, D)
            }
            const q = (0, i.convertToTensor)(v, "x", "conv2d"),
                E = (0, i.convertToTensor)(f, "filter", "conv2d");
            let F = q,
                O = !1;
            3 === q.rank && (O = !0, F = q.as4D(1, q.shape[0], q.shape[1], q.shape[2])), s.assert(4 === F.rank, () => "Error in fused conv2d: input must be rank 4, but got rank " + `${F.rank}.`), s.assert(4 === E.rank, () => "Error in fused conv2d: filter must be rank 4, but got rank " + `${E.rank}.`), null != m && s.assert(s.isInt(g), () => "Error in fused conv2d: pad must be an integer when using, " + `dimRoundingMode ${m} but got pad ${g}.`), s.assert(F.shape[3] === E.shape[2], () => `Error in conv2d: depth of input (${F.shape[3]}) must match ` + `input depth for filter ${E.shape[2]}.`), s.assert(c.eitherStridesOrDilationsAreOne(h, k), () => "Error in conv2D: Either strides or dilations must be 1. " + `Got strides ${h} and dilations '${k}'`), s.assert("NHWC" === b, () => `Error in conv2d: got dataFormat of ${b} but only NHWC is currently supported.`);
            const $ = c.computeConv2DInfo(F.shape, E.shape, h, k, g, m);
            let G, N;
            null != y && (G = (0, i.convertToTensor)(y, "bias", "fused conv2d"), [G] = (0, a.makeTypesMatch)(G, q), d.assertAndGetBroadcastShape($.outShape, G.shape)), null != D && (N = (0, i.convertToTensor)(D, "prelu weights", "fused conv2d"));
            const T = (e, r) => {
                    const [t, a, i, u] = r, d = (0, l.getFusedDyActivation)(e, i, _);
                    s.assert(c.tupleValuesAreOne(k), () => "Error in gradient of fused conv2D: dilation rates greater than 1 " + `are not yet supported in gradients. Got dilations '${k}'`);
                    const p = [(0, o.conv2DBackpropInput)(a.shape, d, t, h, g), (0, n.conv2DBackpropFilter)(a, d, t.shape, h, g)];
                    if (null != u) {
                        const e = (0, l.getFusedBiasGradient)(u, d);
                        p.push(e)
                    }
                    return p
                },
                A = e => {
                    return e.fusedConv2d({
                        input: F,
                        filter: E,
                        convInfo: $,
                        bias: G,
                        activation: _,
                        preluActivationWeights: N
                    })
                },
                C = {
                    x: F,
                    filter: E,
                    bias: G,
                    preluActivationWeights: N
                },
                M = {
                    strides: h,
                    pad: g,
                    dataFormat: b,
                    dilations: k,
                    dimRoundingMode: m,
                    activation: _
                };
            if (null == y) {
                return (0, r.customGrad)((r, n, o) => {
                    let a = e.ENGINE.runKernelFunc(A, C, null, t.FusedConv2D, M);
                    return o([n, r, a]), O && (a = a.as3D(a.shape[1], a.shape[2], a.shape[3])), {
                        value: a,
                        gradFunc: T
                    }
                })(F, E)
            }
            return (0, r.customGrad)((r, n, o, a) => {
                let i = e.ENGINE.runKernelFunc(A, C, null, t.FusedConv2D, M);
                return a([n, r, i, o]), O && (i = i.as3D(i.shape[1], i.shape[2], i.shape[3])), {
                    value: i,
                    gradFunc: T
                }
            })(F, E, G)
        }
        const b = (0, v.op)({
            fusedConv2d_: g
        });
        exports.conv2d = b;
    }, {
        "../engine": "Nc3Y",
        "../gradients": "yPDw",
        "../kernel_names": "sdEe",
        "../ops/conv2d_backprop_filter": "JjEd",
        "../ops/conv2d_backprop_input": "GLx7",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./broadcast_util": "Xh9J",
        "./conv2d": "oJQk",
        "./conv_util": "Evju",
        "./fused_util": "mypO",
        "./operation": "JtaO"
    }],
    "WUlv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.depthwiseConv2d = void 0;
        var e = require("../engine"),
            t = require("../gradients"),
            r = require("../kernel_names"),
            n = require("../tensor_util"),
            i = require("../tensor_util_env"),
            s = f(require("../util")),
            a = require("./add"),
            o = f(require("./broadcast_util")),
            u = f(require("./conv_util")),
            d = require("./depthwise_conv2d"),
            p = require("./depthwise_conv2d_native_backprop_filter"),
            l = require("./depthwise_conv2d_native_backprop_input"),
            h = require("./fused_util"),
            c = require("./operation");

        function v() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return v = function() {
                return e
            }, e
        }

        function f(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = v();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = e[i]
                } return r.default = e, t && t.set(e, r), r
        }

        function w({
            x: c,
            filter: v,
            strides: f,
            pad: w,
            dataFormat: g = "NHWC",
            dilations: b = [1, 1],
            dimRoundingMode: C,
            bias: _,
            activation: m = "linear",
            preluActivationWeights: k
        }) {
            if (!1 === (0, h.shouldFuse)(e.ENGINE.state.gradientDepth, m)) {
                let e = (0, d.depthwiseConv2d)(c, v, f, w, g, b, C);
                return null != _ && (e = (0, a.add)(e, _)), (0, h.applyActivation)(e, m, k)
            }
            const D = (0, i.convertToTensor)(c, "x", "depthwiseConv2d"),
                q = (0, i.convertToTensor)(v, "filter", "depthwiseConv2d");
            let y = D,
                E = !1;
            3 === D.rank && (E = !0, y = D.as4D(1, D.shape[0], D.shape[1], D.shape[2])), s.assert(4 === y.rank, () => "Error in fused depthwiseConv2d: input must be rank 4, but got " + `rank ${y.rank}.`), s.assert(4 === q.rank, () => "Error in fused depthwiseConv2d: filter must be rank 4, " + `but got rank ${q.rank}.`), s.assert(y.shape[3] === q.shape[2], () => "Error in fused depthwiseConv2d: number of input channels " + `(${y.shape[3]}) must match the inChannels dimension in ` + `filter ${q.shape[2]}.`), null == b && (b = [1, 1]), s.assert(u.eitherStridesOrDilationsAreOne(f, b), () => "Error in fused depthwiseConv2d: Either strides or dilations must " + `be 1. Got strides ${f} and dilations '${b}'`), null != C && s.assert(s.isInt(w), () => "Error in fused depthwiseConv2d: pad must be an integer when " + `using dimRoundingMode ${C} but got pad ${w}.`);
            const F = u.computeConv2DInfo(y.shape, q.shape, f, b, w, C, !0);
            let O, G;
            null != _ && (O = (0, i.convertToTensor)(_, "bias", "fused conv2d"), [O] = (0, n.makeTypesMatch)(O, D), o.assertAndGetBroadcastShape(F.outShape, O.shape)), null != k && (G = (0, i.convertToTensor)(k, "prelu weights", "fused depthwiseConv2d"));
            const N = (e, t) => {
                    s.assert(u.tupleValuesAreOne(b), () => "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations " + `'${b}'`);
                    const [r, n, i, a] = t, o = (0, h.getFusedDyActivation)(e, i, m), d = (0, l.depthwiseConv2dNativeBackpropInput)(n.shape, o, r, F), c = (0, p.depthwiseConv2dNativeBackpropFilter)(n, o, r.shape, F);
                    if (null != a) {
                        return [d, c, (0, h.getFusedBiasGradient)(O, o)]
                    }
                    return [d, c]
                },
                T = e => {
                    return e.fusedDepthwiseConv2D({
                        input: y,
                        filter: q,
                        convInfo: F,
                        bias: O,
                        activation: m,
                        preluActivationWeights: G
                    })
                },
                $ = {
                    x: y,
                    filter: q,
                    bias: O,
                    preluActivationWeights: G
                },
                A = {
                    strides: f,
                    pad: w,
                    dataFormat: g,
                    dilations: b,
                    dimRoundingMode: C,
                    activation: m
                };
            if (null == _) {
                return (0, t.customGrad)((t, n, i) => {
                    let s = e.ENGINE.runKernelFunc(T, $, null, r.FusedDepthwiseConv2D, A);
                    return i([n, t, s]), E && (s = s.as3D(s.shape[1], s.shape[2], s.shape[3])), {
                        value: s,
                        gradFunc: N
                    }
                })(y, q)
            }
            return (0, t.customGrad)((t, n, i, s) => {
                let a = e.ENGINE.runKernelFunc(T, $, null, r.FusedDepthwiseConv2D, A);
                return s([n, t, a, i]), E && (a = a.as3D(a.shape[1], a.shape[2], a.shape[3])), {
                    value: a,
                    gradFunc: N
                }
            })(y, q, O)
        }
        const g = (0, c.op)({
            fusedDepthwiseConv2d_: w
        });
        exports.depthwiseConv2d = g;
    }, {
        "../engine": "Nc3Y",
        "../gradients": "yPDw",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./broadcast_util": "Xh9J",
        "./conv_util": "Evju",
        "./depthwise_conv2d": "Kahd",
        "./depthwise_conv2d_native_backprop_filter": "pXLg",
        "./depthwise_conv2d_native_backprop_input": "mUFN",
        "./fused_util": "mypO",
        "./operation": "JtaO"
    }],
    "zMsA": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.matMul = void 0;
        var e = require("../engine"),
            t = require("../gradients"),
            r = require("../kernel_names"),
            a = require("../tensor_util"),
            s = require("../tensor_util_env"),
            n = h(require("../util")),
            u = require("./add"),
            o = h(require("./broadcast_util")),
            i = require("./fused_util"),
            l = require("./mat_mul"),
            p = require("./operation"),
            c = require("./reshape");

        function d() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return d = function() {
                return e
            }, e
        }

        function h(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = d();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                a = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var n = a ? Object.getOwnPropertyDescriptor(e, s) : null;
                    n && (n.get || n.set) ? Object.defineProperty(r, s, n) : r[s] = e[s]
                } return r.default = e, t && t.set(e, r), r
        }

        function f({
            a: p,
            b: d,
            transposeA: h = !1,
            transposeB: f = !1,
            bias: m,
            activation: M = "linear",
            preluActivationWeights: v
        }) {
            if (!1 === (0, i.shouldFuse)(e.ENGINE.state.gradientDepth, M)) {
                let e = (0, l.matMul)(p, d, h, f);
                return null != m && (e = (0, u.add)(e, m)), (0, i.applyActivation)(e, M, v)
            }
            let k = (0, s.convertToTensor)(p, "a", "fused matMul"),
                b = (0, s.convertToTensor)(d, "b", "fused matMul");
            [k, b] = (0, a.makeTypesMatch)(k, b);
            const g = h ? k.shape[k.rank - 2] : k.shape[k.rank - 1],
                y = f ? b.shape[b.rank - 1] : b.shape[b.rank - 2],
                _ = h ? k.shape[k.rank - 1] : k.shape[k.rank - 2],
                q = f ? b.shape[b.rank - 2] : b.shape[b.rank - 1],
                T = k.shape.slice(0, -2),
                $ = b.shape.slice(0, -2),
                F = n.sizeFromShape(T),
                A = n.sizeFromShape($);
            n.assert(k.rank >= 2 && b.rank >= 2 && k.rank === b.rank, () => "Error in fused matMul: inputs must have the same rank of at least " + `2, got ranks ${k.rank} and ${b.rank}.`), n.assert(n.arraysEqual(T, $), () => `Error in fused matMul: outer dimensions (${T}) and (` + `${$}) of Tensors with shapes ${k.shape} and ` + `${b.shape} must match.`), n.assert(g === y, () => `Error in fused matMul: inner shapes (${g}) and (` + `${y}) of Tensors with shapes ${k.shape} and ` + `${b.shape} and transposeA=${h}` + ` and transposeB=${f} must match.`);
            const E = k.shape.slice(0, -2).concat([_, q]),
                O = h ? k.as3D(F, g, _) : k.as3D(F, _, g),
                D = f ? b.as3D(A, q, y) : b.as3D(A, y, q);
            let j, w;
            null != m && (j = (0, s.convertToTensor)(m, "bias", "fused matMul"), [j] = (0, a.makeTypesMatch)(j, k), o.assertAndGetBroadcastShape(E, j.shape)), null != v && (w = (0, s.convertToTensor)(v, "prelu weights", "fused matMul"));
            const B = (e, t) => {
                    const [r, a, s, n] = t, u = (0, i.getFusedDyActivation)((0, c.reshape)(e, s.shape), s, M);
                    let o, p;
                    if (h || f ? !h && f ? (o = (0, l.matMul)(u, a, !1, !1), p = (0, l.matMul)(u, r, !0, !1)) : h && !f ? (o = (0, l.matMul)(a, u, !1, !0), p = (0, l.matMul)(r, u, !1, !1)) : (o = (0, l.matMul)(a, u, !0, !0), p = (0, l.matMul)(u, r, !0, !0)) : (o = (0, l.matMul)(u, a, !1, !0), p = (0, l.matMul)(r, u, !0, !1)), null != m) {
                        return [o, p, (0, i.getFusedBiasGradient)(n, u)]
                    }
                    return [o, p]
                },
                G = e => {
                    return e.fusedBatchMatMul({
                        a: O,
                        b: D,
                        transposeA: h,
                        transposeB: f,
                        bias: j,
                        activation: M,
                        preluActivationWeights: w
                    })
                },
                N = {
                    a: O,
                    b: D,
                    bias: j,
                    preluActivationWeights: w
                },
                P = {
                    transposeA: h,
                    transposeB: f,
                    activation: M
                };
            if (null == m) {
                return (0, t.customGrad)((t, a, s) => {
                    const n = e.ENGINE.runKernelFunc(G, N, null, r._FusedMatMul, P);
                    return s([t, a, n]), {
                        value: (0, c.reshape)(n, E),
                        gradFunc: B
                    }
                })(O, D)
            }
            return (0, t.customGrad)((t, a, s, n) => {
                const u = e.ENGINE.runKernelFunc(G, N, null, r._FusedMatMul, P);
                return n([t, a, u, s]), {
                    value: (0, c.reshape)(u, E),
                    gradFunc: B
                }
            })(O, D, j)
        }
        const m = (0, p.op)({
            fusedMatMul_: f
        });
        exports.matMul = m;
    }, {
        "../engine": "Nc3Y",
        "../gradients": "yPDw",
        "../kernel_names": "sdEe",
        "../tensor_util": "fpST",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./broadcast_util": "Xh9J",
        "./fused_util": "mypO",
        "./mat_mul": "mMWq",
        "./operation": "JtaO",
        "./reshape": "QI4k"
    }],
    "nQCt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "conv2d", {
            enumerable: !0,
            get: function() {
                return e.conv2d
            }
        }), Object.defineProperty(exports, "depthwiseConv2d", {
            enumerable: !0,
            get: function() {
                return r.depthwiseConv2d
            }
        }), Object.defineProperty(exports, "matMul", {
            enumerable: !0,
            get: function() {
                return t.matMul
            }
        });
        var e = require("./fused_conv2d"),
            r = require("./fused_depthwise_conv2d"),
            t = require("./fused_mat_mul");
    }, {
        "./fused_conv2d": "C813",
        "./fused_depthwise_conv2d": "WUlv",
        "./fused_mat_mul": "zMsA"
    }],
    "OvUq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.hammingWindow = void 0;
        var e = require("../ops/operation"),
            o = require("./signal_ops_util");

        function i(e) {
            return (0, o.cosineWindow)(e, .54, .46)
        }
        const n = (0, e.op)({
            hammingWindow_: i
        });
        exports.hammingWindow = n;
    }, {
        "../ops/operation": "JtaO",
        "./signal_ops_util": "A6ms"
    }],
    "FQ37": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.hannWindow = void 0;
        var e = require("../ops/operation"),
            n = require("./signal_ops_util");

        function o(e) {
            return (0, n.cosineWindow)(e, .5, .5)
        }
        const i = (0, e.op)({
            hannWindow_: o
        });
        exports.hannWindow = i;
    }, {
        "../ops/operation": "JtaO",
        "./signal_ops_util": "A6ms"
    }],
    "XPcq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.frame = void 0;
        var e = require("../ops/operation"),
            r = require("./concat"),
            s = require("./fill"),
            o = require("./reshape"),
            t = require("./slice"),
            i = require("./tensor2d");

        function c(e, c, n, u = !1, l = 0) {
            let a = 0;
            const p = [];
            for (; a + c <= e.size;) p.push((0, t.slice)(e, a, c)), a += n;
            if (u)
                for (; a < e.size;) {
                    const o = a + c - e.size,
                        i = (0, r.concat)([(0, t.slice)(e, a, c - o), (0, s.fill)([o], l)]);
                    p.push(i), a += n
                }
            return 0 === p.length ? (0, i.tensor2d)([], [0, c]) : (0, o.reshape)((0, r.concat)(p), [p.length, c])
        }
        const n = (0, e.op)({
            frame_: c
        });
        exports.frame = n;
    }, {
        "../ops/operation": "JtaO",
        "./concat": "dDdq",
        "./fill": "e6pp",
        "./reshape": "QI4k",
        "./slice": "zP07",
        "./tensor2d": "WnBr"
    }],
    "yr5z": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.stft = void 0;
        var e = require("../ops/operation"),
            r = require("./concat"),
            t = require("./frame"),
            o = require("./hann_window"),
            i = require("./mul"),
            n = require("./rfft"),
            s = require("./signal_ops_util"),
            u = require("./slice");

        function f(e, f, c, l, a = o.hannWindow) {
            null == l && (l = (0, s.enclosingPowerOfTwo)(f));
            const p = (0, t.frame)(e, f, c),
                q = (0, i.mul)(p, a(f)),
                _ = [];
            for (let r = 0; r < p.shape[0]; r++) _.push((0, n.rfft)((0, u.slice)(q, [r, 0], [1, f]), l));
            return (0, r.concat)(_)
        }
        const c = (0, e.op)({
            stft_: f
        });
        exports.stft = c;
    }, {
        "../ops/operation": "JtaO",
        "./concat": "dDdq",
        "./frame": "XPcq",
        "./hann_window": "FQ37",
        "./mul": "k2PI",
        "./rfft": "WiyN",
        "./signal_ops_util": "A6ms",
        "./slice": "zP07"
    }],
    "iBUo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cropAndResize = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = i(require("../util")),
            o = require("./operation");

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = s();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, o, i) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }

        function a(o, s, i, a, u, p) {
            const c = (0, t.convertToTensor)(o, "image", "cropAndResize"),
                l = (0, t.convertToTensor)(s, "boxes", "cropAndResize", "float32"),
                b = (0, t.convertToTensor)(i, "boxInd", "cropAndResize", "int32");
            u = u || "bilinear", p = p || 0;
            const d = l.shape[0];
            n.assert(4 === c.rank, () => "Error in cropAndResize: image must be rank 4," + `but got rank ${c.rank}.`), n.assert(2 === l.rank && 4 === l.shape[1], () => `Error in cropAndResize: boxes must be have size [${d},4] ` + `but had shape ${l.shape}.`), n.assert(1 === b.rank && b.shape[0] === d, () => `Error in cropAndResize: boxInd must be have size [${d}] ` + `but had shape ${l.shape}.`), n.assert(2 === a.length, () => "Error in cropAndResize: cropSize must be of length 2, but got " + `length ${a.length}.`), n.assert(a[0] >= 1 && a[1] >= 1, () => `cropSize must be atleast [1,1], but was ${a}`), n.assert("bilinear" === u || "nearest" === u, () => `method must be bilinear or nearest, but was ${u}`);
            const f = {
                    image: c,
                    boxes: l,
                    boxInd: b
                },
                h = {
                    method: u,
                    extrapolationValue: p,
                    cropSize: a
                };
            return e.ENGINE.runKernelFunc(e => e.cropAndResize(c, l, b, a, u, p), f, null, r.CropAndResize, h)
        }
        const u = (0, o.op)({
            cropAndResize_: a
        });
        exports.cropAndResize = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "Cjsh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rotateWithOffset = void 0;
        var e = require("../engine"),
            t = require("../kernel_names"),
            r = require("../tensor_util_env"),
            n = a(require("../util")),
            o = require("./operation");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = i();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function f(o, i, a = 0, f = .5) {
            const u = (0, r.convertToTensor)(o, "image", "rotateWithOffset", "float32");
            n.assert(4 === u.rank, () => "Error in rotateWithOffset: image must be rank 4," + `but got rank ${u.rank}.`);
            const s = {
                    image: u
                },
                c = {
                    radians: i,
                    fillValue: a,
                    center: f
                };
            return e.ENGINE.runKernel(t.RotateWithOffset, s, c)
        }
        const u = (0, o.op)({
            rotateWithOffset_: f
        });
        exports.rotateWithOffset = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "Pk0Y": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppSanityCheck = s;
        var e = r(require("../util"));

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var s = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
                    o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = e[a]
                } return s.default = e, r && r.set(e, s), s
        }

        function s(t, r, s, n, a, o) {
            null == n && (n = .5), null == a && (a = Number.NEGATIVE_INFINITY), null == o && (o = 0);
            const u = t.shape[0];
            return s = Math.min(s, u), e.assert(0 <= n && n <= 1, () => `iouThreshold must be in [0, 1], but was '${n}'`), e.assert(2 === t.rank, () => `boxes must be a 2D tensor, but was of rank '${t.rank}'`), e.assert(4 === t.shape[1], () => `boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`), e.assert(1 === r.rank, () => "scores must be a 1D tensor"), e.assert(r.shape[0] === u, () => `scores has incompatible shape with boxes. Expected ${u}, ` + `but was ${r.shape[0]}`), e.assert(0 <= o && o <= 1, () => `softNmsSigma must be in [0, 1], but was '${o}'`), {
                maxOutputSize: s,
                iouThreshold: n,
                scoreThreshold: a,
                softNmsSigma: o
            }
        }
    }, {
        "../util": "P6nv"
    }],
    "GL9f": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppression = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            n = require("../tensor_util_env"),
            r = require("./nonmax_util"),
            s = require("./operation");

        function u(s, u, i, p = .5, t = Number.NEGATIVE_INFINITY) {
            const a = (0, n.convertToTensor)(s, "boxes", "nonMaxSuppression"),
                x = (0, n.convertToTensor)(u, "scores", "nonMaxSuppression"),
                c = (0, r.nonMaxSuppSanityCheck)(a, x, i, p, t);
            i = c.maxOutputSize, p = c.iouThreshold, t = c.scoreThreshold;
            const l = {
                maxOutputSize: i,
                iouThreshold: p,
                scoreThreshold: t
            };
            return e.ENGINE.runKernelFunc(e => e.nonMaxSuppression(a, x, i, p, t), {
                boxes: a,
                scores: x
            }, null, o.NonMaxSuppressionV3, l)
        }
        const i = (0, s.op)({
            nonMaxSuppression_: u
        });
        exports.nonMaxSuppression = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y",
        "./operation": "JtaO"
    }],
    "vhdJ": [function(require, module, exports) {
        "use strict";

        function e(e, n, r) {
            const o = t(e, n, r),
                c = o < 0 ? -(o + 1) : o;
            e.splice(c, 0, n)
        }

        function t(e, t, o) {
            return r(e, t, o || n)
        }

        function n(e, t) {
            return e > t ? 1 : e < t ? -1 : 0
        }

        function r(e, t, n) {
            let r = 0,
                o = e.length,
                c = 0,
                s = !1;
            for (; r < o;) {
                const u = n(t, e[c = r + (o - r >>> 1)]);
                u > 0 ? r = c + 1 : (o = c, s = !u)
            }
            return s ? r : -r - 1
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.binaryInsert = e, exports.binarySearch = t;
    }, {}],
    "zkpa": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionV3Impl = t, exports.nonMaxSuppressionV4Impl = s, exports.nonMaxSuppressionV5Impl = o;
        var e = require("../ops/scalar"),
            n = require("../ops/tensor1d"),
            r = require("./array_util");

        function t(e, n, r, t, s) {
            return a(e, n, r, t, s, 0).selectedIndices
        }

        function s(e, n, r, t, s, o) {
            return a(e, n, r, t, s, 0, !1, o, !0)
        }

        function o(e, n, r, t, s, o) {
            return a(e, n, r, t, s, o, !0)
        }

        function a(t, s, o, a, p, x, h = !1, l = !1, M = !1) {
            const d = [];
            for (let e = 0; e < s.length; e++) s[e] > p && d.push({
                score: s[e],
                boxIndex: e,
                suppressBeginIndex: 0
            });
            d.sort(u);
            const f = x > 0 ? -.5 / x : 0,
                m = [],
                I = [];
            for (; m.length < o && d.length > 0;) {
                const e = d.pop(),
                    {
                        score: n,
                        boxIndex: s,
                        suppressBeginIndex: o
                    } = e;
                if (n < p) break;
                let x = !1;
                for (let r = m.length - 1; r >= o; --r) {
                    const n = c(t, s, m[r]);
                    if (n >= a) {
                        x = !0;
                        break
                    }
                    if (e.score = e.score * i(a, f, n), e.score <= p) break
                }
                e.suppressBeginIndex = m.length, x || (e.score === n ? (m.push(s), I.push(e.score)) : e.score > p && (0, r.binaryInsert)(d, e, u))
            }
            const b = m.length,
                g = o - b;
            l && g > 0 && (m.push(...new Array(g).fill(0)), I.push(...new Array(g).fill(0)));
            const y = {
                selectedIndices: (0, n.tensor1d)(m, "int32")
            };
            return h && (y.selectedScores = (0, n.tensor1d)(I, "float32")), M && (y.validOutputs = (0, e.scalar)(b, "int32")), y
        }

        function c(e, n, r) {
            const t = e.subarray(4 * n, 4 * n + 4),
                s = e.subarray(4 * r, 4 * r + 4),
                o = Math.min(t[0], t[2]),
                a = Math.min(t[1], t[3]),
                c = Math.max(t[0], t[2]),
                i = Math.max(t[1], t[3]),
                u = Math.min(s[0], s[2]),
                p = Math.min(s[1], s[3]),
                x = Math.max(s[0], s[2]),
                h = Math.max(s[1], s[3]),
                l = (c - o) * (i - a),
                M = (x - u) * (h - p);
            if (l <= 0 || M <= 0) return 0;
            const d = Math.max(o, u),
                f = Math.max(a, p),
                m = Math.min(c, x),
                I = Math.min(i, h),
                b = Math.max(m - d, 0) * Math.max(I - f, 0);
            return b / (l + M - b)
        }

        function i(e, n, r) {
            const t = Math.exp(n * r * r);
            return r <= e ? t : 0
        }

        function u(e, n) {
            return e.score - n.score || e.score === n.score && n.boxIndex - e.boxIndex
        }
    }, {
        "../ops/scalar": "Ay42",
        "../ops/tensor1d": "pBg9",
        "./array_util": "vhdJ"
    }],
    "PetR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionAsync = void 0;
        var e = require("../backends/non_max_suppression_impl"),
            n = require("../tensor_util_env"),
            s = require("./nonmax_util");
        async function o(o, r, i, p = .5, t = Number.NEGATIVE_INFINITY) {
            const a = (0, n.convertToTensor)(o, "boxes", "nonMaxSuppressionAsync"),
                u = (0, n.convertToTensor)(r, "scores", "nonMaxSuppressionAsync"),
                c = (0, s.nonMaxSuppSanityCheck)(a, u, i, p, t);
            i = c.maxOutputSize, p = c.iouThreshold, t = c.scoreThreshold;
            const x = await Promise.all([a.data(), u.data()]),
                d = x[0],
                l = x[1],
                _ = (0, e.nonMaxSuppressionV3Impl)(d, l, i, p, t);
            return a !== o && a.dispose(), u !== r && u.dispose(), _
        }
        const r = o;
        exports.nonMaxSuppressionAsync = r;
    }, {
        "../backends/non_max_suppression_impl": "zkpa",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y"
    }],
    "gYwG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionWithScore = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            r = require("../tensor_util_env"),
            s = require("./nonmax_util"),
            n = require("./operation");

        function i(n, i, t, u = .5, p = Number.NEGATIVE_INFINITY, c = 0) {
            const a = (0, r.convertToTensor)(n, "boxes", "nonMaxSuppression"),
                S = (0, r.convertToTensor)(i, "scores", "nonMaxSuppression"),
                x = (0, s.nonMaxSuppSanityCheck)(a, S, t, u, p, c),
                h = {
                    boxes: a,
                    scores: S
                },
                l = {
                    maxOutputSize: t = x.maxOutputSize,
                    iouThreshold: u = x.iouThreshold,
                    scoreThreshold: p = x.scoreThreshold,
                    softNmsSigma: c = x.softNmsSigma
                },
                d = e.ENGINE.runKernel(o.NonMaxSuppressionV5, h, l);
            return {
                selectedIndices: d[0],
                selectedScores: d[1]
            }
        }
        const t = (0, n.op)({
            nonMaxSuppressionWithScore_: i
        });
        exports.nonMaxSuppressionWithScore = t;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y",
        "./operation": "JtaO"
    }],
    "ZdPq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionWithScoreAsync = void 0;
        var e = require("../backends/non_max_suppression_impl"),
            s = require("../tensor_util_env"),
            o = require("./nonmax_util");
        async function n(n, r, i, t = .5, p = Number.NEGATIVE_INFINITY, a = 0) {
            const u = (0, s.convertToTensor)(n, "boxes", "nonMaxSuppressionAsync"),
                c = (0, s.convertToTensor)(r, "scores", "nonMaxSuppressionAsync"),
                x = (0, o.nonMaxSuppSanityCheck)(u, c, i, t, p, a);
            i = x.maxOutputSize, t = x.iouThreshold, p = x.scoreThreshold, a = x.softNmsSigma;
            const S = await Promise.all([u.data(), c.data()]),
                d = S[0],
                l = S[1],
                m = (0, e.nonMaxSuppressionV5Impl)(d, l, i, t, p, a);
            return u !== n && u.dispose(), c !== r && c.dispose(), m
        }
        const r = n;
        exports.nonMaxSuppressionWithScoreAsync = r;
    }, {
        "../backends/non_max_suppression_impl": "zkpa",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y"
    }],
    "VtMO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionPadded = void 0;
        var e = require("../engine"),
            o = require("../kernel_names"),
            n = require("../tensor_util_env"),
            r = require("./nonmax_util"),
            s = require("./operation");

        function u(s, u, i, t = .5, p = Number.NEGATIVE_INFINITY, a = !1) {
            const d = (0, n.convertToTensor)(s, "boxes", "nonMaxSuppression"),
                x = (0, n.convertToTensor)(u, "scores", "nonMaxSuppression"),
                c = (0, r.nonMaxSuppSanityCheck)(d, x, i, t, p, null),
                l = {
                    boxes: d,
                    scores: x
                },
                S = {
                    maxOutputSize: c.maxOutputSize,
                    iouThreshold: c.iouThreshold,
                    scoreThreshold: c.scoreThreshold,
                    padToMaxOutputSize: a
                },
                T = e.ENGINE.runKernel(o.NonMaxSuppressionV4, l, S);
            return {
                selectedIndices: T[0],
                validOutputs: T[1]
            }
        }
        const i = (0, s.op)({
            nonMaxSuppressionPadded_: u
        });
        exports.nonMaxSuppressionPadded = i;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y",
        "./operation": "JtaO"
    }],
    "c7Zx": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionPaddedAsync = void 0;
        var e = require("../backends/non_max_suppression_impl"),
            n = require("../tensor_util_env"),
            s = require("./nonmax_util");
        async function o(o, r, a, i = .5, p = Number.NEGATIVE_INFINITY, t = !1) {
            const u = (0, n.convertToTensor)(o, "boxes", "nonMaxSuppressionAsync"),
                c = (0, n.convertToTensor)(r, "scores", "nonMaxSuppressionAsync"),
                d = (0, s.nonMaxSuppSanityCheck)(u, c, a, i, p, null),
                x = d.maxOutputSize,
                l = d.iouThreshold,
                _ = d.scoreThreshold,
                [S, T] = await Promise.all([u.data(), c.data()]),
                m = (0, e.nonMaxSuppressionV4Impl)(S, T, x, l, _, t);
            return u !== o && u.dispose(), c !== r && c.dispose(), m
        }
        const r = o;
        exports.nonMaxSuppressionPaddedAsync = r;
    }, {
        "../backends/non_max_suppression_impl": "zkpa",
        "../tensor_util_env": "c6yR",
        "./nonmax_util": "Pk0Y"
    }],
    "uhYK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resizeBilinear = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            n = require("../tensor_util_env"),
            t = s(require("../util")),
            i = require("./operation");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function s(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = a();
            if (r && r.has(e)) return r.get(e);
            var n = {},
                t = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = t ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = e[i]
                } return n.default = e, r && r.set(e, n), n
        }

        function o(i, a, s = !1) {
            const o = (0, n.convertToTensor)(i, "images", "resizeBilinear");
            t.assert(3 === o.rank || 4 === o.rank, () => "Error in resizeBilinear: x must be rank 3 or 4, but got " + `rank ${o.rank}.`), t.assert(2 === a.length, () => "Error in resizeBilinear: new shape must 2D, but got shape " + `${a}.`);
            let u = o,
                l = !1;
            3 === o.rank && (l = !0, u = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]));
            const [p, c] = a, f = {
                images: u
            }, g = {
                alignCorners: s,
                size: a
            }, h = e.ENGINE.runKernelFunc((e, r) => (r([u]), e.resizeBilinear(u, p, c, s)), f, null, r.ResizeBilinear, g);
            return l ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h
        }
        const u = (0, i.op)({
            resizeBilinear_: o
        });
        exports.resizeBilinear = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "OP6T": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resizeNearestNeighbor = void 0;
        var e = require("../engine"),
            r = require("../kernel_names"),
            t = require("../tensor_util_env"),
            n = a(require("../util")),
            s = require("./operation");

        function o() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return o = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = o();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, s) : null;
                    a && (a.get || a.set) ? Object.defineProperty(t, s, a) : t[s] = e[s]
                } return t.default = e, r && r.set(e, t), t
        }

        function i(s, o, a = !1) {
            const i = (0, t.convertToTensor)(s, "images", "resizeNearestNeighbor");
            n.assert(3 === i.rank || 4 === i.rank, () => "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " + `rank ${i.rank}.`), n.assert(2 === o.length, () => "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + `${o}.`), n.assert("float32" === i.dtype || "int32" === i.dtype, () => "`images` must have `int32` or `float32` as dtype");
            let u = i,
                p = !1;
            3 === i.rank && (p = !0, u = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));
            const [l, c] = o, f = {
                images: u
            }, g = {
                alignCorners: a,
                size: o
            }, h = e.ENGINE.runKernelFunc((e, r) => (r([u]), e.resizeNearestNeighbor(u, l, c, a)), f, null, r.ResizeNearestNeighbor, g);
            return p ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h
        }
        const u = (0, s.op)({
            resizeNearestNeighbor_: i
        });
        exports.resizeNearestNeighbor = u;
    }, {
        "../engine": "Nc3Y",
        "../kernel_names": "sdEe",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./operation": "JtaO"
    }],
    "NlFz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.bandPart = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            a = require("./greater_equal"),
            t = require("./less_equal"),
            n = require("./logical_and"),
            s = require("./operation"),
            u = require("./range"),
            o = require("./reshape"),
            i = require("./scalar"),
            l = require("./stack"),
            b = require("./sub"),
            c = require("./unstack"),
            p = require("./where"),
            q = require("./zeros");

        function d(s, d, g) {
            (0, r.assert)(d % 1 == 0, () => `bandPart(): numLower must be an integer, got ${d}.`), (0, r.assert)(g % 1 == 0, () => `bandPart(): numUpper must be an integer, got ${g}.`);
            const h = (0, e.convertToTensor)(s, "a", "bandPart");
            (0, r.assert)(h.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${h.rank}.`);
            const m = h.shape,
                [P, w] = h.shape.slice(-2);
            if (!(d <= P)) throw new Error(`bandPart(): numLower (${d})` + ` must not be greater than the number of rows (${P}).`);
            if (!(g <= w)) throw new Error(`bandPart(): numUpper (${g})` + ` must not be greater than the number of columns (${w}).`);
            d < 0 && (d = P), g < 0 && (g = w);
            const _ = (0, o.reshape)((0, u.range)(0, P, 1, "int32"), [-1, 1]),
                k = (0, u.range)(0, w, 1, "int32"),
                $ = (0, b.sub)(_, k),
                f = (0, n.logicalAnd)((0, t.lessEqual)($, (0, i.scalar)(+d, "int32")), (0, a.greaterEqual)($, (0, i.scalar)(-g, "int32"))),
                v = (0, q.zeros)([P, w], h.dtype);
            return (0, o.reshape)((0, l.stack)((0, c.unstack)((0, o.reshape)(h, [-1, P, w])).map(e => (0, p.where)(f, e, v))), m)
        }
        const g = (0, s.op)({
            bandPart_: d
        });
        exports.bandPart = g;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./greater_equal": "Dbo2",
        "./less_equal": "FvS1",
        "./logical_and": "lYzt",
        "./operation": "JtaO",
        "./range": "gc29",
        "./reshape": "QI4k",
        "./scalar": "Ay42",
        "./stack": "TWBn",
        "./sub": "dGex",
        "./unstack": "JDMu",
        "./where": "BsuI",
        "./zeros": "R5fo"
    }],
    "bcgP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.gramSchmidt = void 0;
        var e = require("../engine"),
            r = require("../util"),
            t = require("./div"),
            s = require("./mul"),
            i = require("./norm"),
            u = require("./operation"),
            n = require("./split"),
            o = require("./squeeze"),
            l = require("./stack"),
            m = require("./sub"),
            a = require("./sum");

        function c(u) {
            let c;
            if (Array.isArray(u)) {
                c = !1, (0, r.assert)(null != u && u.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
                const e = u[0].shape[0];
                for (let t = 1; t < u.length; ++t)(0, r.assert)(u[t].shape[0] === e, () => "Gram-Schmidt: Non-unique lengths found in the input vectors: " + `(${u[t].shape[0]} vs. ${e})`)
            } else c = !0, u = (0, n.split)(u, u.shape[0], 0).map(e => (0, o.squeeze)(e, [0]));
            (0, r.assert)(u.length <= u[0].shape[0], () => `Gram-Schmidt: Number of vectors (${u.length}) exceeds ` + `number of dimensions (${u[0].shape[0]}).`);
            const h = [],
                p = u;
            for (let r = 0; r < u.length; ++r) h.push(e.ENGINE.tidy(() => {
                let e = p[r];
                if (r > 0)
                    for (let t = 0; t < r; ++t) {
                        const r = (0, s.mul)((0, a.sum)((0, s.mul)(h[t], e)), h[t]);
                        e = (0, m.sub)(e, r)
                    }
                return (0, t.div)(e, (0, i.norm)(e, "euclidean"))
            }));
            return c ? (0, l.stack)(h, 0) : h
        }
        const h = (0, u.op)({
            gramSchmidt_: c
        });
        exports.gramSchmidt = h;
    }, {
        "../engine": "Nc3Y",
        "../util": "P6nv",
        "./div": "D8Fc",
        "./mul": "k2PI",
        "./norm": "Twvf",
        "./operation": "JtaO",
        "./split": "VA1I",
        "./squeeze": "ZVMV",
        "./stack": "TWBn",
        "./sub": "dGex",
        "./sum": "ITAy"
    }],
    "ybex": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.qr = void 0;
        var e = require("../engine"),
            r = require("../globals"),
            s = require("../util"),
            t = require("./clone"),
            u = require("./concat"),
            a = require("./div"),
            n = require("./eye"),
            i = require("./greater"),
            o = require("./mat_mul"),
            c = require("./mul"),
            l = require("./neg"),
            p = require("./norm"),
            h = require("./operation"),
            q = require("./reshape"),
            m = require("./slice"),
            d = require("./stack"),
            g = require("./sub"),
            b = require("./tensor2d"),
            k = require("./transpose"),
            M = require("./unstack"),
            f = require("./where");

        function v(e, r = !1) {
            if ((0, s.assert)(e.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`), 2 === e.rank) return y(e, r); {
                const s = e.shape.slice(0, e.shape.length - 2).reduce((e, r) => e * r),
                    t = (0, M.unstack)((0, q.reshape)(e, [s, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
                    u = [],
                    a = [];
                return t.forEach(e => {
                    const [s, t] = y(e, r);
                    u.push(s), a.push(t)
                }), [(0, q.reshape)((0, d.stack)(u, 0), e.shape), (0, q.reshape)((0, d.stack)(a, 0), e.shape)]
            }
        }

        function y(h, q = !1) {
            return e.ENGINE.tidy(() => {
                (0, s.assert)(2 === h.shape.length, () => `qr2d() requires a 2D Tensor, but got a ${h.shape.length}D Tensor.`);
                const d = h.shape[0],
                    M = h.shape[1];
                let v = (0, n.eye)(d),
                    y = (0, t.clone)(h);
                const E = (0, b.tensor2d)([
                    [1]
                ], [1, 1]);
                let N = (0, t.clone)(E);
                const _ = d >= M ? M : d;
                for (let s = 0; s < _; ++s) {
                    const n = y,
                        h = N,
                        q = v;
                    [N, y, v] = e.ENGINE.tidy(() => {
                        const e = (0, m.slice)(y, [s, s], [d - s, 1]),
                            r = (0, p.norm)(e),
                            n = (0, m.slice)(y, [s, s], [1, 1]),
                            h = (0, f.where)((0, i.greater)(n, 0), (0, b.tensor2d)([
                                [-1]
                            ]), (0, b.tensor2d)([
                                [1]
                            ])),
                            q = (0, g.sub)(n, (0, c.mul)(h, r)),
                            _ = (0, a.div)(e, q);
                        N = 1 === _.shape[0] ? (0, t.clone)(E) : (0, u.concat)([E, (0, m.slice)(_, [1, 0], [_.shape[0] - 1, _.shape[1]])], 0);
                        const x = (0, l.neg)((0, a.div)((0, o.matMul)(h, q), r)),
                            w = (0, m.slice)(y, [s, 0], [d - s, M]),
                            D = (0, c.mul)(x, N),
                            G = (0, k.transpose)(N);
                        if (0 === s) y = (0, g.sub)(w, (0, o.matMul)(D, (0, o.matMul)(G, w)));
                        else {
                            const e = (0, g.sub)(w, (0, o.matMul)(D, (0, o.matMul)(G, w)));
                            y = (0, u.concat)([(0, m.slice)(y, [0, 0], [s, M]), e], 0)
                        }
                        const I = (0, k.transpose)(D),
                            T = (0, m.slice)(v, [0, s], [d, v.shape[1] - s]);
                        if (0 === s) v = (0, g.sub)(T, (0, o.matMul)((0, o.matMul)(T, N), I));
                        else {
                            const e = (0, g.sub)(T, (0, o.matMul)((0, o.matMul)(T, N), I));
                            v = (0, u.concat)([(0, m.slice)(v, [0, 0], [d, s]), e], 1)
                        }
                        return [N, y, v]
                    }), (0, r.dispose)([n, h, q])
                }
                return !q && d > M && (v = (0, m.slice)(v, [0, 0], [d, M]), y = (0, m.slice)(y, [0, 0], [M, M])), [v, y]
            })
        }
        const E = (0, h.op)({
            qr_: v
        });
        exports.qr = E;
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../util": "P6nv",
        "./clone": "F06q",
        "./concat": "dDdq",
        "./div": "D8Fc",
        "./eye": "HzEj",
        "./greater": "QdS7",
        "./mat_mul": "mMWq",
        "./mul": "k2PI",
        "./neg": "iGYA",
        "./norm": "Twvf",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./slice": "zP07",
        "./stack": "TWBn",
        "./sub": "dGex",
        "./tensor2d": "WnBr",
        "./transpose": "uQkx",
        "./unstack": "JDMu",
        "./where": "BsuI"
    }],
    "LIoB": [function(require, module, exports) {
        "use strict";
        var e;
        Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Reduction = void 0, exports.Reduction = e,
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS"
            }(e || (exports.Reduction = e = {}));
    }, {}],
    "eNIu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.computeWeightedLoss = void 0;
        var e = require("../tensor_util_env"),
            r = require("./cast"),
            s = require("./div"),
            u = require("./loss_ops_utils"),
            o = require("./mean"),
            t = require("./mul"),
            i = require("./not_equal"),
            n = require("./ones"),
            c = require("./operation"),
            l = require("./scalar"),
            a = require("./sum");

        function d(c, d, m = u.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const _ = (0, e.convertToTensor)(c, "losses", "computeWeightedLoss");
            let p = null;
            null != d && (p = (0, e.convertToTensor)(d, "weights", "computeWeightedLoss"));
            const q = null == p ? _ : (0, t.mul)(_, p);
            if (m === u.Reduction.NONE) return q;
            if (m === u.Reduction.SUM) return (0, a.sum)(q);
            if (m === u.Reduction.MEAN) {
                if (null == p) return (0, o.mean)(q); {
                    const e = _.size / p.size,
                        r = (0, s.div)((0, a.sum)(q), (0, a.sum)(p));
                    return e > 1 ? (0, s.div)(r, (0, l.scalar)(e)) : r
                }
            }
            if (m === u.Reduction.SUM_BY_NONZERO_WEIGHTS) {
                if (null == p) return (0, s.div)((0, a.sum)(q), (0, l.scalar)(_.size)); {
                    const e = (0, t.mul)(p, (0, n.ones)(_.shape)),
                        u = (0, r.cast)((0, a.sum)((0, i.notEqual)(e, (0, l.scalar)(0))), "float32");
                    return (0, s.div)((0, a.sum)(q), u)
                }
            }
            throw Error(`Unknown reduction: ${m}`)
        }
        const m = (0, c.op)({
            computeWeightedLoss_: d
        });
        exports.computeWeightedLoss = m;
    }, {
        "../tensor_util_env": "c6yR",
        "./cast": "qqq3",
        "./div": "D8Fc",
        "./loss_ops_utils": "LIoB",
        "./mean": "jwZo",
        "./mul": "k2PI",
        "./not_equal": "jVu5",
        "./ones": "POxQ",
        "./operation": "JtaO",
        "./scalar": "Ay42",
        "./sum": "ITAy"
    }],
    "GZvF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.absoluteDifference = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            s = require("./abs"),
            o = require("./compute_weighted_loss"),
            t = require("./loss_ops_utils"),
            i = require("./operation"),
            u = require("./sub");

        function n(i, n, c, l = t.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const a = (0, e.convertToTensor)(i, "labels", "absoluteDifference"),
                f = (0, e.convertToTensor)(n, "predictions", "absoluteDifference");
            let b = null;
            null != c && (b = (0, e.convertToTensor)(c, "weights", "absoluteDifference")), (0, r.assertShapesMatch)(a.shape, f.shape, "Error in absoluteDifference: ");
            const p = (0, s.abs)((0, u.sub)(a, f));
            return (0, o.computeWeightedLoss)(p, b, l)
        }
        const c = (0, i.op)({
            absoluteDifference_: n
        });
        exports.absoluteDifference = c;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./abs": "aE3W",
        "./compute_weighted_loss": "eNIu",
        "./loss_ops_utils": "LIoB",
        "./operation": "JtaO",
        "./sub": "dGex"
    }],
    "NDqm": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cosineDistance = void 0;
        var e = require("../tensor_util_env"),
            s = require("../util"),
            r = require("./compute_weighted_loss"),
            o = require("./loss_ops_utils"),
            i = require("./mul"),
            t = require("./operation"),
            n = require("./scalar"),
            c = require("./sub"),
            u = require("./sum");

        function a(t, a, l, p, _ = o.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const q = (0, e.convertToTensor)(t, "labels", "cosineDistance"),
                d = (0, e.convertToTensor)(a, "predictions", "cosineDistance");
            let h = null;
            null != p && (h = (0, e.convertToTensor)(p, "weights", "cosineDistance")), (0, s.assertShapesMatch)(q.shape, d.shape, "Error in cosineDistance: ");
            const v = (0, n.scalar)(1),
                D = (0, c.sub)(v, (0, u.sum)((0, i.mul)(q, d), l, !0));
            return (0, r.computeWeightedLoss)(D, h, _)
        }
        const l = (0, t.op)({
            cosineDistance_: a
        });
        exports.cosineDistance = l;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./compute_weighted_loss": "eNIu",
        "./loss_ops_utils": "LIoB",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./scalar": "Ay42",
        "./sub": "dGex",
        "./sum": "ITAy"
    }],
    "lWDW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.hingeLoss = void 0;
        var e = require("../tensor_util_env"),
            s = require("../util"),
            r = require("./compute_weighted_loss"),
            o = require("./loss_ops_utils"),
            t = require("./mul"),
            i = require("./operation"),
            u = require("./relu"),
            n = require("./scalar"),
            l = require("./sub");

        function c(i, c, a, h = o.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            let p = (0, e.convertToTensor)(i, "labels", "hingeLoss");
            const _ = (0, e.convertToTensor)(c, "predictions", "hingeLoss");
            let g = null;
            null != a && (g = (0, e.convertToTensor)(a, "weights", "hingeLoss")), (0, s.assertShapesMatch)(p.shape, _.shape, "Error in hingeLoss: ");
            const q = (0, n.scalar)(1);
            p = (0, l.sub)((0, t.mul)((0, n.scalar)(2), p), q);
            const L = (0, u.relu)((0, l.sub)(q, (0, t.mul)(p, _)));
            return (0, r.computeWeightedLoss)(L, g, h)
        }
        const a = (0, i.op)({
            hingeLoss_: c
        });
        exports.hingeLoss = a;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./compute_weighted_loss": "eNIu",
        "./loss_ops_utils": "LIoB",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./relu": "SJP3",
        "./scalar": "Ay42",
        "./sub": "dGex"
    }],
    "hI9K": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.huberLoss = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            s = require("./abs"),
            u = require("./add"),
            o = require("./compute_weighted_loss"),
            i = require("./loss_ops_utils"),
            t = require("./minimum"),
            n = require("./mul"),
            a = require("./operation"),
            l = require("./scalar"),
            c = require("./square"),
            b = require("./sub");

        function h(a, h, q, p = 1, _ = i.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const d = (0, e.convertToTensor)(a, "labels", "huberLoss"),
                m = (0, e.convertToTensor)(h, "predictions", "huberLoss");
            let L = null;
            null != q && (L = (0, e.convertToTensor)(q, "weights", "huberLoss")), (0, r.assertShapesMatch)(d.shape, m.shape, "Error in huberLoss: ");
            const v = (0, l.scalar)(p),
                T = (0, s.abs)((0, b.sub)(m, d)),
                g = (0, t.minimum)(T, v),
                x = (0, b.sub)(T, g),
                E = (0, u.add)((0, n.mul)((0, l.scalar)(.5), (0, c.square)(g)), (0, n.mul)(v, x));
            return (0, o.computeWeightedLoss)(E, L, _)
        }
        const q = (0, a.op)({
            huberLoss_: h
        });
        exports.huberLoss = q;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./abs": "aE3W",
        "./add": "ZDFV",
        "./compute_weighted_loss": "eNIu",
        "./loss_ops_utils": "LIoB",
        "./minimum": "crIr",
        "./mul": "k2PI",
        "./operation": "JtaO",
        "./scalar": "Ay42",
        "./square": "mJRX",
        "./sub": "dGex"
    }],
    "gQUw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.logLoss = void 0;
        var e = require("../tensor_util_env"),
            s = require("../util"),
            o = require("./add"),
            r = require("./compute_weighted_loss"),
            u = require("./log"),
            l = require("./loss_ops_utils"),
            t = require("./mul"),
            i = require("./neg"),
            n = require("./operation"),
            a = require("./scalar"),
            c = require("./sub");

        function g(n, g, d, p = 1e-7, _ = l.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const q = (0, e.convertToTensor)(n, "labels", "logLoss"),
                L = (0, e.convertToTensor)(g, "predictions", "logLoss");
            let h = null;
            null != d && (h = (0, e.convertToTensor)(d, "weights", "logLoss")), (0, s.assertShapesMatch)(q.shape, L.shape, "Error in logLoss: ");
            const v = (0, a.scalar)(1),
                T = (0, a.scalar)(p),
                b = (0, i.neg)((0, t.mul)(q, (0, u.log)((0, o.add)(L, T)))),
                m = (0, t.mul)((0, c.sub)(v, q), (0, u.log)((0, o.add)((0, c.sub)(v, L), T))),
                x = (0, c.sub)(b, m);
            return (0, r.computeWeightedLoss)(x, h, _)
        }
        const d = (0, n.op)({
            logLoss_: g
        });
        exports.logLoss = d;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./compute_weighted_loss": "eNIu",
        "./log": "vwHA",
        "./loss_ops_utils": "LIoB",
        "./mul": "k2PI",
        "./neg": "iGYA",
        "./operation": "JtaO",
        "./scalar": "Ay42",
        "./sub": "dGex"
    }],
    "n674": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.meanSquaredError = void 0;
        var e = require("../tensor_util_env"),
            r = require("../util"),
            o = require("./compute_weighted_loss"),
            s = require("./loss_ops_utils"),
            n = require("./operation"),
            t = require("./squared_difference");

        function u(n, u, a, i = s.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            const d = (0, e.convertToTensor)(n, "labels", "meanSquaredError"),
                c = (0, e.convertToTensor)(u, "predictions", "meanSquaredError");
            let q = null;
            null != a && (q = (0, e.convertToTensor)(a, "weights", "meanSquaredError")), (0, r.assertShapesMatch)(d.shape, c.shape, "Error in meanSquaredError: ");
            const l = (0, t.squaredDifference)(d, c);
            return (0, o.computeWeightedLoss)(l, q, i)
        }
        const a = (0, n.op)({
            meanSquaredError_: u
        });
        exports.meanSquaredError = a;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./compute_weighted_loss": "eNIu",
        "./loss_ops_utils": "LIoB",
        "./operation": "JtaO",
        "./squared_difference": "gsmP"
    }],
    "rKBl": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.sigmoidCrossEntropy = void 0;
        var r = require("../tensor_util_env"),
            s = require("../util"),
            e = require("./abs"),
            o = require("./add"),
            i = require("./compute_weighted_loss"),
            t = require("./exp"),
            n = require("./log1p"),
            u = require("./loss_ops_utils"),
            l = require("./mul"),
            a = require("./neg"),
            p = require("./operation"),
            c = require("./relu"),
            d = require("./scalar"),
            g = require("./sub");

        function m(i, u) {
            const p = (0, r.convertToTensor)(i, "labels", "sigmoidCrossEntropyWithLogits"),
                d = (0, r.convertToTensor)(u, "logits", "sigmoidCrossEntropyWithLogits");
            (0, s.assertShapesMatch)(p.shape, d.shape, "Error in sigmoidCrossEntropyWithLogits: ");
            const m = (0, c.relu)(d),
                h = (0, l.mul)(d, p),
                q = (0, n.log1p)((0, t.exp)((0, a.neg)((0, e.abs)(d))));
            return (0, o.add)((0, g.sub)(m, h), q)
        }

        function h(e, t, n, a = 0, p = u.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            let c = (0, r.convertToTensor)(e, "multiClassLabels", "sigmoidCrossEntropy");
            const h = (0, r.convertToTensor)(t, "logits", "sigmoidCrossEntropy");
            let q = null;
            if (null != n && (q = (0, r.convertToTensor)(n, "weights", "sigmoidCrossEntropy")), (0, s.assertShapesMatch)(c.shape, h.shape, "Error in sigmoidCrossEntropy: "), a > 0) {
                const r = (0, d.scalar)(a),
                    s = (0, d.scalar)(1),
                    e = (0, d.scalar)(.5);
                c = (0, o.add)((0, l.mul)(c, (0, g.sub)(s, r)), (0, l.mul)(e, r))
            }
            const E = m(c, h);
            return (0, i.computeWeightedLoss)(E, q, p)
        }
        const q = (0, p.op)({
            sigmoidCrossEntropy_: h
        });
        exports.sigmoidCrossEntropy = q;
    }, {
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./abs": "aE3W",
        "./add": "ZDFV",
        "./compute_weighted_loss": "eNIu",
        "./exp": "zsk9",
        "./log1p": "PxfL",
        "./loss_ops_utils": "LIoB",
        "./mul": "k2PI",
        "./neg": "iGYA",
        "./operation": "JtaO",
        "./relu": "SJP3",
        "./scalar": "Ay42",
        "./sub": "dGex"
    }],
    "F041": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.softmaxCrossEntropy = void 0;
        var e = require("../gradients"),
            r = require("../tensor_util_env"),
            s = require("../util"),
            o = require("./add"),
            t = require("./axis_util"),
            a = require("./cast"),
            n = require("./compute_weighted_loss"),
            u = require("./div"),
            i = require("./exp"),
            l = require("./log_sum_exp"),
            p = require("./loss_ops_utils"),
            c = require("./mul"),
            m = require("./neg"),
            d = require("./operation"),
            q = require("./reshape"),
            x = require("./scalar"),
            f = require("./sub"),
            h = require("./sum");

        function _(r, s, o = -1) {
            if (-1 === o && (o = s.rank - 1), o !== s.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet " + `supported. Labels / logits was rank ${s.rank} ` + `and dim was ${o}`);
            return (0, e.customGrad)((e, r, s) => {
                const n = (0, l.logSumExp)(r, [o], !0),
                    u = (0, f.sub)((0, a.cast)(r, "float32"), n);
                s([e, u]);
                const p = (0, m.neg)((0, c.mul)(u, e));
                return {
                    value: (0, h.sum)(p, [o]),
                    gradFunc: (e, r) => {
                        const [s, n] = r, u = (0, t.expandShapeToKeepDim)(e.shape, [o]);
                        return [(0, c.mul)((0, q.reshape)(e, u), (0, f.sub)((0, a.cast)(s, "float32"), (0, i.exp)(n))), (0, c.mul)((0, q.reshape)(e, u), (0, f.sub)((0, i.exp)(n), (0, a.cast)(s, "float32")))]
                    }
                }
            })(r, s)
        }

        function g(e, t, a, i = 0, l = p.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            let m = (0, r.convertToTensor)(e, "onehotLabels", "softmaxCrossEntropy");
            const d = (0, r.convertToTensor)(t, "logits", "softmaxCrossEntropy");
            let q = null;
            if (null != a && (q = (0, r.convertToTensor)(a, "weights", "softmaxCrossEntropy")), (0, s.assertShapesMatch)(m.shape, d.shape, "Error in softmaxCrossEntropy: "), i > 0) {
                const e = (0, x.scalar)(i),
                    r = (0, x.scalar)(1),
                    s = (0, x.scalar)(m.shape[1]);
                m = (0, o.add)((0, c.mul)(m, (0, f.sub)(r, e)), (0, u.div)(e, s))
            }
            const h = _(m, d);
            return (0, n.computeWeightedLoss)(h, q, l)
        }
        const E = (0, d.op)({
            softmaxCrossEntropy_: g
        });
        exports.softmaxCrossEntropy = E;
    }, {
        "../gradients": "yPDw",
        "../tensor_util_env": "c6yR",
        "../util": "P6nv",
        "./add": "ZDFV",
        "./axis_util": "DsMP",
        "./cast": "qqq3",
        "./compute_weighted_loss": "eNIu",
        "./div": "D8Fc",
        "./exp": "zsk9",
        "./log_sum_exp": "MQ55",
        "./loss_ops_utils": "LIoB",
        "./mul": "k2PI",
        "./neg": "iGYA",
        "./operation": "JtaO",
        "./reshape": "QI4k",
        "./scalar": "Ay42",
        "./sub": "dGex",
        "./sum": "ITAy"
    }],
    "R1mJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var e = {
            image: !0,
            linalg: !0,
            losses: !0,
            spectral: !0,
            signal: !0,
            abs: !0,
            acos: !0,
            acosh: !0,
            add: !0,
            addN: !0,
            all: !0,
            any: !0,
            argMax: !0,
            argMin: !0,
            asin: !0,
            asinh: !0,
            atan: !0,
            atan2: !0,
            atanh: !0,
            avgPool: !0,
            avgPool3d: !0,
            basicLSTMCell: !0,
            batchToSpaceND: !0,
            batchNorm: !0,
            batchNorm2d: !0,
            batchNorm3d: !0,
            batchNorm4d: !0,
            broadcastTo: !0,
            buffer: !0,
            cast: !0,
            ceil: !0,
            clipByValue: !0,
            clone: !0,
            complex: !0,
            concat: !0,
            concat1d: !0,
            concat2d: !0,
            concat3d: !0,
            concat4d: !0,
            conv1d: !0,
            conv2d: !0,
            conv2dTranspose: !0,
            conv3d: !0,
            conv3dTranspose: !0,
            cos: !0,
            cosh: !0,
            cumsum: !0,
            depthToSpace: !0,
            depthwiseConv2d: !0,
            diag: !0,
            dilation2d: !0,
            div: !0,
            divNoNan: !0,
            dot: !0,
            elu: !0,
            equal: !0,
            erf: !0,
            exp: !0,
            expandDims: !0,
            expm1: !0,
            eye: !0,
            fft: !0,
            fill: !0,
            floor: !0,
            floorDiv: !0,
            gather: !0,
            greater: !0,
            greaterEqual: !0,
            ifft: !0,
            imag: !0,
            irfft: !0,
            isFinite: !0,
            isInf: !0,
            isNaN: !0,
            leakyRelu: !0,
            less: !0,
            lessEqual: !0,
            linspace: !0,
            localResponseNormalization: !0,
            log: !0,
            log1p: !0,
            logSigmoid: !0,
            logSoftmax: !0,
            logSumExp: !0,
            logicalAnd: !0,
            logicalNot: !0,
            logicalOr: !0,
            logicalXor: !0,
            matMul: !0,
            max: !0,
            maxPool: !0,
            maxPool3d: !0,
            maxPoolWithArgmax: !0,
            maximum: !0,
            mean: !0,
            min: !0,
            minimum: !0,
            mod: !0,
            moments: !0,
            mul: !0,
            multiRNNCell: !0,
            multinomial: !0,
            neg: !0,
            notEqual: !0,
            oneHot: !0,
            ones: !0,
            onesLike: !0,
            outerProduct: !0,
            pad: !0,
            pad1d: !0,
            pad2d: !0,
            pad3d: !0,
            pad4d: !0,
            pool: !0,
            pow: !0,
            prelu: !0,
            print: !0,
            prod: !0,
            rand: !0,
            randomGamma: !0,
            randomNormal: !0,
            randomUniform: !0,
            range: !0,
            real: !0,
            reciprocal: !0,
            relu: !0,
            relu6: !0,
            reshape: !0,
            reverse: !0,
            reverse1d: !0,
            reverse2d: !0,
            reverse3d: !0,
            reverse4d: !0,
            rfft: !0,
            round: !0,
            rsqrt: !0,
            scalar: !0,
            selu: !0,
            separableConv2d: !0,
            setdiff1dAsync: !0,
            sigmoid: !0,
            sign: !0,
            sin: !0,
            sinh: !0,
            slice: !0,
            slice1d: !0,
            slice2d: !0,
            slice3d: !0,
            slice4d: !0,
            softmax: !0,
            softplus: !0,
            spaceToBatchND: !0,
            split: !0,
            sqrt: !0,
            square: !0,
            squaredDifference: !0,
            squeeze: !0,
            stack: !0,
            step: !0,
            stridedSlice: !0,
            sub: !0,
            sum: !0,
            tan: !0,
            tanh: !0,
            tensor: !0,
            tensor1d: !0,
            tensor2d: !0,
            tensor3d: !0,
            tensor4d: !0,
            tensor5d: !0,
            tensor6d: !0,
            tile: !0,
            topk: !0,
            truncatedNormal: !0,
            unsortedSegmentSum: !0,
            unstack: !0,
            variable: !0,
            where: !0,
            whereAsync: !0,
            zeros: !0,
            zerosLike: !0,
            op: !0,
            fused: !0
        };
        Object.defineProperty(exports, "abs", {
            enumerable: !0,
            get: function() {
                return r.abs
            }
        }), Object.defineProperty(exports, "acos", {
            enumerable: !0,
            get: function() {
                return t.acos
            }
        }), Object.defineProperty(exports, "acosh", {
            enumerable: !0,
            get: function() {
                return n.acosh
            }
        }), Object.defineProperty(exports, "add", {
            enumerable: !0,
            get: function() {
                return o.add
            }
        }), Object.defineProperty(exports, "addN", {
            enumerable: !0,
            get: function() {
                return u.addN
            }
        }), Object.defineProperty(exports, "all", {
            enumerable: !0,
            get: function() {
                return i.all
            }
        }), Object.defineProperty(exports, "any", {
            enumerable: !0,
            get: function() {
                return a.any
            }
        }), Object.defineProperty(exports, "argMax", {
            enumerable: !0,
            get: function() {
                return c.argMax
            }
        }), Object.defineProperty(exports, "argMin", {
            enumerable: !0,
            get: function() {
                return s.argMin
            }
        }), Object.defineProperty(exports, "asin", {
            enumerable: !0,
            get: function() {
                return p.asin
            }
        }), Object.defineProperty(exports, "asinh", {
            enumerable: !0,
            get: function() {
                return l.asinh
            }
        }), Object.defineProperty(exports, "atan", {
            enumerable: !0,
            get: function() {
                return f.atan
            }
        }), Object.defineProperty(exports, "atan2", {
            enumerable: !0,
            get: function() {
                return d.atan2
            }
        }), Object.defineProperty(exports, "atanh", {
            enumerable: !0,
            get: function() {
                return b.atanh
            }
        }), Object.defineProperty(exports, "avgPool", {
            enumerable: !0,
            get: function() {
                return m.avgPool
            }
        }), Object.defineProperty(exports, "avgPool3d", {
            enumerable: !0,
            get: function() {
                return g.avgPool3d
            }
        }), Object.defineProperty(exports, "basicLSTMCell", {
            enumerable: !0,
            get: function() {
                return x.basicLSTMCell
            }
        }), Object.defineProperty(exports, "batchToSpaceND", {
            enumerable: !0,
            get: function() {
                return y.batchToSpaceND
            }
        }), Object.defineProperty(exports, "batchNorm", {
            enumerable: !0,
            get: function() {
                return q.batchNorm
            }
        }), Object.defineProperty(exports, "batchNorm2d", {
            enumerable: !0,
            get: function() {
                return O.batchNorm2d
            }
        }), Object.defineProperty(exports, "batchNorm3d", {
            enumerable: !0,
            get: function() {
                return P.batchNorm3d
            }
        }), Object.defineProperty(exports, "batchNorm4d", {
            enumerable: !0,
            get: function() {
                return j.batchNorm4d
            }
        }), Object.defineProperty(exports, "broadcastTo", {
            enumerable: !0,
            get: function() {
                return _.broadcastTo
            }
        }), Object.defineProperty(exports, "buffer", {
            enumerable: !0,
            get: function() {
                return h.buffer
            }
        }), Object.defineProperty(exports, "cast", {
            enumerable: !0,
            get: function() {
                return v.cast
            }
        }), Object.defineProperty(exports, "ceil", {
            enumerable: !0,
            get: function() {
                return N.ceil
            }
        }), Object.defineProperty(exports, "clipByValue", {
            enumerable: !0,
            get: function() {
                return S.clipByValue
            }
        }), Object.defineProperty(exports, "clone", {
            enumerable: !0,
            get: function() {
                return w.clone
            }
        }), Object.defineProperty(exports, "complex", {
            enumerable: !0,
            get: function() {
                return k.complex
            }
        }), Object.defineProperty(exports, "concat", {
            enumerable: !0,
            get: function() {
                return M.concat
            }
        }), Object.defineProperty(exports, "concat1d", {
            enumerable: !0,
            get: function() {
                return E.concat1d
            }
        }), Object.defineProperty(exports, "concat2d", {
            enumerable: !0,
            get: function() {
                return z.concat2d
            }
        }), Object.defineProperty(exports, "concat3d", {
            enumerable: !0,
            get: function() {
                return D.concat3d
            }
        }), Object.defineProperty(exports, "concat4d", {
            enumerable: !0,
            get: function() {
                return T.concat4d
            }
        }), Object.defineProperty(exports, "conv1d", {
            enumerable: !0,
            get: function() {
                return A.conv1d
            }
        }), Object.defineProperty(exports, "conv2d", {
            enumerable: !0,
            get: function() {
                return L.conv2d
            }
        }), Object.defineProperty(exports, "conv2dTranspose", {
            enumerable: !0,
            get: function() {
                return W.conv2dTranspose
            }
        }), Object.defineProperty(exports, "conv3d", {
            enumerable: !0,
            get: function() {
                return C.conv3d
            }
        }), Object.defineProperty(exports, "conv3dTranspose", {
            enumerable: !0,
            get: function() {
                return R.conv3dTranspose
            }
        }), Object.defineProperty(exports, "cos", {
            enumerable: !0,
            get: function() {
                return B.cos
            }
        }), Object.defineProperty(exports, "cosh", {
            enumerable: !0,
            get: function() {
                return F.cosh
            }
        }), Object.defineProperty(exports, "cumsum", {
            enumerable: !0,
            get: function() {
                return G.cumsum
            }
        }), Object.defineProperty(exports, "depthToSpace", {
            enumerable: !0,
            get: function() {
                return H.depthToSpace
            }
        }), Object.defineProperty(exports, "depthwiseConv2d", {
            enumerable: !0,
            get: function() {
                return I.depthwiseConv2d
            }
        }), Object.defineProperty(exports, "diag", {
            enumerable: !0,
            get: function() {
                return U.diag
            }
        }), Object.defineProperty(exports, "dilation2d", {
            enumerable: !0,
            get: function() {
                return V.dilation2d
            }
        }), Object.defineProperty(exports, "div", {
            enumerable: !0,
            get: function() {
                return X.div
            }
        }), Object.defineProperty(exports, "divNoNan", {
            enumerable: !0,
            get: function() {
                return J.divNoNan
            }
        }), Object.defineProperty(exports, "dot", {
            enumerable: !0,
            get: function() {
                return K.dot
            }
        }), Object.defineProperty(exports, "elu", {
            enumerable: !0,
            get: function() {
                return Q.elu
            }
        }), Object.defineProperty(exports, "equal", {
            enumerable: !0,
            get: function() {
                return Y.equal
            }
        }), Object.defineProperty(exports, "erf", {
            enumerable: !0,
            get: function() {
                return Z.erf
            }
        }), Object.defineProperty(exports, "exp", {
            enumerable: !0,
            get: function() {
                return $.exp
            }
        }), Object.defineProperty(exports, "expandDims", {
            enumerable: !0,
            get: function() {
                return ee.expandDims
            }
        }), Object.defineProperty(exports, "expm1", {
            enumerable: !0,
            get: function() {
                return re.expm1
            }
        }), Object.defineProperty(exports, "eye", {
            enumerable: !0,
            get: function() {
                return te.eye
            }
        }), Object.defineProperty(exports, "fft", {
            enumerable: !0,
            get: function() {
                return ne.fft
            }
        }), Object.defineProperty(exports, "fill", {
            enumerable: !0,
            get: function() {
                return oe.fill
            }
        }), Object.defineProperty(exports, "floor", {
            enumerable: !0,
            get: function() {
                return ue.floor
            }
        }), Object.defineProperty(exports, "floorDiv", {
            enumerable: !0,
            get: function() {
                return ie.floorDiv
            }
        }), Object.defineProperty(exports, "gather", {
            enumerable: !0,
            get: function() {
                return ae.gather
            }
        }), Object.defineProperty(exports, "greater", {
            enumerable: !0,
            get: function() {
                return ce.greater
            }
        }), Object.defineProperty(exports, "greaterEqual", {
            enumerable: !0,
            get: function() {
                return se.greaterEqual
            }
        }), Object.defineProperty(exports, "ifft", {
            enumerable: !0,
            get: function() {
                return pe.ifft
            }
        }), Object.defineProperty(exports, "imag", {
            enumerable: !0,
            get: function() {
                return le.imag
            }
        }), Object.defineProperty(exports, "irfft", {
            enumerable: !0,
            get: function() {
                return fe.irfft
            }
        }), Object.defineProperty(exports, "isFinite", {
            enumerable: !0,
            get: function() {
                return de.isFinite
            }
        }), Object.defineProperty(exports, "isInf", {
            enumerable: !0,
            get: function() {
                return be.isInf
            }
        }), Object.defineProperty(exports, "isNaN", {
            enumerable: !0,
            get: function() {
                return me.isNaN
            }
        }), Object.defineProperty(exports, "leakyRelu", {
            enumerable: !0,
            get: function() {
                return ge.leakyRelu
            }
        }), Object.defineProperty(exports, "less", {
            enumerable: !0,
            get: function() {
                return xe.less
            }
        }), Object.defineProperty(exports, "lessEqual", {
            enumerable: !0,
            get: function() {
                return ye.lessEqual
            }
        }), Object.defineProperty(exports, "linspace", {
            enumerable: !0,
            get: function() {
                return qe.linspace
            }
        }), Object.defineProperty(exports, "localResponseNormalization", {
            enumerable: !0,
            get: function() {
                return Oe.localResponseNormalization
            }
        }), Object.defineProperty(exports, "log", {
            enumerable: !0,
            get: function() {
                return Pe.log
            }
        }), Object.defineProperty(exports, "log1p", {
            enumerable: !0,
            get: function() {
                return je.log1p
            }
        }), Object.defineProperty(exports, "logSigmoid", {
            enumerable: !0,
            get: function() {
                return _e.logSigmoid
            }
        }), Object.defineProperty(exports, "logSoftmax", {
            enumerable: !0,
            get: function() {
                return he.logSoftmax
            }
        }), Object.defineProperty(exports, "logSumExp", {
            enumerable: !0,
            get: function() {
                return ve.logSumExp
            }
        }), Object.defineProperty(exports, "logicalAnd", {
            enumerable: !0,
            get: function() {
                return Ne.logicalAnd
            }
        }), Object.defineProperty(exports, "logicalNot", {
            enumerable: !0,
            get: function() {
                return Se.logicalNot
            }
        }), Object.defineProperty(exports, "logicalOr", {
            enumerable: !0,
            get: function() {
                return we.logicalOr
            }
        }), Object.defineProperty(exports, "logicalXor", {
            enumerable: !0,
            get: function() {
                return ke.logicalXor
            }
        }), Object.defineProperty(exports, "matMul", {
            enumerable: !0,
            get: function() {
                return Me.matMul
            }
        }), Object.defineProperty(exports, "max", {
            enumerable: !0,
            get: function() {
                return Ee.max
            }
        }), Object.defineProperty(exports, "maxPool", {
            enumerable: !0,
            get: function() {
                return ze.maxPool
            }
        }), Object.defineProperty(exports, "maxPool3d", {
            enumerable: !0,
            get: function() {
                return De.maxPool3d
            }
        }), Object.defineProperty(exports, "maxPoolWithArgmax", {
            enumerable: !0,
            get: function() {
                return Te.maxPoolWithArgmax
            }
        }), Object.defineProperty(exports, "maximum", {
            enumerable: !0,
            get: function() {
                return Ae.maximum
            }
        }), Object.defineProperty(exports, "mean", {
            enumerable: !0,
            get: function() {
                return Le.mean
            }
        }), Object.defineProperty(exports, "min", {
            enumerable: !0,
            get: function() {
                return We.min
            }
        }), Object.defineProperty(exports, "minimum", {
            enumerable: !0,
            get: function() {
                return Ce.minimum
            }
        }), Object.defineProperty(exports, "mod", {
            enumerable: !0,
            get: function() {
                return Re.mod
            }
        }), Object.defineProperty(exports, "moments", {
            enumerable: !0,
            get: function() {
                return Be.moments
            }
        }), Object.defineProperty(exports, "mul", {
            enumerable: !0,
            get: function() {
                return Fe.mul
            }
        }), Object.defineProperty(exports, "multiRNNCell", {
            enumerable: !0,
            get: function() {
                return Ge.multiRNNCell
            }
        }), Object.defineProperty(exports, "multinomial", {
            enumerable: !0,
            get: function() {
                return He.multinomial
            }
        }), Object.defineProperty(exports, "neg", {
            enumerable: !0,
            get: function() {
                return Ie.neg
            }
        }), Object.defineProperty(exports, "notEqual", {
            enumerable: !0,
            get: function() {
                return Ue.notEqual
            }
        }), Object.defineProperty(exports, "oneHot", {
            enumerable: !0,
            get: function() {
                return Ve.oneHot
            }
        }), Object.defineProperty(exports, "ones", {
            enumerable: !0,
            get: function() {
                return Xe.ones
            }
        }), Object.defineProperty(exports, "onesLike", {
            enumerable: !0,
            get: function() {
                return Je.onesLike
            }
        }), Object.defineProperty(exports, "outerProduct", {
            enumerable: !0,
            get: function() {
                return Ke.outerProduct
            }
        }), Object.defineProperty(exports, "pad", {
            enumerable: !0,
            get: function() {
                return Qe.pad
            }
        }), Object.defineProperty(exports, "pad1d", {
            enumerable: !0,
            get: function() {
                return Ye.pad1d
            }
        }), Object.defineProperty(exports, "pad2d", {
            enumerable: !0,
            get: function() {
                return Ze.pad2d
            }
        }), Object.defineProperty(exports, "pad3d", {
            enumerable: !0,
            get: function() {
                return $e.pad3d
            }
        }), Object.defineProperty(exports, "pad4d", {
            enumerable: !0,
            get: function() {
                return er.pad4d
            }
        }), Object.defineProperty(exports, "pool", {
            enumerable: !0,
            get: function() {
                return rr.pool
            }
        }), Object.defineProperty(exports, "pow", {
            enumerable: !0,
            get: function() {
                return tr.pow
            }
        }), Object.defineProperty(exports, "prelu", {
            enumerable: !0,
            get: function() {
                return nr.prelu
            }
        }), Object.defineProperty(exports, "print", {
            enumerable: !0,
            get: function() {
                return or.print
            }
        }), Object.defineProperty(exports, "prod", {
            enumerable: !0,
            get: function() {
                return ur.prod
            }
        }), Object.defineProperty(exports, "rand", {
            enumerable: !0,
            get: function() {
                return ir.rand
            }
        }), Object.defineProperty(exports, "randomGamma", {
            enumerable: !0,
            get: function() {
                return ar.randomGamma
            }
        }), Object.defineProperty(exports, "randomNormal", {
            enumerable: !0,
            get: function() {
                return cr.randomNormal
            }
        }), Object.defineProperty(exports, "randomUniform", {
            enumerable: !0,
            get: function() {
                return sr.randomUniform
            }
        }), Object.defineProperty(exports, "range", {
            enumerable: !0,
            get: function() {
                return pr.range
            }
        }), Object.defineProperty(exports, "real", {
            enumerable: !0,
            get: function() {
                return lr.real
            }
        }), Object.defineProperty(exports, "reciprocal", {
            enumerable: !0,
            get: function() {
                return fr.reciprocal
            }
        }), Object.defineProperty(exports, "relu", {
            enumerable: !0,
            get: function() {
                return dr.relu
            }
        }), Object.defineProperty(exports, "relu6", {
            enumerable: !0,
            get: function() {
                return br.relu6
            }
        }), Object.defineProperty(exports, "reshape", {
            enumerable: !0,
            get: function() {
                return mr.reshape
            }
        }), Object.defineProperty(exports, "reverse", {
            enumerable: !0,
            get: function() {
                return gr.reverse
            }
        }), Object.defineProperty(exports, "reverse1d", {
            enumerable: !0,
            get: function() {
                return xr.reverse1d
            }
        }), Object.defineProperty(exports, "reverse2d", {
            enumerable: !0,
            get: function() {
                return yr.reverse2d
            }
        }), Object.defineProperty(exports, "reverse3d", {
            enumerable: !0,
            get: function() {
                return qr.reverse3d
            }
        }), Object.defineProperty(exports, "reverse4d", {
            enumerable: !0,
            get: function() {
                return Or.reverse4d
            }
        }), Object.defineProperty(exports, "rfft", {
            enumerable: !0,
            get: function() {
                return Pr.rfft
            }
        }), Object.defineProperty(exports, "round", {
            enumerable: !0,
            get: function() {
                return jr.round
            }
        }), Object.defineProperty(exports, "rsqrt", {
            enumerable: !0,
            get: function() {
                return _r.rsqrt
            }
        }), Object.defineProperty(exports, "scalar", {
            enumerable: !0,
            get: function() {
                return hr.scalar
            }
        }), Object.defineProperty(exports, "selu", {
            enumerable: !0,
            get: function() {
                return vr.selu
            }
        }), Object.defineProperty(exports, "separableConv2d", {
            enumerable: !0,
            get: function() {
                return Nr.separableConv2d
            }
        }), Object.defineProperty(exports, "setdiff1dAsync", {
            enumerable: !0,
            get: function() {
                return Sr.setdiff1dAsync
            }
        }), Object.defineProperty(exports, "sigmoid", {
            enumerable: !0,
            get: function() {
                return wr.sigmoid
            }
        }), Object.defineProperty(exports, "sign", {
            enumerable: !0,
            get: function() {
                return kr.sign
            }
        }), Object.defineProperty(exports, "sin", {
            enumerable: !0,
            get: function() {
                return Mr.sin
            }
        }), Object.defineProperty(exports, "sinh", {
            enumerable: !0,
            get: function() {
                return Er.sinh
            }
        }), Object.defineProperty(exports, "slice", {
            enumerable: !0,
            get: function() {
                return zr.slice
            }
        }), Object.defineProperty(exports, "slice1d", {
            enumerable: !0,
            get: function() {
                return Dr.slice1d
            }
        }), Object.defineProperty(exports, "slice2d", {
            enumerable: !0,
            get: function() {
                return Tr.slice2d
            }
        }), Object.defineProperty(exports, "slice3d", {
            enumerable: !0,
            get: function() {
                return Ar.slice3d
            }
        }), Object.defineProperty(exports, "slice4d", {
            enumerable: !0,
            get: function() {
                return Lr.slice4d
            }
        }), Object.defineProperty(exports, "softmax", {
            enumerable: !0,
            get: function() {
                return Wr.softmax
            }
        }), Object.defineProperty(exports, "softplus", {
            enumerable: !0,
            get: function() {
                return Cr.softplus
            }
        }), Object.defineProperty(exports, "spaceToBatchND", {
            enumerable: !0,
            get: function() {
                return Rr.spaceToBatchND
            }
        }), Object.defineProperty(exports, "split", {
            enumerable: !0,
            get: function() {
                return Br.split
            }
        }), Object.defineProperty(exports, "sqrt", {
            enumerable: !0,
            get: function() {
                return Fr.sqrt
            }
        }), Object.defineProperty(exports, "square", {
            enumerable: !0,
            get: function() {
                return Gr.square
            }
        }), Object.defineProperty(exports, "squaredDifference", {
            enumerable: !0,
            get: function() {
                return Hr.squaredDifference
            }
        }), Object.defineProperty(exports, "squeeze", {
            enumerable: !0,
            get: function() {
                return Ir.squeeze
            }
        }), Object.defineProperty(exports, "stack", {
            enumerable: !0,
            get: function() {
                return Ur.stack
            }
        }), Object.defineProperty(exports, "step", {
            enumerable: !0,
            get: function() {
                return Vr.step
            }
        }), Object.defineProperty(exports, "stridedSlice", {
            enumerable: !0,
            get: function() {
                return Xr.stridedSlice
            }
        }), Object.defineProperty(exports, "sub", {
            enumerable: !0,
            get: function() {
                return Jr.sub
            }
        }), Object.defineProperty(exports, "sum", {
            enumerable: !0,
            get: function() {
                return Kr.sum
            }
        }), Object.defineProperty(exports, "tan", {
            enumerable: !0,
            get: function() {
                return Qr.tan
            }
        }), Object.defineProperty(exports, "tanh", {
            enumerable: !0,
            get: function() {
                return Yr.tanh
            }
        }), Object.defineProperty(exports, "tensor", {
            enumerable: !0,
            get: function() {
                return Zr.tensor
            }
        }), Object.defineProperty(exports, "tensor1d", {
            enumerable: !0,
            get: function() {
                return $r.tensor1d
            }
        }), Object.defineProperty(exports, "tensor2d", {
            enumerable: !0,
            get: function() {
                return et.tensor2d
            }
        }), Object.defineProperty(exports, "tensor3d", {
            enumerable: !0,
            get: function() {
                return rt.tensor3d
            }
        }), Object.defineProperty(exports, "tensor4d", {
            enumerable: !0,
            get: function() {
                return tt.tensor4d
            }
        }), Object.defineProperty(exports, "tensor5d", {
            enumerable: !0,
            get: function() {
                return nt.tensor5d
            }
        }), Object.defineProperty(exports, "tensor6d", {
            enumerable: !0,
            get: function() {
                return ot.tensor6d
            }
        }), Object.defineProperty(exports, "tile", {
            enumerable: !0,
            get: function() {
                return ut.tile
            }
        }), Object.defineProperty(exports, "topk", {
            enumerable: !0,
            get: function() {
                return it.topk
            }
        }), Object.defineProperty(exports, "truncatedNormal", {
            enumerable: !0,
            get: function() {
                return at.truncatedNormal
            }
        }), Object.defineProperty(exports, "unsortedSegmentSum", {
            enumerable: !0,
            get: function() {
                return ct.unsortedSegmentSum
            }
        }), Object.defineProperty(exports, "unstack", {
            enumerable: !0,
            get: function() {
                return st.unstack
            }
        }), Object.defineProperty(exports, "variable", {
            enumerable: !0,
            get: function() {
                return pt.variable
            }
        }), Object.defineProperty(exports, "where", {
            enumerable: !0,
            get: function() {
                return lt.where
            }
        }), Object.defineProperty(exports, "whereAsync", {
            enumerable: !0,
            get: function() {
                return ft.whereAsync
            }
        }), Object.defineProperty(exports, "zeros", {
            enumerable: !0,
            get: function() {
                return dt.zeros
            }
        }), Object.defineProperty(exports, "zerosLike", {
            enumerable: !0,
            get: function() {
                return bt.zerosLike
            }
        }), Object.defineProperty(exports, "op", {
            enumerable: !0,
            get: function() {
                return St.op
            }
        }), exports.fused = exports.signal = exports.spectral = exports.losses = exports.linalg = exports.image = void 0;
        var r = require("./abs"),
            t = require("./acos"),
            n = require("./acosh"),
            o = require("./add"),
            u = require("./add_n"),
            i = require("./all"),
            a = require("./any"),
            c = require("./arg_max"),
            s = require("./arg_min"),
            p = require("./asin"),
            l = require("./asinh"),
            f = require("./atan"),
            d = require("./atan2"),
            b = require("./atanh"),
            m = require("./avg_pool"),
            g = require("./avg_pool_3d"),
            x = require("./basic_lstm_cell"),
            y = require("./batch_to_space_nd"),
            q = require("./batchnorm"),
            O = require("./batchnorm2d"),
            P = require("./batchnorm3d"),
            j = require("./batchnorm4d"),
            _ = require("./broadcast_to"),
            h = require("./buffer"),
            v = require("./cast"),
            N = require("./ceil"),
            S = require("./clip_by_value"),
            w = require("./clone"),
            k = require("./complex"),
            M = require("./concat"),
            E = require("./concat_1d"),
            z = require("./concat_2d"),
            D = require("./concat_3d"),
            T = require("./concat_4d"),
            A = require("./conv1d"),
            L = require("./conv2d"),
            W = require("./conv2d_transpose"),
            C = require("./conv3d"),
            R = require("./conv3d_transpose"),
            B = require("./cos"),
            F = require("./cosh"),
            G = require("./cumsum"),
            H = require("./depth_to_space"),
            I = require("./depthwise_conv2d"),
            U = require("./diag"),
            V = require("./dilation2d"),
            X = require("./div"),
            J = require("./div_no_nan"),
            K = require("./dot"),
            Q = require("./elu"),
            Y = require("./equal"),
            Z = require("./erf"),
            $ = require("./exp"),
            ee = require("./expand_dims"),
            re = require("./expm1"),
            te = require("./eye"),
            ne = require("./fft"),
            oe = require("./fill"),
            ue = require("./floor"),
            ie = require("./floorDiv"),
            ae = require("./gather"),
            ce = require("./greater"),
            se = require("./greater_equal"),
            pe = require("./ifft"),
            le = require("./imag"),
            fe = require("./irfft"),
            de = require("./is_finite"),
            be = require("./is_inf"),
            me = require("./is_nan"),
            ge = require("./leaky_relu"),
            xe = require("./less"),
            ye = require("./less_equal"),
            qe = require("./linspace"),
            Oe = require("./local_response_normalization"),
            Pe = require("./log"),
            je = require("./log1p"),
            _e = require("./log_sigmoid"),
            he = require("./log_softmax"),
            ve = require("./log_sum_exp"),
            Ne = require("./logical_and"),
            Se = require("./logical_not"),
            we = require("./logical_or"),
            ke = require("./logical_xor"),
            Me = require("./mat_mul"),
            Ee = require("./max"),
            ze = require("./max_pool"),
            De = require("./max_pool_3d"),
            Te = require("./max_pool_with_argmax"),
            Ae = require("./maximum"),
            Le = require("./mean"),
            We = require("./min"),
            Ce = require("./minimum"),
            Re = require("./mod"),
            Be = require("./moments"),
            Fe = require("./mul"),
            Ge = require("./multi_rnn_cell"),
            He = require("./multinomial"),
            Ie = require("./neg"),
            Ue = require("./not_equal"),
            Ve = require("./one_hot"),
            Xe = require("./ones"),
            Je = require("./ones_like"),
            Ke = require("./outer_product"),
            Qe = require("./pad"),
            Ye = require("./pad1d"),
            Ze = require("./pad2d"),
            $e = require("./pad3d"),
            er = require("./pad4d"),
            rr = require("./pool"),
            tr = require("./pow"),
            nr = require("./prelu"),
            or = require("./print"),
            ur = require("./prod"),
            ir = require("./rand"),
            ar = require("./random_gamma"),
            cr = require("./random_normal"),
            sr = require("./random_uniform"),
            pr = require("./range"),
            lr = require("./real"),
            fr = require("./reciprocal"),
            dr = require("./relu"),
            br = require("./relu6"),
            mr = require("./reshape"),
            gr = require("./reverse"),
            xr = require("./reverse_1d"),
            yr = require("./reverse_2d"),
            qr = require("./reverse_3d"),
            Or = require("./reverse_4d"),
            Pr = require("./rfft"),
            jr = require("./round"),
            _r = require("./rsqrt"),
            hr = require("./scalar"),
            vr = require("./selu"),
            Nr = require("./separable_conv2d"),
            Sr = require("./setdiff1d_async"),
            wr = require("./sigmoid"),
            kr = require("./sign"),
            Mr = require("./sin"),
            Er = require("./sinh"),
            zr = require("./slice"),
            Dr = require("./slice1d"),
            Tr = require("./slice2d"),
            Ar = require("./slice3d"),
            Lr = require("./slice4d"),
            Wr = require("./softmax"),
            Cr = require("./softplus"),
            Rr = require("./space_to_batch_nd"),
            Br = require("./split"),
            Fr = require("./sqrt"),
            Gr = require("./square"),
            Hr = require("./squared_difference"),
            Ir = require("./squeeze"),
            Ur = require("./stack"),
            Vr = require("./step"),
            Xr = require("./strided_slice"),
            Jr = require("./sub"),
            Kr = require("./sum"),
            Qr = require("./tan"),
            Yr = require("./tanh"),
            Zr = require("./tensor"),
            $r = require("./tensor1d"),
            et = require("./tensor2d"),
            rt = require("./tensor3d"),
            tt = require("./tensor4d"),
            nt = require("./tensor5d"),
            ot = require("./tensor6d"),
            ut = require("./tile"),
            it = require("./topk"),
            at = require("./truncated_normal"),
            ct = require("./unsorted_segment_sum"),
            st = require("./unstack"),
            pt = require("./variable"),
            lt = require("./where"),
            ft = require("./where_async"),
            dt = require("./zeros"),
            bt = require("./zeros_like"),
            mt = require("./boolean_mask");
        Object.keys(mt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return mt[r]
                }
            }))
        });
        var gt = require("./compare");
        Object.keys(gt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return gt[r]
                }
            }))
        });
        var xt = require("./binary_ops");
        Object.keys(xt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return xt[r]
                }
            }))
        });
        var yt = require("./transpose");
        Object.keys(yt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return yt[r]
                }
            }))
        });
        var qt = require("./norm");
        Object.keys(qt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return qt[r]
                }
            }))
        });
        var Ot = require("./moving_average");
        Object.keys(Ot).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return Ot[r]
                }
            }))
        });
        var Pt = require("./scatter_nd");
        Object.keys(Pt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return Pt[r]
                }
            }))
        });
        var jt = require("./sparse_to_dense");
        Object.keys(jt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return jt[r]
                }
            }))
        });
        var _t = require("./gather_nd");
        Object.keys(_t).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return _t[r]
                }
            }))
        });
        var ht = require("./dropout");
        Object.keys(ht).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return ht[r]
                }
            }))
        });
        var vt = require("./signal_ops_util");
        Object.keys(vt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return vt[r]
                }
            }))
        });
        var Nt = require("./in_top_k");
        Object.keys(Nt).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return Nt[r]
                }
            }))
        });
        var St = require("./operation"),
            wt = tn(require("./fused_ops"));
        exports.fused = wt;
        var kt = require("./hamming_window"),
            Mt = require("./hann_window"),
            Et = require("./frame"),
            zt = require("./stft"),
            Dt = require("./crop_and_resize"),
            Tt = require("./rotate_with_offset"),
            At = require("./non_max_suppression"),
            Lt = require("./non_max_suppression_async"),
            Wt = require("./non_max_suppression_with_score"),
            Ct = require("./non_max_suppression_with_score_async"),
            Rt = require("./non_max_suppression_padded"),
            Bt = require("./non_max_suppression_padded_async"),
            Ft = require("./resize_bilinear"),
            Gt = require("./resize_nearest_neighbor"),
            Ht = require("./band_part"),
            It = require("./gram_schmidt"),
            Ut = require("./qr"),
            Vt = require("./absolute_difference"),
            Xt = require("./compute_weighted_loss"),
            Jt = require("./cosine_distance"),
            Kt = require("./hinge_loss"),
            Qt = require("./huber_loss"),
            Yt = require("./log_loss"),
            Zt = require("./mean_squared_error"),
            $t = require("./sigmoid_cross_entropy"),
            en = require("./softmax_cross_entropy");

        function rn() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return rn = function() {
                return e
            }, e
        }

        function tn(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = rn();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(t, o, u) : t[o] = e[o]
                } return t.default = e, r && r.set(e, t), t
        }
        const nn = {
            fft: ne.fft,
            ifft: pe.ifft,
            rfft: Pr.rfft,
            irfft: fe.irfft
        };
        exports.spectral = nn;
        const on = {
            hammingWindow: kt.hammingWindow,
            hannWindow: Mt.hannWindow,
            frame: Et.frame,
            stft: zt.stft
        };
        exports.signal = on;
        const un = {
            resizeNearestNeighbor: Gt.resizeNearestNeighbor,
            resizeBilinear: Ft.resizeBilinear,
            rotateWithOffset: Tt.rotateWithOffset,
            cropAndResize: Dt.cropAndResize,
            nonMaxSuppression: At.nonMaxSuppression,
            nonMaxSuppressionAsync: Lt.nonMaxSuppressionAsync,
            nonMaxSuppressionWithScore: Wt.nonMaxSuppressionWithScore,
            nonMaxSuppressionWithScoreAsync: Ct.nonMaxSuppressionWithScoreAsync,
            nonMaxSuppressionPadded: Rt.nonMaxSuppressionPadded,
            nonMaxSuppressionPaddedAsync: Bt.nonMaxSuppressionPaddedAsync
        };
        exports.image = un;
        const an = {
            bandPart: Ht.bandPart,
            gramSchmidt: It.gramSchmidt,
            qr: Ut.qr
        };
        exports.linalg = an;
        const cn = {
            absoluteDifference: Vt.absoluteDifference,
            computeWeightedLoss: Xt.computeWeightedLoss,
            cosineDistance: Jt.cosineDistance,
            hingeLoss: Kt.hingeLoss,
            huberLoss: Qt.huberLoss,
            logLoss: Yt.logLoss,
            meanSquaredError: Zt.meanSquaredError,
            sigmoidCrossEntropy: $t.sigmoidCrossEntropy,
            softmaxCrossEntropy: en.softmaxCrossEntropy
        };
        exports.losses = cn;
    }, {
        "./abs": "aE3W",
        "./acos": "wQJc",
        "./acosh": "JJYu",
        "./add": "ZDFV",
        "./add_n": "EQUq",
        "./all": "VAUj",
        "./any": "OF1E",
        "./arg_max": "wSFk",
        "./arg_min": "Zhc7",
        "./asin": "pS4z",
        "./asinh": "B3dx",
        "./atan": "Yh9p",
        "./atan2": "eUJw",
        "./atanh": "DlnE",
        "./avg_pool": "iP9e",
        "./avg_pool_3d": "df2t",
        "./basic_lstm_cell": "yZSA",
        "./batch_to_space_nd": "Q9gF",
        "./batchnorm": "qqTf",
        "./batchnorm2d": "fmF3",
        "./batchnorm3d": "seIf",
        "./batchnorm4d": "REgA",
        "./broadcast_to": "qUV0",
        "./buffer": "WyiN",
        "./cast": "qqq3",
        "./ceil": "S70G",
        "./clip_by_value": "VfEE",
        "./clone": "F06q",
        "./complex": "Iowv",
        "./concat": "dDdq",
        "./concat_1d": "J9se",
        "./concat_2d": "Y6Ad",
        "./concat_3d": "NSM9",
        "./concat_4d": "Yjfb",
        "./conv1d": "n3wz",
        "./conv2d": "oJQk",
        "./conv2d_transpose": "GCOF",
        "./conv3d": "VJ2T",
        "./conv3d_transpose": "fQzO",
        "./cos": "g9ZU",
        "./cosh": "GpTU",
        "./cumsum": "Kzhc",
        "./depth_to_space": "U4UL",
        "./depthwise_conv2d": "Kahd",
        "./diag": "B6ot",
        "./dilation2d": "q2Zv",
        "./div": "D8Fc",
        "./div_no_nan": "mdNH",
        "./dot": "bUs4",
        "./elu": "a7Il",
        "./equal": "WG94",
        "./erf": "roFm",
        "./exp": "zsk9",
        "./expand_dims": "XF6l",
        "./expm1": "ntzg",
        "./eye": "HzEj",
        "./fft": "lSPP",
        "./fill": "e6pp",
        "./floor": "XD37",
        "./floorDiv": "Pk64",
        "./gather": "ESvM",
        "./greater": "QdS7",
        "./greater_equal": "Dbo2",
        "./ifft": "fGYa",
        "./imag": "C5d3",
        "./irfft": "SM4c",
        "./is_finite": "JMGA",
        "./is_inf": "PwB1",
        "./is_nan": "LVjE",
        "./leaky_relu": "hUKE",
        "./less": "Ndy5",
        "./less_equal": "FvS1",
        "./linspace": "encs",
        "./local_response_normalization": "wFSX",
        "./log": "vwHA",
        "./log1p": "PxfL",
        "./log_sigmoid": "lXsJ",
        "./log_softmax": "I1du",
        "./log_sum_exp": "MQ55",
        "./logical_and": "lYzt",
        "./logical_not": "XZse",
        "./logical_or": "HD5h",
        "./logical_xor": "FEKV",
        "./mat_mul": "mMWq",
        "./max": "iipD",
        "./max_pool": "hJeZ",
        "./max_pool_3d": "Cet1",
        "./max_pool_with_argmax": "gxl3",
        "./maximum": "X5MV",
        "./mean": "jwZo",
        "./min": "w9We",
        "./minimum": "crIr",
        "./mod": "lYF1",
        "./moments": "rBcz",
        "./mul": "k2PI",
        "./multi_rnn_cell": "V2Xb",
        "./multinomial": "GA9C",
        "./neg": "iGYA",
        "./not_equal": "jVu5",
        "./one_hot": "ETzZ",
        "./ones": "POxQ",
        "./ones_like": "VzlV",
        "./outer_product": "lKlD",
        "./pad": "hajs",
        "./pad1d": "aLXo",
        "./pad2d": "OUX7",
        "./pad3d": "Exwp",
        "./pad4d": "HxGt",
        "./pool": "T3We",
        "./pow": "vt1B",
        "./prelu": "mkuj",
        "./print": "xBTU",
        "./prod": "pvB6",
        "./rand": "WpBM",
        "./random_gamma": "fM99",
        "./random_normal": "gSkF",
        "./random_uniform": "yl8A",
        "./range": "gc29",
        "./real": "cKEu",
        "./reciprocal": "w0Wv",
        "./relu": "SJP3",
        "./relu6": "MNkg",
        "./reshape": "QI4k",
        "./reverse": "SxGN",
        "./reverse_1d": "dTCT",
        "./reverse_2d": "jAVH",
        "./reverse_3d": "fmHW",
        "./reverse_4d": "CaS6",
        "./rfft": "WiyN",
        "./round": "J1Ke",
        "./rsqrt": "XwKw",
        "./scalar": "Ay42",
        "./selu": "nLmU",
        "./separable_conv2d": "M7Hy",
        "./setdiff1d_async": "cgP9",
        "./sigmoid": "yARQ",
        "./sign": "cGq1",
        "./sin": "AdWB",
        "./sinh": "fN3P",
        "./slice": "zP07",
        "./slice1d": "lQVK",
        "./slice2d": "r8xQ",
        "./slice3d": "jraI",
        "./slice4d": "r60P",
        "./softmax": "xLGH",
        "./softplus": "eE4m",
        "./space_to_batch_nd": "rWul",
        "./split": "VA1I",
        "./sqrt": "iJpu",
        "./square": "mJRX",
        "./squared_difference": "gsmP",
        "./squeeze": "ZVMV",
        "./stack": "TWBn",
        "./step": "e2o4",
        "./strided_slice": "Q58L",
        "./sub": "dGex",
        "./sum": "ITAy",
        "./tan": "DosY",
        "./tanh": "ZRNG",
        "./tensor": "P2QC",
        "./tensor1d": "pBg9",
        "./tensor2d": "WnBr",
        "./tensor3d": "v3VY",
        "./tensor4d": "VxHJ",
        "./tensor5d": "qXmw",
        "./tensor6d": "GISR",
        "./tile": "mfii",
        "./topk": "GNrW",
        "./truncated_normal": "njSi",
        "./unsorted_segment_sum": "GWRE",
        "./unstack": "JDMu",
        "./variable": "oIio",
        "./where": "BsuI",
        "./where_async": "md2p",
        "./zeros": "R5fo",
        "./zeros_like": "PDcB",
        "./boolean_mask": "hPEM",
        "./compare": "M0Xr",
        "./binary_ops": "V7h5",
        "./transpose": "uQkx",
        "./norm": "Twvf",
        "./moving_average": "HWJh",
        "./scatter_nd": "QGqq",
        "./sparse_to_dense": "vYKY",
        "./gather_nd": "UkmN",
        "./dropout": "sFBi",
        "./signal_ops_util": "A6ms",
        "./in_top_k": "JOMU",
        "./operation": "JtaO",
        "./fused_ops": "nQCt",
        "./hamming_window": "OvUq",
        "./hann_window": "FQ37",
        "./frame": "XPcq",
        "./stft": "yr5z",
        "./crop_and_resize": "iBUo",
        "./rotate_with_offset": "Cjsh",
        "./non_max_suppression": "GL9f",
        "./non_max_suppression_async": "PetR",
        "./non_max_suppression_with_score": "gYwG",
        "./non_max_suppression_with_score_async": "ZdPq",
        "./non_max_suppression_padded": "VtMO",
        "./non_max_suppression_padded_async": "c7Zx",
        "./resize_bilinear": "uhYK",
        "./resize_nearest_neighbor": "OP6T",
        "./band_part": "NlFz",
        "./gram_schmidt": "bcgP",
        "./qr": "ybex",
        "./absolute_difference": "GZvF",
        "./compute_weighted_loss": "eNIu",
        "./cosine_distance": "NDqm",
        "./hinge_loss": "lWDW",
        "./huber_loss": "hI9K",
        "./log_loss": "gQUw",
        "./mean_squared_error": "n674",
        "./sigmoid_cross_entropy": "rKBl",
        "./softmax_cross_entropy": "F041"
    }],
    "uOca": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Optimizer = void 0;
        var e = require("../globals"),
            t = require("../gradients"),
            i = require("../ops/ops"),
            s = require("../serialization");
        class r extends s.Serializable {
            minimize(t, i = !1, s) {
                const {
                    value: r,
                    grads: n
                } = this.computeGradients(t, s);
                if (null != s) {
                    const e = s.map(e => ({
                        name: e.name,
                        tensor: n[e.name]
                    }));
                    this.applyGradients(e)
                } else this.applyGradients(n);
                return (0, e.dispose)(n), i ? r : (r.dispose(), null)
            }
            get iterations() {
                return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
            }
            incrementIterations() {
                this.iterations_ = this.iterations + 1
            }
            computeGradients(e, i) {
                return (0, t.variableGrads)(e, i)
            }
            dispose() {
                null != this.iterations_ && (0, e.dispose)(this.iterations_)
            }
            async saveIterations() {
                return null == this.iterations_ && (this.iterations_ = 0), {
                    name: "iter",
                    tensor: (0, i.scalar)(this.iterations_, "int32")
                }
            }
            async getWeights() {
                throw new Error("getWeights() is not implemented for this optimizer yet.")
            }
            async setWeights(e) {
                throw new Error("setWeights() is not implemented for this optimizer class " + `${this.getClassName()}`)
            }
            async extractIterations(e) {
                return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1)
            }
        }
        exports.Optimizer = r, Object.defineProperty(r, Symbol.hasInstance, {
            value: e => null != e.minimize && null != e.computeGradients && null != e.applyGradients
        });
    }, {
        "../globals": "GWnL",
        "../gradients": "yPDw",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU"
    }],
    "NZz8": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AdadeltaOptimizer = void 0;
        var a = require("../engine"),
            e = require("../globals"),
            s = require("../ops/ops"),
            t = require("../serialization"),
            i = require("./optimizer");
        class r extends i.Optimizer {
            constructor(e, s, t = null) {
                super(), this.learningRate = e, this.rho = s, this.epsilon = t, this.accumulatedGrads = [], this.accumulatedUpdates = [], null == t && (this.epsilon = a.ENGINE.backend.epsilon())
            }
            applyGradients(t) {
                (Array.isArray(t) ? t.map(a => a.name) : Object.keys(t)).forEach((i, r) => {
                    const l = a.ENGINE.registeredVariables[i];
                    null == this.accumulatedGrads[r] && (this.accumulatedGrads[r] = {
                        originalName: `${i}/accum_grad`,
                        variable: (0, e.tidy)(() => (0, s.zerosLike)(l).variable(!1))
                    }), null == this.accumulatedUpdates[r] && (this.accumulatedUpdates[r] = {
                        originalName: `${i}/accum_var`,
                        variable: (0, e.tidy)(() => (0, s.zerosLike)(l).variable(!1))
                    });
                    const n = Array.isArray(t) ? t[r].tensor : t[i];
                    if (null == n) return;
                    const d = this.accumulatedGrads[r].variable,
                        u = this.accumulatedUpdates[r].variable;
                    (0, e.tidy)(() => {
                        const a = d.mul(this.rho).add(n.square().mul(1 - this.rho)),
                            e = u.add(this.epsilon).sqrt().div(d.add(this.epsilon).sqrt()).mul(n),
                            s = u.mul(this.rho).add(e.square().mul(1 - this.rho));
                        d.assign(a), u.assign(s);
                        const t = e.mul(-this.learningRate).add(l);
                        l.assign(t)
                    })
                }), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedUpdates && ((0, e.dispose)(this.accumulatedGrads.map(a => a.variable)), (0, e.dispose)(this.accumulatedUpdates.map(a => a.variable)))
            }
            async getWeights() {
                const a = [...this.accumulatedGrads, ...this.accumulatedUpdates];
                return [await this.saveIterations()].concat(a.map(a => ({
                    name: a.originalName,
                    tensor: a.variable
                })))
            }
            async setWeights(a) {
                const e = (a = await this.extractIterations(a)).length / 2;
                this.accumulatedGrads = a.slice(0, e).map(a => ({
                    originalName: a.name,
                    variable: a.tensor.variable(!1)
                })), this.accumulatedUpdates = a.slice(e, 2 * e).map(a => ({
                    originalName: a.name,
                    variable: a.tensor.variable(!1)
                }))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    rho: this.rho,
                    epsilon: this.epsilon
                }
            }
            static fromConfig(a, e) {
                return new a(e.learningRate, e.rho, e.epsilon)
            }
        }
        exports.AdadeltaOptimizer = r, r.className = "Adadelta", (0, t.registerClass)(r);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "oWMZ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AdagradOptimizer = void 0;
        var a = require("../engine"),
            e = require("../globals"),
            i = require("../ops/fill"),
            t = require("../serialization"),
            r = require("./optimizer");
        class s extends r.Optimizer {
            constructor(a, e = .1) {
                super(), this.learningRate = a, this.initialAccumulatorValue = e, this.accumulatedGrads = []
            }
            applyGradients(t) {
                (Array.isArray(t) ? t.map(a => a.name) : Object.keys(t)).forEach((r, s) => {
                    const l = a.ENGINE.registeredVariables[r];
                    if (null == this.accumulatedGrads[s]) {
                        const a = !1;
                        this.accumulatedGrads[s] = {
                            originalName: `${r}/accumulator`,
                            variable: (0, e.tidy)(() => (0, i.fill)(l.shape, this.initialAccumulatorValue).variable(a))
                        }
                    }
                    const n = Array.isArray(t) ? t[s].tensor : t[r];
                    if (null == n) return;
                    const u = this.accumulatedGrads[s].variable;
                    (0, e.tidy)(() => {
                        const e = u.add(n.square());
                        u.assign(e);
                        const i = n.div(e.add(a.ENGINE.backend.epsilon()).sqrt()).mul(-this.learningRate).add(l);
                        l.assign(i)
                    })
                }), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedGrads && (0, e.dispose)(this.accumulatedGrads.map(a => a.variable))
            }
            async getWeights() {
                return [await this.saveIterations()].concat(this.accumulatedGrads.map(a => ({
                    name: a.originalName,
                    tensor: a.variable
                })))
            }
            async setWeights(a) {
                a = await this.extractIterations(a);
                this.accumulatedGrads = a.map(a => ({
                    originalName: a.name,
                    variable: a.tensor.variable(!1)
                }))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    initialAccumulatorValue: this.initialAccumulatorValue
                }
            }
            static fromConfig(a, e) {
                return new a(e.learningRate, e.initialAccumulatorValue)
            }
        }
        exports.AdagradOptimizer = s, s.className = "Adagrad", (0, t.registerClass)(s);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/fill": "e6pp",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "K7FB": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AdamOptimizer = void 0;
        var t = require("../engine"),
            e = require("../globals"),
            a = require("../ops/ops"),
            i = require("../serialization"),
            s = require("./optimizer");
        class n extends s.Optimizer {
            constructor(i, s, n, r = null) {
                super(), this.learningRate = i, this.beta1 = s, this.beta2 = n, this.epsilon = r, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], (0, e.tidy)(() => {
                    this.accBeta1 = (0, a.scalar)(s).variable(), this.accBeta2 = (0, a.scalar)(n).variable()
                }), null == r && (this.epsilon = t.ENGINE.backend.epsilon())
            }
            applyGradients(i) {
                const s = Array.isArray(i) ? i.map(t => t.name) : Object.keys(i);
                (0, e.tidy)(() => {
                    const n = (0, a.sub)(1, this.accBeta1),
                        r = (0, a.sub)(1, this.accBeta2);
                    s.forEach((s, c) => {
                        const l = t.ENGINE.registeredVariables[s];
                        null == this.accumulatedFirstMoment[c] && (this.accumulatedFirstMoment[c] = {
                            originalName: `${s}/m`,
                            variable: (0, e.tidy)(() => (0, a.zerosLike)(l).variable(!1))
                        }), null == this.accumulatedSecondMoment[c] && (this.accumulatedSecondMoment[c] = {
                            originalName: `${s}/v`,
                            variable: (0, e.tidy)(() => (0, a.zerosLike)(l).variable(!1))
                        });
                        const o = Array.isArray(i) ? i[c].tensor : i[s];
                        if (null == o) return;
                        const m = this.accumulatedFirstMoment[c].variable,
                            u = this.accumulatedSecondMoment[c].variable,
                            h = m.mul(this.beta1).add(o.mul(1 - this.beta1)),
                            d = u.mul(this.beta2).add(o.square().mul(1 - this.beta2)),
                            b = h.div(n),
                            p = d.div(r);
                        m.assign(h), u.assign(d);
                        const g = b.div(p.sqrt().add(this.epsilon)).mul(-this.learningRate).add(l);
                        l.assign(g)
                    }), this.accBeta1.assign(this.accBeta1.mul(this.beta1)), this.accBeta2.assign(this.accBeta2.mul(this.beta2))
                }), this.incrementIterations()
            }
            dispose() {
                this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && (0, e.dispose)(this.accumulatedFirstMoment.map(t => t.variable)), null != this.accumulatedSecondMoment && (0, e.dispose)(this.accumulatedSecondMoment.map(t => t.variable))
            }
            async getWeights() {
                const t = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
                return [await this.saveIterations()].concat(t.map(t => ({
                    name: t.originalName,
                    tensor: t.variable
                })))
            }
            async setWeights(t) {
                t = await this.extractIterations(t), (0, e.tidy)(() => {
                    this.accBeta1.assign((0, a.pow)(this.beta1, this.iterations_ + 1)), this.accBeta2.assign((0, a.pow)(this.beta2, this.iterations_ + 1))
                });
                const i = t.length / 2;
                this.accumulatedFirstMoment = t.slice(0, i).map(t => ({
                    originalName: t.name,
                    variable: t.tensor.variable(!1)
                })), this.accumulatedSecondMoment = t.slice(i, 2 * i).map(t => ({
                    originalName: t.name,
                    variable: t.tensor.variable(!1)
                }))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    beta1: this.beta1,
                    beta2: this.beta2,
                    epsilon: this.epsilon
                }
            }
            static fromConfig(t, e) {
                return new t(e.learningRate, e.beta1, e.beta2, e.epsilon)
            }
        }
        exports.AdamOptimizer = n, n.className = "Adam", (0, i.registerClass)(n);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "NenH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AdamaxOptimizer = void 0;
        var e = require("../engine"),
            t = require("../globals"),
            i = require("../ops/ops"),
            a = require("../serialization"),
            s = require("./optimizer");
        class r extends s.Optimizer {
            constructor(a, s, r, n = null, l = 0) {
                super(), this.learningRate = a, this.beta1 = s, this.beta2 = r, this.epsilon = n, this.decay = l, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], (0, t.tidy)(() => {
                    this.iteration = (0, i.scalar)(0).variable(), this.accBeta1 = (0, i.scalar)(s).variable()
                }), null == n && (this.epsilon = e.ENGINE.backend.epsilon())
            }
            applyGradients(a) {
                const s = Array.isArray(a) ? a.map(e => e.name) : Object.keys(a);
                (0, t.tidy)(() => {
                    const t = (0, i.sub)(1, this.accBeta1),
                        r = (0, i.div)(-this.learningRate, this.iteration.mul(this.decay).add(1));
                    s.forEach((s, n) => {
                        const l = e.ENGINE.registeredVariables[s];
                        null == this.accumulatedFirstMoment[n] && (this.accumulatedFirstMoment[n] = {
                            originalName: `${s}/m`,
                            variable: (0, i.zerosLike)(l).variable(!1)
                        }), null == this.accumulatedWeightedInfNorm[n] && (this.accumulatedWeightedInfNorm[n] = {
                            originalName: `${s}/v`,
                            variable: (0, i.zerosLike)(l).variable(!1)
                        });
                        const o = Array.isArray(a) ? a[n].tensor : a[s];
                        if (null == o) return;
                        const c = this.accumulatedFirstMoment[n].variable,
                            d = this.accumulatedWeightedInfNorm[n].variable,
                            m = c.mul(this.beta1).add(o.mul(1 - this.beta1)),
                            h = d.mul(this.beta2),
                            u = o.abs(),
                            g = h.maximum(u);
                        c.assign(m), d.assign(g);
                        const p = r.div(t).mul(m.div(g.add(this.epsilon))).add(l);
                        l.assign(p)
                    }), this.iteration.assign(this.iteration.add(1)), this.accBeta1.assign(this.accBeta1.mul(this.beta1))
                }), this.incrementIterations()
            }
            dispose() {
                this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && (0, t.dispose)(this.accumulatedFirstMoment.map(e => e.variable)), null != this.accumulatedWeightedInfNorm && (0, t.dispose)(this.accumulatedWeightedInfNorm.map(e => e.variable))
            }
            async getWeights() {
                throw new Error("getWeights() is not implemented for Adamax yet.")
            }
            async setWeights(e) {
                throw new Error("setWeights() is not implemented for Adamax yet.")
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    beta1: this.beta1,
                    beta2: this.beta2,
                    epsilon: this.epsilon,
                    decay: this.decay
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay)
            }
        }
        exports.AdamaxOptimizer = r, r.className = "Adamax", (0, a.registerClass)(r);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "jyih": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SGDOptimizer = void 0;
        var e = require("../engine"),
            t = require("../globals"),
            r = require("../ops/ops"),
            i = require("../serialization"),
            s = require("./optimizer");
        class a extends s.Optimizer {
            constructor(e) {
                super(), this.learningRate = e, this.setLearningRate(e)
            }
            applyGradients(r) {
                (Array.isArray(r) ? r.map(e => e.name) : Object.keys(r)).forEach((i, s) => {
                    const a = Array.isArray(r) ? r[s].tensor : r[i];
                    if (null == a) return;
                    const n = e.ENGINE.registeredVariables[i];
                    (0, t.tidy)(() => {
                        const e = this.c.mul(a).add(n);
                        n.assign(e)
                    })
                }), this.incrementIterations()
            }
            setLearningRate(e) {
                this.learningRate = e, null != this.c && this.c.dispose(), this.c = (0, t.keep)((0, r.scalar)(-e))
            }
            dispose() {
                this.c.dispose()
            }
            async getWeights() {
                return [await this.saveIterations()]
            }
            async setWeights(e) {
                if (0 !== (e = await this.extractIterations(e)).length) throw new Error("SGD optimizer does not have settable weights.")
            }
            getConfig() {
                return {
                    learningRate: this.learningRate
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate)
            }
        }
        exports.SGDOptimizer = a, a.className = "SGD", (0, i.registerClass)(a);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "KNfn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.MomentumOptimizer = void 0;
        var e = require("../engine"),
            t = require("../globals"),
            s = require("../ops/ops"),
            i = require("../serialization"),
            a = require("./sgd_optimizer");
        class r extends a.SGDOptimizer {
            constructor(e, t, i = !1) {
                super(e), this.learningRate = e, this.momentum = t, this.useNesterov = i, this.accumulations = [], this.m = (0, s.scalar)(this.momentum)
            }
            applyGradients(i) {
                (Array.isArray(i) ? i.map(e => e.name) : Object.keys(i)).forEach((a, r) => {
                    const n = e.ENGINE.registeredVariables[a];
                    if (null == this.accumulations[r]) {
                        const e = !1;
                        this.accumulations[r] = {
                            originalName: `${a}/momentum`,
                            variable: (0, t.tidy)(() => (0, s.zerosLike)(n).variable(e))
                        }
                    }
                    const m = this.accumulations[r].variable,
                        o = Array.isArray(i) ? i[r].tensor : i[a];
                    null != o && (0, t.tidy)(() => {
                        let e;
                        const t = this.m.mul(m).add(o);
                        e = this.useNesterov ? this.c.mul(o.add(t.mul(this.m))).add(n) : this.c.mul(t).add(n), m.assign(t), n.assign(e)
                    })
                }), this.incrementIterations()
            }
            dispose() {
                this.m.dispose(), null != this.accumulations && (0, t.dispose)(this.accumulations.map(e => e.variable))
            }
            setMomentum(e) {
                this.momentum = e
            }
            async getWeights() {
                return [await this.saveIterations()].concat(this.accumulations.map(e => ({
                    name: e.originalName,
                    tensor: e.variable
                })))
            }
            async setWeights(e) {
                e = await this.extractIterations(e);
                this.accumulations = e.map(e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                }))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    momentum: this.momentum,
                    useNesterov: this.useNesterov
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.momentum, t.useNesterov)
            }
        }
        exports.MomentumOptimizer = r, r.className = "Momentum", (0, i.registerClass)(r);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./sgd_optimizer": "jyih"
    }],
    "dtrn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.RMSPropOptimizer = void 0;
        var e = require("../engine"),
            a = require("../globals"),
            t = require("../ops/ops"),
            s = require("../serialization"),
            i = require("./optimizer");
        class r extends i.Optimizer {
            constructor(a, t = .9, s = 0, i = null, r = !1) {
                if (super(), this.learningRate = a, this.decay = t, this.momentum = s, this.epsilon = i, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, null == i && (this.epsilon = e.ENGINE.backend.epsilon()), null == a) throw new Error("learningRate for RMSPropOptimizer must be defined.")
            }
            applyGradients(s) {
                (Array.isArray(s) ? s.map(e => e.name) : Object.keys(s)).forEach((i, r) => {
                    const n = e.ENGINE.registeredVariables[i];
                    null == this.accumulatedMeanSquares[r] && (this.accumulatedMeanSquares[r] = {
                        originalName: `${i}/rms`,
                        variable: (0, a.tidy)(() => (0, t.zerosLike)(n).variable(!1))
                    }), null == this.accumulatedMoments[r] && (this.accumulatedMoments[r] = {
                        originalName: `${i}/momentum`,
                        variable: (0, a.tidy)(() => (0, t.zerosLike)(n).variable(!1))
                    }), null == this.accumulatedMeanGrads[r] && this.centered && (this.accumulatedMeanGrads[r] = {
                        originalName: `${i}/mg`,
                        variable: (0, a.tidy)(() => (0, t.zerosLike)(n).variable(!1))
                    });
                    const l = Array.isArray(s) ? s[r].tensor : s[i];
                    if (null == l) return;
                    const u = this.accumulatedMeanSquares[r].variable,
                        c = this.accumulatedMoments[r].variable;
                    (0, a.tidy)(() => {
                        const e = u.mul(this.decay).add(l.square().mul(1 - this.decay));
                        if (this.centered) {
                            const a = this.accumulatedMeanGrads[r].variable,
                                t = a.mul(this.decay).add(l.mul(1 - this.decay)),
                                s = c.mul(this.momentum).add(l.mul(this.learningRate).div(e.sub(t.square().add(this.epsilon)).sqrt()));
                            u.assign(e), a.assign(t), c.assign(s);
                            const i = n.sub(s);
                            n.assign(i)
                        } else {
                            const e = u.mul(this.decay).add(l.square().mul(1 - this.decay)),
                                a = c.mul(this.momentum).add(l.mul(this.learningRate).div(e.add(this.epsilon).sqrt()));
                            u.assign(e), c.assign(a);
                            const t = n.sub(a);
                            n.assign(t)
                        }
                    })
                }), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedMeanSquares && (0, a.dispose)(this.accumulatedMeanSquares.map(e => e.variable)), null != this.accumulatedMeanGrads && this.centered && (0, a.dispose)(this.accumulatedMeanGrads.map(e => e.variable)), null != this.accumulatedMoments && (0, a.dispose)(this.accumulatedMoments.map(e => e.variable))
            }
            async getWeights() {
                const e = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
                return this.centered && e.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e.map(e => ({
                    name: e.originalName,
                    tensor: e.variable
                })))
            }
            async setWeights(e) {
                e = await this.extractIterations(e);
                const a = this.centered ? e.length / 3 : e.length / 2;
                this.accumulatedMeanSquares = e.slice(0, a).map(e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                })), this.accumulatedMoments = e.slice(a, 2 * a).map(e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                })), this.centered && (this.accumulatedMeanGrads = e.slice(2 * a, 3 * a).map(e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                })))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    decay: this.decay,
                    momentum: this.momentum,
                    epsilon: this.epsilon,
                    centered: this.centered
                }
            }
            static fromConfig(e, a) {
                return new e(a.learningRate, a.decay, a.momentum, a.epsilon, a.centered)
            }
        }
        exports.RMSPropOptimizer = r, r.className = "RMSProp", (0, s.registerClass)(r);
    }, {
        "../engine": "Nc3Y",
        "../globals": "GWnL",
        "../ops/ops": "R1mJ",
        "../serialization": "HDfU",
        "./optimizer": "uOca"
    }],
    "UCbu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.OptimizerConstructors = void 0;
        var r = require("./adadelta_optimizer"),
            e = require("./adagrad_optimizer"),
            t = require("./adam_optimizer"),
            i = require("./adamax_optimizer"),
            a = require("./momentum_optimizer"),
            m = require("./rmsprop_optimizer"),
            u = require("./sgd_optimizer");
        class p {
            static sgd(r) {
                return new u.SGDOptimizer(r)
            }
            static momentum(r, e, t = !1) {
                return new a.MomentumOptimizer(r, e, t)
            }
            static rmsprop(r, e = .9, t = 0, i = null, a = !1) {
                return new m.RMSPropOptimizer(r, e, t, i, a)
            }
            static adam(r = .001, e = .9, i = .999, a = null) {
                return new t.AdamOptimizer(r, e, i, a)
            }
            static adadelta(e = .001, t = .95, i = null) {
                return new r.AdadeltaOptimizer(e, t, i)
            }
            static adamax(r = .002, e = .9, t = .999, a = null, m = 0) {
                return new i.AdamaxOptimizer(r, e, t, a, m)
            }
            static adagrad(r, t = .1) {
                return new e.AdagradOptimizer(r, t)
            }
        }
        exports.OptimizerConstructors = p;
    }, {
        "./adadelta_optimizer": "NZz8",
        "./adagrad_optimizer": "oWMZ",
        "./adam_optimizer": "K7FB",
        "./adamax_optimizer": "NenH",
        "./momentum_optimizer": "KNfn",
        "./rmsprop_optimizer": "dtrn",
        "./sgd_optimizer": "jyih"
    }],
    "GtIJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.train = void 0;
        var r = require("./optimizers/adadelta_optimizer"),
            i = require("./optimizers/adagrad_optimizer"),
            e = require("./optimizers/adam_optimizer"),
            t = require("./optimizers/adamax_optimizer"),
            m = require("./optimizers/momentum_optimizer"),
            o = require("./optimizers/optimizer_constructors"),
            a = require("./optimizers/rmsprop_optimizer"),
            p = require("./optimizers/sgd_optimizer");
        m.MomentumOptimizer, p.SGDOptimizer, r.AdadeltaOptimizer, i.AdagradOptimizer, a.RMSPropOptimizer, t.AdamaxOptimizer, e.AdamOptimizer;
        const s = {
            sgd: o.OptimizerConstructors.sgd,
            momentum: o.OptimizerConstructors.momentum,
            adadelta: o.OptimizerConstructors.adadelta,
            adagrad: o.OptimizerConstructors.adagrad,
            rmsprop: o.OptimizerConstructors.rmsprop,
            adamax: o.OptimizerConstructors.adamax,
            adam: o.OptimizerConstructors.adam
        };
        exports.train = s;
    }, {
        "./optimizers/adadelta_optimizer": "NZz8",
        "./optimizers/adagrad_optimizer": "oWMZ",
        "./optimizers/adam_optimizer": "K7FB",
        "./optimizers/adamax_optimizer": "NenH",
        "./optimizers/momentum_optimizer": "KNfn",
        "./optimizers/optimizer_constructors": "UCbu",
        "./optimizers/rmsprop_optimizer": "dtrn",
        "./optimizers/sgd_optimizer": "jyih"
    }],
    "mxOd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nextFrame = t;
        const e = (() => "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : e => e())();

        function t() {
            return new Promise(t => e(() => t()))
        }
    }, {}],
    "eAkN": [function(require, module, exports) {
        "use strict";

        function e(e, t, r) {
            return [r * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])]
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getImageCenter = e;
    }, {}],
    "bsd6": [function(require, module, exports) {
        "use strict";

        function e(e, t, s, o = !0) {
            let u = [];
            if (o)(u = u.concat(t.slice(0))).push(e[0] / s), u = u.concat(e.slice(1));
            else {
                u = u.concat(e[0]);
                const s = t.length;
                for (let o = 0; o < s; ++o) u = u.concat([e[o + 1] / t[o], t[o]]);
                u = u.concat(e.slice(s + 1))
            }
            return u
        }

        function t(e, t, s = !0) {
            const o = [];
            if (s) {
                o.push(t);
                for (let s = t + 1; s < e; ++s) s <= 2 * t ? (o.push(s), o.push(s - (t + 1))) : o.push(s)
            } else {
                const s = [],
                    u = [];
                for (let o = 1; o < e; ++o) o >= 2 * t + 1 || o % 2 == 1 ? u.push(o) : s.push(o);
                o.push(...s), o.push(0), o.push(...u)
            }
            return o
        }

        function s(e, t, s, o = !0) {
            const u = [];
            o ? u.push(e[0] / s) : u.push(e[0] * s);
            for (let n = 1; n < e.length; ++n) n <= t.length ? o ? u.push(t[n - 1] * e[n]) : u.push(e[n] / t[n - 1]) : u.push(e[n]);
            return u
        }

        function o(e, t) {
            const s = [0];
            for (let o = 0; o < t; ++o) s.push(e[o][0]);
            return s
        }

        function u(e, t, s) {
            const o = e.slice(0, 1);
            for (let u = 0; u < s; ++u) o.push(e[u + 1] - t[u][0] - t[u][1]);
            return o
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getReshaped = e, exports.getPermuted = t, exports.getReshapedPermuted = s, exports.getSliceBeginCoords = o, exports.getSliceSize = u;
    }, {}],
    "iVXL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ERF_A5 = exports.ERF_A4 = exports.ERF_A3 = exports.ERF_A2 = exports.ERF_A1 = exports.ERF_P = void 0;
        const t = .3275911;
        exports.ERF_P = t;
        const o = .254829592;
        exports.ERF_A1 = o;
        const s = -.284496736;
        exports.ERF_A2 = s;
        const e = 1.421413741;
        exports.ERF_A3 = e;
        const r = -1.453152027;
        exports.ERF_A4 = r;
        const p = 1.061405429;
        exports.ERF_A5 = p;
    }, {}],
    "EnTq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.warn = o, exports.log = n;
        var e = require("./environment");

        function o(...o) {
            (0, e.env)().getBool("IS_TEST") || console.warn(...o)
        }

        function n(...o) {
            (0, e.env)().getBool("IS_TEST") || console.log(...o)
        }
    }, {
        "./environment": "Fbeg"
    }],
    "F59n": [function(require, module, exports) {
        "use strict";

        function t(t, e) {
            if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + `${t.length}, imag: ${e.length}.`);
            const r = new Float32Array(2 * t.length);
            for (let n = 0; n < r.length; n += 2) r[n] = t[n / 2], r[n + 1] = e[n / 2];
            return r
        }

        function e(t) {
            const e = new Float32Array(t.length / 2),
                r = new Float32Array(t.length / 2);
            for (let n = 0; n < t.length; n += 2) e[n / 2] = t[n], r[n / 2] = t[n + 1];
            return {
                real: e,
                imag: r
            }
        }

        function r(t) {
            const e = Math.ceil(t.length / 4),
                r = new Float32Array(e),
                n = new Float32Array(e);
            for (let o = 0; o < t.length; o += 4) r[Math.floor(o / 4)] = t[o], n[Math.floor(o / 4)] = t[o + 1];
            return {
                real: r,
                imag: n
            }
        }

        function n(t) {
            const e = Math.floor(t.length / 4),
                r = new Float32Array(e),
                n = new Float32Array(e);
            for (let o = 2; o < t.length; o += 4) r[Math.floor(o / 4)] = t[o], n[Math.floor(o / 4)] = t[o + 1];
            return {
                real: r,
                imag: n
            }
        }

        function o(t, e) {
            return {
                real: t[2 * e],
                imag: t[2 * e + 1]
            }
        }

        function a(t, e, r, n) {
            t[2 * n] = e, t[2 * n + 1] = r
        }

        function l(t, e) {
            const r = new Float32Array(t / 2),
                n = new Float32Array(t / 2);
            for (let o = 0; o < Math.ceil(t / 2); o++) {
                const a = (e ? 2 : -2) * Math.PI * (o / t);
                r[o] = Math.cos(a), n[o] = Math.sin(a)
            }
            return {
                real: r,
                imag: n
            }
        }

        function h(t, e, r) {
            const n = (r ? 2 : -2) * Math.PI * (t / e);
            return {
                real: Math.cos(n),
                imag: Math.sin(n)
            }
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.mergeRealAndImagArrays = t, exports.splitRealAndImagArrays = e, exports.complexWithEvenIndex = r, exports.complexWithOddIndex = n, exports.getComplexWithIndex = o, exports.assignToTypedArray = a, exports.exponents = l, exports.exponent = h;
    }, {}],
    "yei0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var e = {
            castTensor: !0,
            reshapeTensor: !0,
            linspaceImpl: !0,
            upcastType: !0,
            segment_util: !0
        };
        exports.castTensor = q, exports.reshapeTensor = E, exports.linspaceImpl = k, Object.defineProperty(exports, "upcastType", {
            enumerable: !0,
            get: function() {
                return f.upcastType
            }
        }), exports.segment_util = void 0;
        var t = require("../engine"),
            r = require("../ops/scalar"),
            o = require("../ops/tensor1d"),
            n = require("../ops/zeros"),
            u = require("../util"),
            a = require("../ops/axis_util");
        Object.keys(a).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return a[t]
                }
            }))
        });
        var c = require("../ops/broadcast_util");
        Object.keys(c).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return c[t]
                }
            }))
        });
        var s = require("../ops/concat_util");
        Object.keys(s).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return s[t]
                }
            }))
        });
        var p = require("../ops/conv_util");
        Object.keys(p).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return p[t]
                }
            }))
        });
        var l = require("../ops/fused_util");
        Object.keys(l).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return l[t]
                }
            }))
        });
        var i = require("../ops/reduce_util");
        Object.keys(i).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return i[t]
                }
            }))
        });
        var f = require("../types"),
            y = require("../ops/rotate_util");
        Object.keys(y).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return y[t]
                }
            }))
        });
        var d = require("../ops/array_ops_util");
        Object.keys(d).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return d[t]
                }
            }))
        });
        var b = require("../ops/gather_nd_util");
        Object.keys(b).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return b[t]
                }
            }))
        });
        var O = require("../ops/scatter_nd_util");
        Object.keys(O).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return O[t]
                }
            }))
        });
        var _ = require("../ops/selu_util");
        Object.keys(_).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return _[t]
                }
            }))
        });
        var j = require("../ops/erf_util");
        Object.keys(j).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return j[t]
                }
            }))
        });
        var h = require("../log");
        Object.keys(h).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return h[t]
                }
            }))
        });
        var P = require("../backends/complex_util");
        Object.keys(P).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return P[t]
                }
            }))
        });
        var m = require("../ops/split_util");
        Object.keys(m).forEach(function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(exports, t, {
                enumerable: !0,
                get: function() {
                    return m[t]
                }
            }))
        });
        var g = v(require("../ops/segment_util"));

        function x() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return x = function() {
                return e
            }, e
        }

        function v(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = x();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var u = o ? Object.getOwnPropertyDescriptor(e, n) : null;
                    u && (u.get || u.set) ? Object.defineProperty(r, n, u) : r[n] = e[n]
                } return r.default = e, t && t.set(e, r), r
        }

        function q(e, o, a) {
            if ("complex64" === o) {
                if ("complex64" === e.dtype) return e.clone();
                const t = (0, n.zeros)(e.shape),
                    r = e.toFloat(),
                    o = a.complex(r, t);
                return t.dispose(), r.dispose(), o
            }
            if (!(0, u.hasEncodingLoss)(e.dtype, o)) return t.ENGINE.makeTensorFromDataId(e.dataId, e.shape, o);
            if ("complex64" === e.dtype) {
                const t = a.real(e),
                    r = t.cast(o);
                return t.dispose(), r
            }
            if ("int32" === o) return a.int(e);
            if ("bool" === o) {
                const t = (0, r.scalar)(0, e.dtype),
                    o = a.notEqual(e, t);
                return t.dispose(), o
            }
            throw new Error(`Error in Cast: failed to cast ${e.dtype} to ${o}`)
        }

        function E(e, r) {
            return t.ENGINE.makeTensorFromDataId(e.dataId, r, e.dtype)
        }

        function k(e, t, r) {
            const n = (t - e) / (r - 1),
                a = (0, u.makeZerosTypedArray)(r, "float32");
            a[0] = e;
            for (let o = 1; o < a.length; o++) a[o] = a[o - 1] + n;
            return (0, o.tensor1d)(a, "float32")
        }
        exports.segment_util = g;
    }, {
        "../engine": "Nc3Y",
        "../ops/scalar": "Ay42",
        "../ops/tensor1d": "pBg9",
        "../ops/zeros": "R5fo",
        "../util": "P6nv",
        "../ops/axis_util": "DsMP",
        "../ops/broadcast_util": "Xh9J",
        "../ops/concat_util": "Toan",
        "../ops/conv_util": "Evju",
        "../ops/fused_util": "mypO",
        "../ops/reduce_util": "iHyk",
        "../types": "Grh1",
        "../ops/rotate_util": "eAkN",
        "../ops/array_ops_util": "bsd6",
        "../ops/gather_nd_util": "ZyFe",
        "../ops/scatter_nd_util": "H15o",
        "../ops/selu_util": "ssng",
        "../ops/erf_util": "iVXL",
        "../log": "EnTq",
        "../backends/complex_util": "F59n",
        "../ops/split_util": "Z8ze",
        "../ops/segment_util": "U497"
    }],
    "lx8n": [function(require, module, exports) {
        "use strict";

        function e(e, t, r) {
            const s = new Array(e.rank).fill(0),
                n = e.shape.slice();
            return t.map(t => {
                const c = [...n];
                c[r] = t;
                const o = e.slice(s, c);
                return s[r] += t, o
            })
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.split = e;
    }, {}],
    "AkDR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.tile = r;
        var e = require("../ops/buffer");

        function r(r, t) {
            const o = new Array(r.rank);
            for (let e = 0; e < o.length; e++) o[e] = r.shape[e] * t[e];
            const n = (0, e.buffer)(o, r.dtype);
            for (let e = 0; e < n.values.length; ++e) {
                const t = n.indexToLoc(e),
                    o = new Array(r.rank);
                for (let e = 0; e < o.length; e++) o[e] = t[e] % r.shape[e];
                const s = r.locToIndex(o);
                n.values[e] = r.values[s]
            }
            return n.toTensor()
        }
    }, {
        "../ops/buffer": "WyiN"
    }],
    "wWTc": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.topkImpl = t;
        var e = require("../ops/tensor"),
            r = require("../util");

        function t(t, o, n, s, l) {
            const u = o[o.length - 1],
                [a, i] = [t.length / u, u],
                p = (0, r.getTypedArrayFromDType)(n, a * s),
                y = (0, r.getTypedArrayFromDType)("int32", a * s);
            for (let e = 0; e < a; e++) {
                const r = e * i,
                    o = t.subarray(r, r + i),
                    n = [];
                for (let e = 0; e < o.length; e++) n.push({
                    value: o[e],
                    index: e
                });
                n.sort((e, r) => r.value - e.value);
                const l = e * s,
                    u = p.subarray(l, l + s),
                    a = y.subarray(l, l + s);
                for (let e = 0; e < s; e++) u[e] = n[e].value, a[e] = n[e].index
            }
            const c = o.slice();
            return c[c.length - 1] = s, [(0, e.tensor)(p, c, n), (0, e.tensor)(y, c, "int32")]
        }
    }, {
        "../ops/tensor": "P2QC",
        "../util": "P6nv"
    }],
    "F9kw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "nonMaxSuppressionV3Impl", {
            enumerable: !0,
            get: function() {
                return e.nonMaxSuppressionV3Impl
            }
        }), Object.defineProperty(exports, "nonMaxSuppressionV4Impl", {
            enumerable: !0,
            get: function() {
                return e.nonMaxSuppressionV4Impl
            }
        }), Object.defineProperty(exports, "nonMaxSuppressionV5Impl", {
            enumerable: !0,
            get: function() {
                return e.nonMaxSuppressionV5Impl
            }
        }), Object.defineProperty(exports, "split", {
            enumerable: !0,
            get: function() {
                return r.split
            }
        }), Object.defineProperty(exports, "tile", {
            enumerable: !0,
            get: function() {
                return n.tile
            }
        }), Object.defineProperty(exports, "topkImpl", {
            enumerable: !0,
            get: function() {
                return t.topkImpl
            }
        }), Object.defineProperty(exports, "whereImpl", {
            enumerable: !0,
            get: function() {
                return p.whereImpl
            }
        });
        var e = require("./non_max_suppression_impl"),
            r = require("./split_shared"),
            n = require("./tile_impl"),
            t = require("./topk_impl"),
            p = require("./where_impl");
    }, {
        "./non_max_suppression_impl": "zkpa",
        "./split_shared": "lx8n",
        "./tile_impl": "AkDR",
        "./topk_impl": "wWTc",
        "./where_impl": "tgEp"
    }],
    "X4AU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.KernelBackend = exports.DataStorage = exports.EPSILON_FLOAT16 = exports.EPSILON_FLOAT32 = void 0;
        const r = 1e-7;
        exports.EPSILON_FLOAT32 = r;
        const e = 1e-4;
        exports.EPSILON_FLOAT16 = e;
        class t {
            constructor(r, e) {
                this.backend = r, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0
            }
            get(r) {
                return this.data.has(r) || this.dataMover.moveData(this.backend, r), this.data.get(r)
            }
            set(r, e) {
                this.dataIdsCount++, this.data.set(r, e)
            }
            has(r) {
                return this.data.has(r)
            }
            delete(r) {
                return this.dataIdsCount--, this.data.delete(r)
            }
            numDataIds() {
                return this.dataIdsCount
            }
        }
        exports.DataStorage = t;
        class n {
            time(r) {
                return a("time")
            }
            read(r) {
                return a("read")
            }
            readSync(r) {
                return a("readSync")
            }
            numDataIds() {
                return a("numDataIds")
            }
            disposeData(r) {
                return a("disposeData")
            }
            write(r, e, t) {
                return a("write")
            }
            move(r, e, t, n) {
                return a("move")
            }
            memory() {
                return a("memory")
            }
            floatPrecision() {
                return a("floatPrecision")
            }
            epsilon() {
                return 32 === this.floatPrecision() ? r : e
            }
            batchMatMul(r, e, t, n) {
                return a("batchMatMul")
            }
            fusedBatchMatMul({
                a: r,
                b: e,
                transposeA: t,
                transposeB: n,
                bias: u,
                activation: o,
                preluActivationWeights: s
            }) {
                return a("fusedBatchMatMul")
            }
            slice(r, e, t) {
                return a("slice")
            }
            stridedSlice(r, e, t, n) {
                return a("stridedSlice")
            }
            unstack(r, e) {
                return a("unstack")
            }
            reverse(r, e) {
                return a("reverse")
            }
            concat(r, e) {
                return a("concat")
            }
            neg(r) {
                return a("neg")
            }
            add(r, e) {
                return a("add")
            }
            addN(r) {
                return a("addN")
            }
            subtract(r, e) {
                return a("subtract")
            }
            multiply(r, e) {
                return a("multiply")
            }
            realDivide(r, e) {
                return a("realDivide")
            }
            floorDiv(r, e) {
                return a("floorDiv")
            }
            sum(r, e) {
                return a("sum")
            }
            prod(r, e) {
                return a("prod")
            }
            unsortedSegmentSum(r, e, t) {
                return a("unsortedSegmentSum")
            }
            argMin(r, e) {
                return a("argMin")
            }
            argMax(r, e) {
                return a("argMax")
            }
            equal(r, e) {
                return a("equal")
            }
            notEqual(r, e) {
                return a("notEqual")
            }
            less(r, e) {
                return a("less")
            }
            lessEqual(r, e) {
                return a("lessEqual")
            }
            greater(r, e) {
                return a("greater")
            }
            greaterEqual(r, e) {
                return a("greaterEqual")
            }
            logicalNot(r) {
                return a("logicalNot")
            }
            logicalAnd(r, e) {
                return a("logicalAnd")
            }
            logicalOr(r, e) {
                return a("logicalOr")
            }
            where(r) {
                return a("where")
            }
            select(r, e, t) {
                return a("select")
            }
            topk(r, e, t) {
                return a("topk")
            }
            min(r, e) {
                return a("min")
            }
            minimum(r, e) {
                return a("minimum")
            }
            mod(r, e) {
                return a("mod")
            }
            max(r, e) {
                return a("max")
            }
            maximum(r, e) {
                return a("maximum")
            }
            all(r, e) {
                return a("all")
            }
            any(r, e) {
                return a("any")
            }
            squaredDifference(r, e) {
                return a("squaredDifference")
            }
            ceil(r) {
                return a("ceil")
            }
            floor(r) {
                return a("floor")
            }
            round(r) {
                return a("round")
            }
            sign(r) {
                return a("sign")
            }
            isNaN(r) {
                return a("isNaN")
            }
            isInf(r) {
                return a("isInf")
            }
            isFinite(r) {
                return a("isFinite")
            }
            pow(r, e) {
                return a("pow")
            }
            exp(r) {
                return a("exp")
            }
            expm1(r) {
                return a("expm1")
            }
            softmax(r, e) {
                return a("softmax")
            }
            log(r) {
                return a("log")
            }
            log1p(r) {
                return a("log1p")
            }
            sqrt(r) {
                return a("sqrt")
            }
            rsqrt(r) {
                return a("rsqrt")
            }
            square(r) {
                return a("square")
            }
            reciprocal(r) {
                return a("reciprocal")
            }
            relu(r) {
                return a("relu")
            }
            relu6(r) {
                return a("relu6")
            }
            prelu(r, e) {
                return a("prelu")
            }
            elu(r) {
                return a("elu")
            }
            eluDer(r, e) {
                return a("eluDer")
            }
            selu(r) {
                return a("selu")
            }
            int(r) {
                return a("int")
            }
            clip(r, e, t) {
                return a("clip")
            }
            abs(r) {
                return a("abs")
            }
            complexAbs(r) {
                return a("complexAbs")
            }
            sigmoid(r) {
                return a("sigmoid")
            }
            softplus(r) {
                return a("softplus")
            }
            sin(r) {
                return a("sin")
            }
            cos(r) {
                return a("cos")
            }
            tan(r) {
                return a("tan")
            }
            asin(r) {
                return a("asin")
            }
            acos(r) {
                return a("acos")
            }
            atan(r) {
                return a("atan")
            }
            atan2(r, e) {
                return a("atan2")
            }
            sinh(r) {
                return a("sinh")
            }
            cosh(r) {
                return a("cosh")
            }
            tanh(r) {
                return a("tanh")
            }
            asinh(r) {
                return a("asinh")
            }
            acosh(r) {
                return a("acosh")
            }
            atanh(r) {
                return a("atanh")
            }
            erf(r) {
                return a("erf")
            }
            step(r, e) {
                return a("step")
            }
            fusedConv2d({
                input: r,
                filter: e,
                convInfo: t,
                bias: n,
                activation: u,
                preluActivationWeights: o
            }) {
                return a("fusedConv2d")
            }
            conv2d(r, e, t) {
                return a("conv2d")
            }
            conv2dDerInput(r, e, t) {
                return a("conv2dDerInput")
            }
            conv2dDerFilter(r, e, t) {
                return a("conv2dDerFilter")
            }
            fusedDepthwiseConv2D({
                input: r,
                filter: e,
                convInfo: t,
                bias: n,
                activation: u,
                preluActivationWeights: o
            }) {
                return a("fusedDepthwiseConv2D")
            }
            depthwiseConv2D(r, e, t) {
                return a("depthwiseConv2D")
            }
            depthwiseConv2DDerInput(r, e, t) {
                return a("depthwiseConv2DDerInput")
            }
            depthwiseConv2DDerFilter(r, e, t) {
                return a("depthwiseConv2DDerFilter")
            }
            conv3d(r, e, t) {
                return a("conv3d")
            }
            conv3dDerInput(r, e, t) {
                return a("conv3dDerInput")
            }
            conv3dDerFilter(r, e, t) {
                return a("conv3dDerFilter")
            }
            maxPool(r, e) {
                return a("maxPool")
            }
            maxPoolBackprop(r, e, t, n) {
                return a("maxPoolBackprop")
            }
            avgPool(r, e) {
                return a("avgPool")
            }
            avgPoolBackprop(r, e, t) {
                return a("avgPoolBackprop")
            }
            avgPool3d(r, e) {
                return a("avgPool3d")
            }
            avgPool3dBackprop(r, e, t) {
                return a("avgPool3dBackprop")
            }
            maxPool3d(r, e) {
                return a("maxPool3d")
            }
            maxPool3dBackprop(r, e, t, n) {
                return a("maxPool3dBackprop")
            }
            reshape(r, e) {
                return a("reshape")
            }
            cast(r, e) {
                return a("cast")
            }
            tile(r, e) {
                return a("tile")
            }
            pad(r, e, t) {
                return a("pad")
            }
            transpose(r, e) {
                return a("transpose")
            }
            gather(r, e, t) {
                return a("gather")
            }
            gatherND(r, e) {
                return a("gatherND")
            }
            scatterND(r, e, t) {
                return a("scatterND")
            }
            batchToSpaceND(r, e, t) {
                return a("batchToSpaceND")
            }
            spaceToBatchND(r, e, t) {
                return a("spaceToBatchND")
            }
            resizeBilinear(r, e, t, n) {
                return a("resizeBilinear")
            }
            resizeBilinearBackprop(r, e, t) {
                return a("resizeBilinearBackprop")
            }
            resizeNearestNeighbor(r, e, t, n) {
                return a("resizeNearestNeighbor")
            }
            resizeNearestNeighborBackprop(r, e, t) {
                return a("resizeNearestNeighborBackprop")
            }
            batchNorm(r, e, t, n, u, o) {
                return a("batchNorm")
            }
            localResponseNormalization4D(r, e, t, n, u) {
                return a("localResponseNormalization4D")
            }
            LRNGrad(r, e, t, n, u, o, s) {
                return a("LRNGrad")
            }
            multinomial(r, e, t, n) {
                return a("multinomial")
            }
            oneHot(r, e, t, n) {
                return a("oneHot")
            }
            cumsum(r, e, t, n) {
                return a("cumsum")
            }
            nonMaxSuppression(r, e, t, n, u) {
                return a("nonMaxSuppression")
            }
            fft(r) {
                return a("fft")
            }
            ifft(r) {
                return a("ifft")
            }
            complex(r, e) {
                return a("complex")
            }
            real(r) {
                return a("real")
            }
            imag(r) {
                return a("imag")
            }
            cropAndResize(r, e, t, n, u, o) {
                return a("cropAndResize")
            }
            depthToSpace(r, e, t) {
                return a("depthToSpace")
            }
            split(r, e, t) {
                return a("split")
            }
            sparseToDense(r, e, t, n) {
                return a("sparseToDense")
            }
            diag(r) {
                return a("diag")
            }
            fill(r, e, t) {
                return a("fill")
            }
            onesLike(r) {
                return a("onesLike")
            }
            zerosLike(r) {
                return a("zerosLike")
            }
            linspace(r, e, t) {
                return a("linspace")
            }
            dispose() {
                return a("dispose")
            }
        }

        function a(r) {
            throw new Error(`'${r}' not yet implemented or not found in the registry. ` + "Did you forget to import the kernel?")
        }
        exports.KernelBackend = n;
    }, {}],
    "hAHY": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.abs = function() {
            return this.throwIfDisposed(), (0, r.abs)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "rSb9": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.acos = function() {
            return this.throwIfDisposed(), (0, r.acos)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "ZzDz": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.acosh = function() {
            return this.throwIfDisposed(), (0, r.acosh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "mDGp": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.addStrict = function(t) {
            return this.throwIfDisposed(), (0, r.addStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "exjO": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/add"),
            e = require("../../tensor");
        e.Tensor.prototype.add = function(e) {
            return this.throwIfDisposed(), (0, r.add)(this, e)
        };
    }, {
        "../../ops/add": "ZDFV",
        "../../tensor": "DTHt"
    }],
    "Yjqi": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/all"),
            e = require("../../tensor");
        e.Tensor.prototype.all = function(e, t) {
            return this.throwIfDisposed(), (0, r.all)(this, e, t)
        };
    }, {
        "../../ops/all": "VAUj",
        "../../tensor": "DTHt"
    }],
    "iiFF": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/any"),
            e = require("../../tensor");
        e.Tensor.prototype.any = function(e, t) {
            return this.throwIfDisposed(), (0, r.any)(this, e, t)
        };
    }, {
        "../../ops/any": "OF1E",
        "../../tensor": "DTHt"
    }],
    "Y7h7": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/arg_max"),
            e = require("../../tensor");
        e.Tensor.prototype.argMax = function(e) {
            return this.throwIfDisposed(), (0, r.argMax)(this, e)
        };
    }, {
        "../../ops/arg_max": "wSFk",
        "../../tensor": "DTHt"
    }],
    "dZ6W": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/arg_min"),
            e = require("../../tensor");
        e.Tensor.prototype.argMin = function(e) {
            return this.throwIfDisposed(), (0, r.argMin)(this, e)
        };
    }, {
        "../../ops/arg_min": "Zhc7",
        "../../tensor": "DTHt"
    }],
    "BTGh": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor"),
            s = require("../../util");
        r.Tensor.prototype.asScalar = function() {
            return this.throwIfDisposed(), (0, s.assert)(1 === this.size, () => "The array must have only 1 element."), (0, e.reshape)(this, [])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt",
        "../../util": "P6nv"
    }],
    "mipD": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.asType = function(s) {
            return this.throwIfDisposed(), (0, r.cast)(this, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "mL1i": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.as1D = function() {
            return this.throwIfDisposed(), (0, e.reshape)(this, [this.size])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "Xuiy": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.as2D = function(r, s) {
            return this.throwIfDisposed(), (0, e.reshape)(this, [r, s])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "hC0z": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.as3D = function(r, s, t) {
            return this.throwIfDisposed(), (0, e.reshape)(this, [r, s, t])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "TCVi": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.as4D = function(r, s, t, o) {
            return this.throwIfDisposed(), (0, e.reshape)(this, [r, s, t, o])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "pH5u": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.as5D = function(r, s, t, o, i) {
            return this.throwIfDisposed(), (0, e.reshape)(this, [r, s, t, o, i])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "ZS2q": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.asin = function() {
            return this.throwIfDisposed(), (0, r.asin)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "TfWD": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.asinh = function() {
            return this.throwIfDisposed(), (0, r.asinh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Q84r": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.atan = function() {
            return this.throwIfDisposed(), (0, r.atan)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "te8p": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/atan2"),
            r = require("../../tensor");
        r.Tensor.prototype.atan2 = function(r) {
            return this.throwIfDisposed(), (0, t.atan2)(this, r)
        };
    }, {
        "../../ops/atan2": "eUJw",
        "../../tensor": "DTHt"
    }],
    "EIXR": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.atanh = function() {
            return this.throwIfDisposed(), (0, r.atanh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Fqu3": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/avg_pool"),
            r = require("../../tensor");
        r.Tensor.prototype.avgPool = function(r, e, t, s) {
            return this.throwIfDisposed(), (0, o.avgPool)(this, r, e, t, s)
        };
    }, {
        "../../ops/avg_pool": "iP9e",
        "../../tensor": "DTHt"
    }],
    "YAFz": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/batch_to_space_nd"),
            e = require("../../tensor");
        e.Tensor.prototype.batchToSpaceND = function(e, r) {
            return this.throwIfDisposed(), (0, t.batchToSpaceND)(this, e, r)
        };
    }, {
        "../../ops/batch_to_space_nd": "Q9gF",
        "../../tensor": "DTHt"
    }],
    "heJa": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/batchnorm"),
            t = require("../../tensor");
        t.Tensor.prototype.batchNorm = function(t, o, e, s, i) {
            return this.throwIfDisposed(), (0, r.batchNorm)(this, t, o, e, s, i)
        };
    }, {
        "../../ops/batchnorm": "qqTf",
        "../../tensor": "DTHt"
    }],
    "lVOQ": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/broadcast_to"),
            o = require("../../tensor");
        o.Tensor.prototype.broadcastTo = function(o) {
            return this.throwIfDisposed(), (0, r.broadcastTo)(this, o)
        };
    }, {
        "../../ops/broadcast_to": "qUV0",
        "../../tensor": "DTHt"
    }],
    "lZjr": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.cast = function(s) {
            return this.throwIfDisposed(), (0, r.cast)(this, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "hy2u": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.ceil = function() {
            return this.throwIfDisposed(), (0, e.ceil)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "fSb8": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.clipByValue = function(r, s) {
            return this.throwIfDisposed(), (0, e.clipByValue)(this, r, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "SYfg": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/concat"),
            o = require("../../tensor");
        o.Tensor.prototype.concat = function(r, e) {
            return this.throwIfDisposed(), r instanceof o.Tensor && (r = [r]), (0, t.concat)([this, ...r], e)
        };
    }, {
        "../../ops/concat": "dDdq",
        "../../tensor": "DTHt"
    }],
    "yTi7": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/conv1d"),
            o = require("../../tensor");
        o.Tensor.prototype.conv1d = function(o, e, t, s, n, i) {
            return this.throwIfDisposed(), (0, r.conv1d)(this, o, e, t, s, n, i)
        };
    }, {
        "../../ops/conv1d": "n3wz",
        "../../tensor": "DTHt"
    }],
    "YdaE": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/conv2d_transpose"),
            s = require("../../tensor");
        s.Tensor.prototype.conv2dTranspose = function(s, o, e, n, t) {
            return this.throwIfDisposed(), (0, r.conv2dTranspose)(this, s, o, e, n, t)
        };
    }, {
        "../../ops/conv2d_transpose": "GCOF",
        "../../tensor": "DTHt"
    }],
    "VuHV": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/conv2d"),
            o = require("../../tensor");
        o.Tensor.prototype.conv2d = function(o, e, t, s, n, i) {
            return this.throwIfDisposed(), (0, r.conv2d)(this, o, e, t, s, n, i)
        };
    }, {
        "../../ops/conv2d": "oJQk",
        "../../tensor": "DTHt"
    }],
    "tRrk": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.cos = function() {
            return this.throwIfDisposed(), (0, r.cos)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "m7UX": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.cosh = function() {
            return this.throwIfDisposed(), (0, r.cosh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Plz3": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/cumsum"),
            s = require("../../tensor");
        s.Tensor.prototype.cumsum = function(s, u, e) {
            return this.throwIfDisposed(), (0, r.cumsum)(this, s, u, e)
        };
    }, {
        "../../ops/cumsum": "Kzhc",
        "../../tensor": "DTHt"
    }],
    "gpZR": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/depth_to_space"),
            t = require("../../tensor");
        t.Tensor.prototype.depthToSpace = function(t, r) {
            return this.throwIfDisposed(), (0, e.depthToSpace)(this, t, r)
        };
    }, {
        "../../ops/depth_to_space": "U4UL",
        "../../tensor": "DTHt"
    }],
    "NNEi": [function(require, module, exports) {
        "use strict";
        var e = require("../../globals"),
            s = require("../../ops/depthwise_conv2d"),
            t = require("../../tensor");
        t.Tensor.prototype.depthwiseConv2D = function(t, r, i, o, d, n) {
            return (0, e.deprecationWarn)("depthwiseConv2D is deprecated, use depthwiseConv2d instead"), this.throwIfDisposed(), (0, s.depthwiseConv2d)(this, t, r, i, o, d, n)
        };
    }, {
        "../../globals": "GWnL",
        "../../ops/depthwise_conv2d": "Kahd",
        "../../tensor": "DTHt"
    }],
    "qY3A": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/depthwise_conv2d"),
            t = require("../../tensor");
        t.Tensor.prototype.depthwiseConv2d = function(t, r, s, o, i, n) {
            return this.throwIfDisposed(), (0, e.depthwiseConv2d)(this, t, r, s, o, i, n)
        };
    }, {
        "../../ops/depthwise_conv2d": "Kahd",
        "../../tensor": "DTHt"
    }],
    "r5pA": [function(require, module, exports) {
        "use strict";
        var i = require("../../ops/dilation2d"),
            t = require("../../tensor");
        t.Tensor.prototype.dilation2d = function(t, r, o, e, s) {
            return this.throwIfDisposed(), (0, i.dilation2d)(this, t, r, o, e, s)
        };
    }, {
        "../../ops/dilation2d": "q2Zv",
        "../../tensor": "DTHt"
    }],
    "ezkx": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/div_no_nan"),
            o = require("../../tensor");
        o.Tensor.prototype.divNoNan = function(o) {
            return this.throwIfDisposed(), (0, r.divNoNan)(this, o)
        };
    }, {
        "../../ops/div_no_nan": "mdNH",
        "../../tensor": "DTHt"
    }],
    "iqWL": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.divStrict = function(t) {
            return this.throwIfDisposed(), (0, r.divStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "lByl": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/div"),
            e = require("../../tensor");
        e.Tensor.prototype.div = function(e) {
            return this.throwIfDisposed(), (0, r.div)(this, e)
        };
    }, {
        "../../ops/div": "D8Fc",
        "../../tensor": "DTHt"
    }],
    "AmE9": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/dot"),
            r = require("../../tensor");
        r.Tensor.prototype.dot = function(r) {
            return this.throwIfDisposed(), (0, t.dot)(this, r)
        };
    }, {
        "../../ops/dot": "bUs4",
        "../../tensor": "DTHt"
    }],
    "ZWIj": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/elu"),
            r = require("../../tensor");
        r.Tensor.prototype.elu = function() {
            return this.throwIfDisposed(), (0, e.elu)(this)
        };
    }, {
        "../../ops/elu": "a7Il",
        "../../tensor": "DTHt"
    }],
    "wrOz": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.equalStrict = function(t) {
            return this.throwIfDisposed(), (0, r.equalStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Xg4w": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/equal"),
            r = require("../../tensor");
        r.Tensor.prototype.equal = function(r) {
            return this.throwIfDisposed(), (0, e.equal)(this, r)
        };
    }, {
        "../../ops/equal": "WG94",
        "../../tensor": "DTHt"
    }],
    "c95I": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            e = require("../../tensor");
        e.Tensor.prototype.erf = function() {
            return this.throwIfDisposed(), (0, r.erf)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "uHAD": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.exp = function() {
            return this.throwIfDisposed(), (0, e.exp)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "n4T6": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/expand_dims"),
            r = require("../../tensor");
        r.Tensor.prototype.expandDims = function(r) {
            return this.throwIfDisposed(), (0, e.expandDims)(this, r)
        };
    }, {
        "../../ops/expand_dims": "XF6l",
        "../../tensor": "DTHt"
    }],
    "YSEy": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.expm1 = function() {
            return this.throwIfDisposed(), (0, e.expm1)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "ONAF": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.fft = function() {
            return this.throwIfDisposed(), (0, r.fft)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "nzjH": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.flatten = function() {
            return this.throwIfDisposed(), (0, e.reshape)(this, [this.size])
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "aXpv": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.floor = function() {
            return this.throwIfDisposed(), (0, r.floor)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Stcd": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/floorDiv"),
            o = require("../../tensor");
        o.Tensor.prototype.floorDiv = function(o) {
            return this.throwIfDisposed(), (0, r.floorDiv)(this, o)
        };
    }, {
        "../../ops/floorDiv": "Pk64",
        "../../tensor": "DTHt"
    }],
    "pqmf": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/gather"),
            e = require("../../tensor");
        e.Tensor.prototype.gather = function(e, t) {
            return this.throwIfDisposed(), (0, r.gather)(this, e, t)
        };
    }, {
        "../../ops/gather": "ESvM",
        "../../tensor": "DTHt"
    }],
    "av7B": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.greaterEqualStrict = function(t) {
            return this.throwIfDisposed(), (0, r.greaterEqualStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "BPNR": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/greater_equal"),
            e = require("../../tensor");
        e.Tensor.prototype.greaterEqual = function(e) {
            return this.throwIfDisposed(), (0, r.greaterEqual)(this, e)
        };
    }, {
        "../../ops/greater_equal": "Dbo2",
        "../../tensor": "DTHt"
    }],
    "pAc3": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.greaterStrict = function(t) {
            return this.throwIfDisposed(), (0, r.greaterStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Zkuh": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/greater"),
            e = require("../../tensor");
        e.Tensor.prototype.greater = function(e) {
            return this.throwIfDisposed(), (0, r.greater)(this, e)
        };
    }, {
        "../../ops/greater": "QdS7",
        "../../tensor": "DTHt"
    }],
    "mMKa": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.ifft = function() {
            return this.throwIfDisposed(), (0, r.ifft)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "cuqs": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.irfft = function() {
            return this.throwIfDisposed(), (0, r.irfft)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "MNux": [function(require, module, exports) {
        "use strict";
        var i = require("../../ops/ops"),
            e = require("../../tensor");
        e.Tensor.prototype.isFinite = function() {
            return this.throwIfDisposed(), (0, i.isFinite)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "nF1c": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.isInf = function() {
            return this.throwIfDisposed(), (0, r.isInf)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "uo5y": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.isNaN = function() {
            return this.throwIfDisposed(), (0, r.isNaN)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "DhH2": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/leaky_relu"),
            r = require("../../tensor");
        r.Tensor.prototype.leakyRelu = function(r) {
            return this.throwIfDisposed(), (0, e.leakyRelu)(this, r)
        };
    }, {
        "../../ops/leaky_relu": "hUKE",
        "../../tensor": "DTHt"
    }],
    "Jw5V": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.lessEqualStrict = function(s) {
            return this.throwIfDisposed(), (0, r.lessEqualStrict)(this, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "izlZ": [function(require, module, exports) {
        "use strict";
        var s = require("../../ops/less_equal"),
            e = require("../../tensor");
        e.Tensor.prototype.lessEqual = function(e) {
            return this.throwIfDisposed(), (0, s.lessEqual)(this, e)
        };
    }, {
        "../../ops/less_equal": "FvS1",
        "../../tensor": "DTHt"
    }],
    "zsYh": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.lessStrict = function(s) {
            return this.throwIfDisposed(), (0, r.lessStrict)(this, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "abOQ": [function(require, module, exports) {
        "use strict";
        var s = require("../../ops/less"),
            e = require("../../tensor");
        e.Tensor.prototype.less = function(e) {
            return this.throwIfDisposed(), (0, s.less)(this, e)
        };
    }, {
        "../../ops/less": "Ndy5",
        "../../tensor": "DTHt"
    }],
    "aCE7": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/local_response_normalization"),
            e = require("../../tensor");
        e.Tensor.prototype.localResponseNormalization = function(e, r, s, i) {
            return this.throwIfDisposed(), (0, o.localResponseNormalization)(this, e, r, s, i)
        };
    }, {
        "../../ops/local_response_normalization": "wFSX",
        "../../tensor": "DTHt"
    }],
    "ss0N": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.logSigmoid = function() {
            return this.throwIfDisposed(), (0, o.logSigmoid)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "MVKK": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.logSoftmax = function(r) {
            return this.throwIfDisposed(), (0, o.logSoftmax)(this, r)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "ismY": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/log_sum_exp"),
            e = require("../../tensor");
        e.Tensor.prototype.logSumExp = function(e, o) {
            return this.throwIfDisposed(), (0, r.logSumExp)(this, e, o)
        };
    }, {
        "../../ops/log_sum_exp": "MQ55",
        "../../tensor": "DTHt"
    }],
    "lZRQ": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.log = function() {
            return this.throwIfDisposed(), (0, r.log)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Wf8C": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.log1p = function() {
            return this.throwIfDisposed(), (0, r.log1p)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "FqD2": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/logical_and"),
            o = require("../../tensor");
        o.Tensor.prototype.logicalAnd = function(o) {
            return this.throwIfDisposed(), (0, r.logicalAnd)(this, o)
        };
    }, {
        "../../ops/logical_and": "lYzt",
        "../../tensor": "DTHt"
    }],
    "n5pl": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/logical_not"),
            t = require("../../tensor");
        t.Tensor.prototype.logicalNot = function() {
            return this.throwIfDisposed(), (0, o.logicalNot)(this)
        };
    }, {
        "../../ops/logical_not": "XZse",
        "../../tensor": "DTHt"
    }],
    "butI": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/logical_or"),
            o = require("../../tensor");
        o.Tensor.prototype.logicalOr = function(o) {
            return this.throwIfDisposed(), (0, r.logicalOr)(this, o)
        };
    }, {
        "../../ops/logical_or": "HD5h",
        "../../tensor": "DTHt"
    }],
    "uTs7": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/logical_xor"),
            o = require("../../tensor");
        o.Tensor.prototype.logicalXor = function(o) {
            return this.throwIfDisposed(), (0, r.logicalXor)(this, o)
        };
    }, {
        "../../ops/logical_xor": "FEKV",
        "../../tensor": "DTHt"
    }],
    "nnXQ": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/mat_mul"),
            r = require("../../tensor");
        r.Tensor.prototype.matMul = function(r, e, s) {
            return this.throwIfDisposed(), (0, t.matMul)(this, r, e, s)
        };
    }, {
        "../../ops/mat_mul": "mMWq",
        "../../tensor": "DTHt"
    }],
    "i4md": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/max_pool"),
            r = require("../../tensor");
        r.Tensor.prototype.maxPool = function(r, e, t, s) {
            return this.throwIfDisposed(), (0, o.maxPool)(this, r, e, t, s)
        };
    }, {
        "../../ops/max_pool": "hJeZ",
        "../../tensor": "DTHt"
    }],
    "wKmI": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/max"),
            e = require("../../tensor");
        e.Tensor.prototype.max = function(e, t) {
            return this.throwIfDisposed(), (0, r.max)(this, e, t)
        };
    }, {
        "../../ops/max": "iipD",
        "../../tensor": "DTHt"
    }],
    "u2v8": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.maximumStrict = function(t) {
            return this.throwIfDisposed(), (0, r.maximumStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "ByTA": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/maximum"),
            e = require("../../tensor");
        e.Tensor.prototype.maximum = function(e) {
            return this.throwIfDisposed(), (0, r.maximum)(this, e)
        };
    }, {
        "../../ops/maximum": "X5MV",
        "../../tensor": "DTHt"
    }],
    "EtRN": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/mean"),
            r = require("../../tensor");
        r.Tensor.prototype.mean = function(r, t) {
            return this.throwIfDisposed(), (0, e.mean)(this, r, t)
        };
    }, {
        "../../ops/mean": "jwZo",
        "../../tensor": "DTHt"
    }],
    "bVxv": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/min"),
            e = require("../../tensor");
        e.Tensor.prototype.min = function(e, i) {
            return this.throwIfDisposed(), (0, r.min)(this, e, i)
        };
    }, {
        "../../ops/min": "w9We",
        "../../tensor": "DTHt"
    }],
    "kQuU": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.minimumStrict = function(t) {
            return this.throwIfDisposed(), (0, r.minimumStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "v0BM": [function(require, module, exports) {
        "use strict";
        var i = require("../../ops/minimum"),
            r = require("../../tensor");
        r.Tensor.prototype.minimum = function(r) {
            return this.throwIfDisposed(), (0, i.minimum)(this, r)
        };
    }, {
        "../../ops/minimum": "crIr",
        "../../tensor": "DTHt"
    }],
    "hBeP": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.modStrict = function(t) {
            return this.throwIfDisposed(), (0, r.modStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "bviV": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/mod"),
            o = require("../../tensor");
        o.Tensor.prototype.mod = function(o) {
            return this.throwIfDisposed(), (0, r.mod)(this, o)
        };
    }, {
        "../../ops/mod": "lYF1",
        "../../tensor": "DTHt"
    }],
    "sxwu": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.mulStrict = function(t) {
            return this.throwIfDisposed(), (0, r.mulStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "yrwH": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/mul"),
            e = require("../../tensor");
        e.Tensor.prototype.mul = function(e) {
            return this.throwIfDisposed(), (0, r.mul)(this, e)
        };
    }, {
        "../../ops/mul": "k2PI",
        "../../tensor": "DTHt"
    }],
    "BdQu": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.neg = function() {
            return this.throwIfDisposed(), (0, e.neg)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "KhHB": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.norm = function(o, e, s) {
            return this.throwIfDisposed(), (0, r.norm)(this, o, e, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Wqhm": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.notEqualStrict = function(r) {
            return this.throwIfDisposed(), (0, t.notEqualStrict)(this, r)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "DMM0": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/not_equal"),
            r = require("../../tensor");
        r.Tensor.prototype.notEqual = function(r) {
            return this.throwIfDisposed(), (0, t.notEqual)(this, r)
        };
    }, {
        "../../ops/not_equal": "jVu5",
        "../../tensor": "DTHt"
    }],
    "qaY4": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/one_hot"),
            e = require("../../tensor");
        e.Tensor.prototype.oneHot = function(e, t = 1, r = 0) {
            return this.throwIfDisposed(), (0, o.oneHot)(this, e, t, r)
        };
    }, {
        "../../ops/one_hot": "ETzZ",
        "../../tensor": "DTHt"
    }],
    "WSxx": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.onesLike = function() {
            return this.throwIfDisposed(), (0, e.onesLike)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "hIgT": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/pad"),
            e = require("../../tensor");
        e.Tensor.prototype.pad = function(e, t) {
            return this.throwIfDisposed(), (0, r.pad)(this, e, t)
        };
    }, {
        "../../ops/pad": "hajs",
        "../../tensor": "DTHt"
    }],
    "B6PO": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/pool"),
            r = require("../../tensor");
        r.Tensor.prototype.pool = function(r, e, t, s, i) {
            return this.throwIfDisposed(), (0, o.pool)(this, r, e, t, s, i)
        };
    }, {
        "../../ops/pool": "T3We",
        "../../tensor": "DTHt"
    }],
    "e4VV": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.powStrict = function(t) {
            return this.throwIfDisposed(), (0, r.powStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "ptfu": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/pow"),
            o = require("../../tensor");
        o.Tensor.prototype.pow = function(o) {
            return this.throwIfDisposed(), (0, r.pow)(this, o)
        };
    }, {
        "../../ops/pow": "vt1B",
        "../../tensor": "DTHt"
    }],
    "Nu7c": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/prelu"),
            e = require("../../tensor");
        e.Tensor.prototype.prelu = function(e) {
            return this.throwIfDisposed(), (0, r.prelu)(this, e)
        };
    }, {
        "../../ops/prelu": "mkuj",
        "../../tensor": "DTHt"
    }],
    "rRJT": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/prod"),
            o = require("../../tensor");
        o.Tensor.prototype.prod = function(o, e) {
            return this.throwIfDisposed(), (0, r.prod)(this, o, e)
        };
    }, {
        "../../ops/prod": "pvB6",
        "../../tensor": "DTHt"
    }],
    "iB18": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            e = require("../../tensor");
        e.Tensor.prototype.reciprocal = function() {
            return this.throwIfDisposed(), (0, r.reciprocal)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "H96b": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/relu"),
            e = require("../../tensor");
        e.Tensor.prototype.relu = function() {
            return this.throwIfDisposed(), (0, r.relu)(this)
        };
    }, {
        "../../ops/relu": "SJP3",
        "../../tensor": "DTHt"
    }],
    "cyjM": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/relu6"),
            e = require("../../tensor");
        e.Tensor.prototype.relu6 = function() {
            return this.throwIfDisposed(), (0, r.relu6)(this)
        };
    }, {
        "../../ops/relu6": "MNkg",
        "../../tensor": "DTHt"
    }],
    "Rvhk": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.reshapeAs = function(r) {
            return this.throwIfDisposed(), (0, e.reshape)(this, r.shape)
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "fRxu": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reshape"),
            r = require("../../tensor");
        r.Tensor.prototype.reshape = function(r) {
            return this.throwIfDisposed(), (0, e.reshape)(this, r)
        };
    }, {
        "../../ops/reshape": "QI4k",
        "../../tensor": "DTHt"
    }],
    "SMt2": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/resize_bilinear"),
            r = require("../../tensor");
        r.Tensor.prototype.resizeBilinear = function(r, i) {
            return this.throwIfDisposed(), (0, e.resizeBilinear)(this, r, i)
        };
    }, {
        "../../ops/resize_bilinear": "uhYK",
        "../../tensor": "DTHt"
    }],
    "RIGW": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/resize_nearest_neighbor"),
            r = require("../../tensor");
        r.Tensor.prototype.resizeNearestNeighbor = function(r, s) {
            return this.throwIfDisposed(), (0, e.resizeNearestNeighbor)(this, r, s)
        };
    }, {
        "../../ops/resize_nearest_neighbor": "OP6T",
        "../../tensor": "DTHt"
    }],
    "fR2E": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/reverse"),
            r = require("../../tensor");
        r.Tensor.prototype.reverse = function(r) {
            return this.throwIfDisposed(), (0, e.reverse)(this, r)
        };
    }, {
        "../../ops/reverse": "SxGN",
        "../../tensor": "DTHt"
    }],
    "YyJO": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.rfft = function() {
            return this.throwIfDisposed(), (0, r.rfft)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "oHSL": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.round = function() {
            return this.throwIfDisposed(), (0, r.round)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Rill": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.rsqrt = function() {
            return this.throwIfDisposed(), (0, r.rsqrt)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "g71a": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/selu"),
            r = require("../../tensor");
        r.Tensor.prototype.selu = function() {
            return this.throwIfDisposed(), (0, e.selu)(this)
        };
    }, {
        "../../ops/selu": "nLmU",
        "../../tensor": "DTHt"
    }],
    "MtTs": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/separable_conv2d"),
            r = require("../../tensor");
        r.Tensor.prototype.separableConv2d = function(r, s, o, t, n, a) {
            return this.throwIfDisposed(), (0, e.separableConv2d)(this, r, s, o, t, n, a)
        };
    }, {
        "../../ops/separable_conv2d": "M7Hy",
        "../../tensor": "DTHt"
    }],
    "gZlU": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.sigmoid = function() {
            return this.throwIfDisposed(), (0, r.sigmoid)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "e2ia": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.sign = function() {
            return this.throwIfDisposed(), (0, r.sign)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "kIM6": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.sin = function() {
            return this.throwIfDisposed(), (0, r.sin)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "UeBt": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.sinh = function() {
            return this.throwIfDisposed(), (0, r.sinh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "UCTo": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.slice = function(r, s) {
            return this.throwIfDisposed(), (0, e.slice)(this, r, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "neuq": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.softmax = function(s) {
            return this.throwIfDisposed(), (0, r.softmax)(this, s)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "KPUl": [function(require, module, exports) {
        "use strict";
        var s = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.softplus = function() {
            return this.throwIfDisposed(), (0, s.softplus)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "YZ0n": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/space_to_batch_nd"),
            e = require("../../tensor");
        e.Tensor.prototype.spaceToBatchND = function(e, r) {
            return this.throwIfDisposed(), (0, t.spaceToBatchND)(this, e, r)
        };
    }, {
        "../../ops/space_to_batch_nd": "rWul",
        "../../tensor": "DTHt"
    }],
    "fYj1": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/split"),
            r = require("../../tensor");
        r.Tensor.prototype.split = function(r, s) {
            return this.throwIfDisposed(), (0, t.split)(this, r, s)
        };
    }, {
        "../../ops/split": "VA1I",
        "../../tensor": "DTHt"
    }],
    "Aqdd": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            s = require("../../tensor");
        s.Tensor.prototype.sqrt = function() {
            return this.throwIfDisposed(), (0, r.sqrt)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "rS2M": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            e = require("../../tensor");
        e.Tensor.prototype.square = function() {
            return this.throwIfDisposed(), (0, r.square)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "AUM6": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/squared_difference"),
            r = require("../../tensor");
        r.Tensor.prototype.squaredDifference = function(r) {
            return this.throwIfDisposed(), (0, e.squaredDifference)(this, r)
        };
    }, {
        "../../ops/squared_difference": "gsmP",
        "../../tensor": "DTHt"
    }],
    "lXXH": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.squaredDifferenceStrict = function(r) {
            return this.throwIfDisposed(), (0, e.squaredDifferenceStrict)(this, r)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "C0g2": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/squeeze"),
            r = require("../../tensor");
        r.Tensor.prototype.squeeze = function(r) {
            return this.throwIfDisposed(), (0, e.squeeze)(this, r)
        };
    }, {
        "../../ops/squeeze": "ZVMV",
        "../../tensor": "DTHt"
    }],
    "h7BE": [function(require, module, exports) {
        "use strict";
        var s = require("../../ops/stack"),
            t = require("../../tensor");
        t.Tensor.prototype.stack = function(r, e) {
            this.throwIfDisposed();
            const o = r instanceof t.Tensor ? [this, r] : [this, ...r];
            return (0, s.stack)(o, e)
        };
    }, {
        "../../ops/stack": "TWBn",
        "../../tensor": "DTHt"
    }],
    "w4V1": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.step = function(r) {
            return this.throwIfDisposed(), (0, e.step)(this, r)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "Im92": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.stridedSlice = function(r, s, t, i, o, d, n, p) {
            return this.throwIfDisposed(), (0, e.stridedSlice)(this, r, s, t, i, o, d, n, p)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "J35v": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.subStrict = function(t) {
            return this.throwIfDisposed(), (0, r.subStrict)(this, t)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "PYtK": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/sub"),
            s = require("../../tensor");
        s.Tensor.prototype.sub = function(s) {
            return this.throwIfDisposed(), (0, r.sub)(this, s)
        };
    }, {
        "../../ops/sub": "dGex",
        "../../tensor": "DTHt"
    }],
    "Xnvz": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/sum"),
            s = require("../../tensor");
        s.Tensor.prototype.sum = function(s, e) {
            return this.throwIfDisposed(), (0, r.sum)(this, s, e)
        };
    }, {
        "../../ops/sum": "ITAy",
        "../../tensor": "DTHt"
    }],
    "tg9T": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.tan = function() {
            return this.throwIfDisposed(), (0, r.tan)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "vCuK": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/ops"),
            t = require("../../tensor");
        t.Tensor.prototype.tanh = function() {
            return this.throwIfDisposed(), (0, r.tanh)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "dovN": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/tile"),
            t = require("../../tensor");
        t.Tensor.prototype.tile = function(t) {
            return this.throwIfDisposed(), (0, e.tile)(this, t)
        };
    }, {
        "../../ops/tile": "mfii",
        "../../tensor": "DTHt"
    }],
    "sA3u": [function(require, module, exports) {
        "use strict";
        var o = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.toBool = function() {
            return this.throwIfDisposed(), (0, o.cast)(this, "bool")
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "HKul": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/ops"),
            o = require("../../tensor");
        o.Tensor.prototype.toFloat = function() {
            return this.throwIfDisposed(), (0, t.cast)(this, "float32")
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "zfU7": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.toInt = function() {
            return this.throwIfDisposed(), (0, t.cast)(this, "int32")
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "V76c": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/topk"),
            r = require("../../tensor");
        r.Tensor.prototype.topk = function(r, o) {
            return this.throwIfDisposed(), (0, t.topk)(this, r, o)
        };
    }, {
        "../../ops/topk": "GNrW",
        "../../tensor": "DTHt"
    }],
    "dCc2": [function(require, module, exports) {
        "use strict";
        var r = require("../../ops/transpose"),
            s = require("../../tensor");
        s.Tensor.prototype.transpose = function(s) {
            return this.throwIfDisposed(), (0, r.transpose)(this, s)
        };
    }, {
        "../../ops/transpose": "uQkx",
        "../../tensor": "DTHt"
    }],
    "jRej": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/unsorted_segment_sum"),
            t = require("../../tensor");
        t.Tensor.prototype.unsortedSegmentSum = function(t, r) {
            return this.throwIfDisposed(), (0, e.unsortedSegmentSum)(this, t, r)
        };
    }, {
        "../../ops/unsorted_segment_sum": "GWRE",
        "../../tensor": "DTHt"
    }],
    "tCpw": [function(require, module, exports) {
        "use strict";
        var t = require("../../ops/unstack"),
            r = require("../../tensor");
        r.Tensor.prototype.unstack = function(r) {
            return this.throwIfDisposed(), (0, t.unstack)(this, r)
        };
    }, {
        "../../ops/unstack": "JDMu",
        "../../tensor": "DTHt"
    }],
    "K1PH": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/where"),
            r = require("../../tensor");
        r.Tensor.prototype.where = function(r, t) {
            return this.throwIfDisposed(), (0, e.where)(r, this, t)
        };
    }, {
        "../../ops/where": "BsuI",
        "../../tensor": "DTHt"
    }],
    "Kgd3": [function(require, module, exports) {
        "use strict";
        var e = require("../../ops/ops"),
            r = require("../../tensor");
        r.Tensor.prototype.zerosLike = function() {
            return this.throwIfDisposed(), (0, e.zerosLike)(this)
        };
    }, {
        "../../ops/ops": "R1mJ",
        "../../tensor": "DTHt"
    }],
    "QTkt": [function(require, module, exports) {
        "use strict";
        require("./abs"), require("./acos"), require("./acosh"), require("./add_strict"), require("./add"), require("./all"), require("./any"), require("./arg_max"), require("./arg_min"), require("./as_scalar"), require("./as_type"), require("./as1d"), require("./as2d"), require("./as3d"), require("./as4d"), require("./as5d"), require("./asin"), require("./asinh"), require("./atan"), require("./atan2"), require("./atanh"), require("./avg_pool"), require("./batch_to_space_nd"), require("./batchnorm"), require("./broadcast_to"), require("./cast"), require("./ceil"), require("./clip_by_value"), require("./concat"), require("./conv1d"), require("./conv2d_transpose"), require("./conv2d"), require("./cos"), require("./cosh"), require("./cumsum"), require("./depth_to_space"), require("./depthwise_conv2D_deprecated"), require("./depthwise_conv2d"), require("./dilation2d"), require("./div_no_nan"), require("./div_strict"), require("./div"), require("./dot"), require("./elu"), require("./equal_strict"), require("./equal"), require("./erf"), require("./exp"), require("./expand_dims"), require("./expm1"), require("./fft"), require("./flatten"), require("./floor"), require("./floorDiv"), require("./gather"), require("./greater_equal_strict"), require("./greater_equal"), require("./greater_strict"), require("./greater"), require("./ifft"), require("./irfft"), require("./is_finite"), require("./is_inf"), require("./is_nan"), require("./leaky_relu"), require("./less_equal_strict"), require("./less_equal"), require("./less_strict"), require("./less"), require("./local_response_normalization"), require("./log_sigmoid"), require("./log_softmax"), require("./log_sum_exp"), require("./log"), require("./log1p"), require("./logical_and"), require("./logical_not"), require("./logical_or"), require("./logical_xor"), require("./mat_mul"), require("./max_pool"), require("./max"), require("./maximum_strict"), require("./maximum"), require("./mean"), require("./min"), require("./minimum_strict"), require("./minimum"), require("./mod_strict"), require("./mod"), require("./mul_strict"), require("./mul"), require("./neg"), require("./norm"), require("./not_equal_strict"), require("./not_equal"), require("./one_hot"), require("./ones_like"), require("./pad"), require("./pool"), require("./pow_strict"), require("./pow"), require("./prelu"), require("./prod"), require("./reciprocal"), require("./relu"), require("./relu6"), require("./reshape_as"), require("./reshape"), require("./resize_bilinear"), require("./resize_nearest_neighbor"), require("./reverse"), require("./rfft"), require("./round"), require("./rsqrt"), require("./selu"), require("./separable_conv2d"), require("./sigmoid"), require("./sign"), require("./sin"), require("./sinh"), require("./slice"), require("./softmax"), require("./softplus"), require("./space_to_batch_nd"), require("./split"), require("./sqrt"), require("./square"), require("./squared_difference"), require("./squared_difference_strict"), require("./squeeze"), require("./stack"), require("./step"), require("./strided_slice"), require("./sub_strict"), require("./sub"), require("./sum"), require("./tan"), require("./tanh"), require("./tile"), require("./to_bool"), require("./to_float"), require("./to_int"), require("./topk"), require("./transpose"), require("./unsorted_segment_sum"), require("./unstack"), require("./where"), require("./zeros_like");
    }, {
        "./abs": "hAHY",
        "./acos": "rSb9",
        "./acosh": "ZzDz",
        "./add_strict": "mDGp",
        "./add": "exjO",
        "./all": "Yjqi",
        "./any": "iiFF",
        "./arg_max": "Y7h7",
        "./arg_min": "dZ6W",
        "./as_scalar": "BTGh",
        "./as_type": "mipD",
        "./as1d": "mL1i",
        "./as2d": "Xuiy",
        "./as3d": "hC0z",
        "./as4d": "TCVi",
        "./as5d": "pH5u",
        "./asin": "ZS2q",
        "./asinh": "TfWD",
        "./atan": "Q84r",
        "./atan2": "te8p",
        "./atanh": "EIXR",
        "./avg_pool": "Fqu3",
        "./batch_to_space_nd": "YAFz",
        "./batchnorm": "heJa",
        "./broadcast_to": "lVOQ",
        "./cast": "lZjr",
        "./ceil": "hy2u",
        "./clip_by_value": "fSb8",
        "./concat": "SYfg",
        "./conv1d": "yTi7",
        "./conv2d_transpose": "YdaE",
        "./conv2d": "VuHV",
        "./cos": "tRrk",
        "./cosh": "m7UX",
        "./cumsum": "Plz3",
        "./depth_to_space": "gpZR",
        "./depthwise_conv2D_deprecated": "NNEi",
        "./depthwise_conv2d": "qY3A",
        "./dilation2d": "r5pA",
        "./div_no_nan": "ezkx",
        "./div_strict": "iqWL",
        "./div": "lByl",
        "./dot": "AmE9",
        "./elu": "ZWIj",
        "./equal_strict": "wrOz",
        "./equal": "Xg4w",
        "./erf": "c95I",
        "./exp": "uHAD",
        "./expand_dims": "n4T6",
        "./expm1": "YSEy",
        "./fft": "ONAF",
        "./flatten": "nzjH",
        "./floor": "aXpv",
        "./floorDiv": "Stcd",
        "./gather": "pqmf",
        "./greater_equal_strict": "av7B",
        "./greater_equal": "BPNR",
        "./greater_strict": "pAc3",
        "./greater": "Zkuh",
        "./ifft": "mMKa",
        "./irfft": "cuqs",
        "./is_finite": "MNux",
        "./is_inf": "nF1c",
        "./is_nan": "uo5y",
        "./leaky_relu": "DhH2",
        "./less_equal_strict": "Jw5V",
        "./less_equal": "izlZ",
        "./less_strict": "zsYh",
        "./less": "abOQ",
        "./local_response_normalization": "aCE7",
        "./log_sigmoid": "ss0N",
        "./log_softmax": "MVKK",
        "./log_sum_exp": "ismY",
        "./log": "lZRQ",
        "./log1p": "Wf8C",
        "./logical_and": "FqD2",
        "./logical_not": "n5pl",
        "./logical_or": "butI",
        "./logical_xor": "uTs7",
        "./mat_mul": "nnXQ",
        "./max_pool": "i4md",
        "./max": "wKmI",
        "./maximum_strict": "u2v8",
        "./maximum": "ByTA",
        "./mean": "EtRN",
        "./min": "bVxv",
        "./minimum_strict": "kQuU",
        "./minimum": "v0BM",
        "./mod_strict": "hBeP",
        "./mod": "bviV",
        "./mul_strict": "sxwu",
        "./mul": "yrwH",
        "./neg": "BdQu",
        "./norm": "KhHB",
        "./not_equal_strict": "Wqhm",
        "./not_equal": "DMM0",
        "./one_hot": "qaY4",
        "./ones_like": "WSxx",
        "./pad": "hIgT",
        "./pool": "B6PO",
        "./pow_strict": "e4VV",
        "./pow": "ptfu",
        "./prelu": "Nu7c",
        "./prod": "rRJT",
        "./reciprocal": "iB18",
        "./relu": "H96b",
        "./relu6": "cyjM",
        "./reshape_as": "Rvhk",
        "./reshape": "fRxu",
        "./resize_bilinear": "SMt2",
        "./resize_nearest_neighbor": "RIGW",
        "./reverse": "fR2E",
        "./rfft": "YyJO",
        "./round": "oHSL",
        "./rsqrt": "Rill",
        "./selu": "g71a",
        "./separable_conv2d": "MtTs",
        "./sigmoid": "gZlU",
        "./sign": "e2ia",
        "./sin": "kIM6",
        "./sinh": "UeBt",
        "./slice": "UCTo",
        "./softmax": "neuq",
        "./softplus": "KPUl",
        "./space_to_batch_nd": "YZ0n",
        "./split": "fYj1",
        "./sqrt": "Aqdd",
        "./square": "rS2M",
        "./squared_difference": "AUM6",
        "./squared_difference_strict": "lXXH",
        "./squeeze": "C0g2",
        "./stack": "h7BE",
        "./step": "w4V1",
        "./strided_slice": "Im92",
        "./sub_strict": "J35v",
        "./sub": "PYtK",
        "./sum": "Xnvz",
        "./tan": "tg9T",
        "./tanh": "vCuK",
        "./tile": "dovN",
        "./to_bool": "sA3u",
        "./to_float": "HKul",
        "./to_int": "zfU7",
        "./topk": "V76c",
        "./transpose": "dCc2",
        "./unsorted_segment_sum": "jRej",
        "./unstack": "tCpw",
        "./where": "K1PH",
        "./zeros_like": "Kgd3"
    }],
    "tc6m": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var e = {
            io: !0,
            math: !0,
            browser: !0,
            gather_util: !0,
            scatter_util: !0,
            slice_util: !0,
            serialization: !0,
            Tensor: !0,
            TensorBuffer: !0,
            Variable: !0,
            tensor_util: !0,
            test_util: !0,
            util: !0,
            version_core: !0,
            AdadeltaOptimizer: !0,
            AdagradOptimizer: !0,
            AdamOptimizer: !0,
            AdamaxOptimizer: !0,
            MomentumOptimizer: !0,
            Optimizer: !0,
            RMSPropOptimizer: !0,
            SGDOptimizer: !0,
            Rank: !0,
            sumOutType: !0,
            upcastType: !0,
            Reduction: !0,
            customGrad: !0,
            grad: !0,
            grads: !0,
            valueAndGrad: !0,
            valueAndGrads: !0,
            variableGrads: !0,
            Environment: !0,
            env: !0,
            ENV: !0,
            nextFrame: !0,
            backend_util: !0,
            device_util: !0,
            kernel_impls: !0,
            KernelBackend: !0,
            DataStorage: !0
        };
        Object.defineProperty(exports, "Tensor", {
            enumerable: !0,
            get: function() {
                return p.Tensor
            }
        }), Object.defineProperty(exports, "TensorBuffer", {
            enumerable: !0,
            get: function() {
                return p.TensorBuffer
            }
        }), Object.defineProperty(exports, "Variable", {
            enumerable: !0,
            get: function() {
                return p.Variable
            }
        }), Object.defineProperty(exports, "version_core", {
            enumerable: !0,
            get: function() {
                return d.version
            }
        }), Object.defineProperty(exports, "AdadeltaOptimizer", {
            enumerable: !0,
            get: function() {
                return m.AdadeltaOptimizer
            }
        }), Object.defineProperty(exports, "AdagradOptimizer", {
            enumerable: !0,
            get: function() {
                return f.AdagradOptimizer
            }
        }), Object.defineProperty(exports, "AdamOptimizer", {
            enumerable: !0,
            get: function() {
                return b.AdamOptimizer
            }
        }), Object.defineProperty(exports, "AdamaxOptimizer", {
            enumerable: !0,
            get: function() {
                return O.AdamaxOptimizer
            }
        }), Object.defineProperty(exports, "MomentumOptimizer", {
            enumerable: !0,
            get: function() {
                return _.MomentumOptimizer
            }
        }), Object.defineProperty(exports, "Optimizer", {
            enumerable: !0,
            get: function() {
                return x.Optimizer
            }
        }), Object.defineProperty(exports, "RMSPropOptimizer", {
            enumerable: !0,
            get: function() {
                return y.RMSPropOptimizer
            }
        }), Object.defineProperty(exports, "SGDOptimizer", {
            enumerable: !0,
            get: function() {
                return g.SGDOptimizer
            }
        }), Object.defineProperty(exports, "Rank", {
            enumerable: !0,
            get: function() {
                return j.Rank
            }
        }), Object.defineProperty(exports, "sumOutType", {
            enumerable: !0,
            get: function() {
                return j.sumOutType
            }
        }), Object.defineProperty(exports, "upcastType", {
            enumerable: !0,
            get: function() {
                return j.upcastType
            }
        }), Object.defineProperty(exports, "Reduction", {
            enumerable: !0,
            get: function() {
                return P.Reduction
            }
        }), Object.defineProperty(exports, "customGrad", {
            enumerable: !0,
            get: function() {
                return h.customGrad
            }
        }), Object.defineProperty(exports, "grad", {
            enumerable: !0,
            get: function() {
                return h.grad
            }
        }), Object.defineProperty(exports, "grads", {
            enumerable: !0,
            get: function() {
                return h.grads
            }
        }), Object.defineProperty(exports, "valueAndGrad", {
            enumerable: !0,
            get: function() {
                return h.valueAndGrad
            }
        }), Object.defineProperty(exports, "valueAndGrads", {
            enumerable: !0,
            get: function() {
                return h.valueAndGrads
            }
        }), Object.defineProperty(exports, "variableGrads", {
            enumerable: !0,
            get: function() {
                return h.variableGrads
            }
        }), Object.defineProperty(exports, "Environment", {
            enumerable: !0,
            get: function() {
                return A.Environment
            }
        }), Object.defineProperty(exports, "env", {
            enumerable: !0,
            get: function() {
                return A.env
            }
        }), Object.defineProperty(exports, "ENV", {
            enumerable: !0,
            get: function() {
                return A.ENV
            }
        }), Object.defineProperty(exports, "nextFrame", {
            enumerable: !0,
            get: function() {
                return w.nextFrame
            }
        }), Object.defineProperty(exports, "KernelBackend", {
            enumerable: !0,
            get: function() {
                return E.KernelBackend
            }
        }), Object.defineProperty(exports, "DataStorage", {
            enumerable: !0,
            get: function() {
                return E.DataStorage
            }
        }), exports.kernel_impls = exports.device_util = exports.backend_util = exports.util = exports.test_util = exports.tensor_util = exports.serialization = exports.slice_util = exports.scatter_util = exports.gather_util = exports.browser = exports.math = exports.io = void 0, require("./engine"), require("./flags"), require("./register_all_gradients"), require("./platforms/platform_browser"), require("./platforms/platform_node");
        var r = D(require("./io/io"));
        exports.io = r;
        var t = D(require("./math"));
        exports.math = t;
        var i = D(require("./ops/browser"));
        exports.browser = i;
        var n = D(require("./ops/gather_nd_util"));
        exports.gather_util = n;
        var o = D(require("./ops/scatter_nd_util"));
        exports.scatter_util = o;
        var u = D(require("./ops/slice_util"));
        exports.slice_util = u;
        var a = D(require("./serialization"));
        exports.serialization = a;
        var p = require("./tensor"),
            s = D(require("./tensor_util"));
        exports.tensor_util = s;
        var l = D(require("./test_util"));
        exports.test_util = l;
        var c = D(require("./util"));
        exports.util = c;
        var d = require("./version"),
            m = require("./optimizers/adadelta_optimizer"),
            f = require("./optimizers/adagrad_optimizer"),
            b = require("./optimizers/adam_optimizer"),
            O = require("./optimizers/adamax_optimizer"),
            _ = require("./optimizers/momentum_optimizer"),
            x = require("./optimizers/optimizer"),
            y = require("./optimizers/rmsprop_optimizer"),
            g = require("./optimizers/sgd_optimizer"),
            j = require("./types"),
            v = D(require("./ops/ops"));
        Object.keys(v).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return v[r]
                }
            }))
        });
        var P = require("./ops/loss_ops_utils"),
            z = require("./train");
        Object.keys(z).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return z[r]
                }
            }))
        });
        var q = require("./globals");
        Object.keys(q).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return q[r]
                }
            }))
        });
        var k = require("./kernel_registry");
        Object.keys(k).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return k[r]
                }
            }))
        });
        var h = require("./gradients"),
            A = require("./environment"),
            w = require("./browser_util"),
            G = D(require("./backends/backend_util"));
        exports.backend_util = G;
        var M = D(require("./device_util"));
        exports.device_util = M;
        var T = D(require("./backends/kernel_impls"));
        exports.kernel_impls = T;
        var E = require("./backends/backend"),
            R = require("./kernel_names");

        function S() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return S = function() {
                return e
            }, e
        }

        function D(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = S();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var o = i ? Object.getOwnPropertyDescriptor(e, n) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, n, o) : t[n] = e[n]
                } return t.default = e, r && r.set(e, t), t
        }
        Object.keys(R).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return R[r]
                }
            }))
        }), require("./public/chained_ops/register_all_chained_ops"), (0, p.setOpHandler)(v);
    }, {
        "./engine": "Nc3Y",
        "./flags": "BElI",
        "./register_all_gradients": "pbwh",
        "./platforms/platform_browser": "szKX",
        "./platforms/platform_node": "sDG1",
        "./io/io": "EwEE",
        "./math": "bMAY",
        "./ops/browser": "yVDt",
        "./ops/gather_nd_util": "ZyFe",
        "./ops/scatter_nd_util": "H15o",
        "./ops/slice_util": "Quoj",
        "./serialization": "HDfU",
        "./tensor": "DTHt",
        "./tensor_util": "fpST",
        "./test_util": "ip5I",
        "./util": "P6nv",
        "./version": "SdA6",
        "./optimizers/adadelta_optimizer": "NZz8",
        "./optimizers/adagrad_optimizer": "oWMZ",
        "./optimizers/adam_optimizer": "K7FB",
        "./optimizers/adamax_optimizer": "NenH",
        "./optimizers/momentum_optimizer": "KNfn",
        "./optimizers/optimizer": "uOca",
        "./optimizers/rmsprop_optimizer": "dtrn",
        "./optimizers/sgd_optimizer": "jyih",
        "./types": "Grh1",
        "./ops/ops": "R1mJ",
        "./ops/loss_ops_utils": "LIoB",
        "./train": "GtIJ",
        "./globals": "GWnL",
        "./kernel_registry": "wJg6",
        "./gradients": "yPDw",
        "./environment": "Fbeg",
        "./browser_util": "mxOd",
        "./backends/backend_util": "yei0",
        "./device_util": "GUPw",
        "./backends/kernel_impls": "F9kw",
        "./backends/backend": "X4AU",
        "./kernel_names": "sdEe",
        "./public/chained_ops/register_all_chained_ops": "QTkt"
    }],
    "pKMt": [function(require, module, exports) {
        "use strict";
        var T, _;
        Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SaverDef = exports.DataType = void 0, exports.DataType = T,
            function(T) {
                T[T.DT_INVALID = 0] = "DT_INVALID", T[T.DT_FLOAT = 1] = "DT_FLOAT", T[T.DT_DOUBLE = 2] = "DT_DOUBLE", T[T.DT_INT32 = 3] = "DT_INT32", T[T.DT_UINT8 = 4] = "DT_UINT8", T[T.DT_INT16 = 5] = "DT_INT16", T[T.DT_INT8 = 6] = "DT_INT8", T[T.DT_STRING = 7] = "DT_STRING", T[T.DT_COMPLEX64 = 8] = "DT_COMPLEX64", T[T.DT_INT64 = 9] = "DT_INT64", T[T.DT_BOOL = 10] = "DT_BOOL", T[T.DT_QINT8 = 11] = "DT_QINT8", T[T.DT_QUINT8 = 12] = "DT_QUINT8", T[T.DT_QINT32 = 13] = "DT_QINT32", T[T.DT_BFLOAT16 = 14] = "DT_BFLOAT16", T[T.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", T[T.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", T[T.DT_INT32_REF = 103] = "DT_INT32_REF", T[T.DT_UINT8_REF = 104] = "DT_UINT8_REF", T[T.DT_INT16_REF = 105] = "DT_INT16_REF", T[T.DT_INT8_REF = 106] = "DT_INT8_REF", T[T.DT_STRING_REF = 107] = "DT_STRING_REF", T[T.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", T[T.DT_INT64_REF = 109] = "DT_INT64_REF", T[T.DT_BOOL_REF = 110] = "DT_BOOL_REF", T[T.DT_QINT8_REF = 111] = "DT_QINT8_REF", T[T.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", T[T.DT_QINT32_REF = 113] = "DT_QINT32_REF", T[T.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF"
            }(T || (exports.DataType = T = {})), exports.SaverDef = _,
            function(T) {
                let _;
                ! function(T) {
                    T[T.LEGACY = 0] = "LEGACY", T[T.V1 = 1] = "V1", T[T.V2 = 2] = "V2"
                }(_ = T.CheckpointFormatVersion || (T.CheckpointFormatVersion = {}))
            }(_ || (exports.SaverDef = _ = {}));
    }, {}],
    "gQtl": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.registerOp = t, exports.getRegisteredOp = r, exports.deregisterOp = s;
        const e = {};

        function t(t, r) {
            const s = {
                tfOpName: t,
                category: "custom",
                inputs: [],
                attrs: [],
                customExecutor: r
            };
            e[t] = s
        }

        function r(t) {
            return e[t]
        }

        function s(t) {
            delete e[t]
        }
    }, {}],
    "w10i": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getParamValue = r, exports.getTensor = o, exports.getTensorsForCurrentContenxt = u, exports.getNodeNameAndIndex = i, exports.parseNodeName = p, exports.split = c, exports.getPadding = a;
        var t = n(require("@tensorflow/tfjs-core"));

        function e() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return e = function() {
                return t
            }, t
        }

        function n(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var n = e();
            if (n && n.has(t)) return n.get(t);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in t)
                if (Object.prototype.hasOwnProperty.call(t, u)) {
                    var i = o ? Object.getOwnPropertyDescriptor(t, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, u, i) : r[u] = t[u]
                } return r.default = t, n && n.set(t, r), r
        }

        function r(e, n, r, u) {
            const i = n.inputParams[e];
            if (i && void 0 !== i.inputIndexStart) {
                const e = i.inputIndexStart,
                    s = 0 === i.inputIndexEnd ? void 0 : void 0 === i.inputIndexEnd ? e + 1 : i.inputIndexEnd;
                if ("tensor" === i.type) return o(n.inputNames[i.inputIndexStart], r, u);
                if ("tensors" === i.type) {
                    return n.inputNames.slice(e, s).map(t => o(t, r, u))
                }
                const p = o(n.inputNames.slice(e)[0], r, u),
                    c = p.dataSync();
                return "number" === i.type ? c[0] : t.util.toNestedArray(p.shape, c)
            }
            const s = n.attrParams[e];
            return s && s.value
        }

        function o(t, e, n) {
            const [r, o] = p(t), u = n.currentContextIds.find(t => !!e[s(r, t)]);
            return void 0 !== u ? e[s(r, u)][o] : void 0
        }

        function u(t, e, n) {
            return e[s(t, n.currentContextId)]
        }

        function i(t, e) {
            const [n, r] = p(t);
            return [s(n, e && e.currentContextId), r]
        }

        function s(t, e) {
            return e ? `${t}-${e}` : t
        }

        function p(t) {
            const e = t.split(":");
            return 1 === e.length ? [t, 0] : [e[0], Number(e[e.length - 1])]
        }

        function c(t, e) {
            const n = [];
            for (let r = 0; r < t.length; r += e) n.push(t.slice(r, r + e));
            return n
        }

        function a(t, e, n) {
            let o = r("pad", t, e, n);
            if ("explicit" === o) {
                o = r("explicitPaddings", t, e, n);
                const u = [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ];
                for (let t = 0; t < 4; t++) u[t][0] = o[2 * t], u[t][1] = o[2 * t + 1];
                return u
            }
            return o
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "cO5O": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "Add",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "AddV2",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "AddN",
            category: "arithmetic",
            inputs: [{
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }]
        }, {
            tfOpName: "BiasAdd",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sub",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "RealDiv",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Div",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "DivNoNan",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "FloorDiv",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Mul",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Maximum",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }]
        }, {
            tfOpName: "Minimum",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }]
        }, {
            tfOpName: "Pow",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "SquaredDifference",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Mod",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "FloorMod",
            category: "arithmetic",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "a7ub": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "Abs",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Acos",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Asin",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Atan",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Atan2",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "y",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Ceil",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "ClipByValue",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "clip_value_min",
                name: "clipValueMin",
                type: "number"
            }, {
                tfName: "clip_value_max",
                name: "clipValueMax",
                type: "number"
            }]
        }, {
            tfOpName: "Complex",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "real",
                type: "tensor"
            }, {
                start: 1,
                name: "imag",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "ComplexAbs",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Cos",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Cosh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Elu",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Exp",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Floor",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Log",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Imag",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "Tout",
                name: "outputType",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Neg",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Real",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "Tout",
                name: "outputType",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Prelu",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "alpha",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Relu",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Relu6",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "clipValueMin",
                name: "clipValueMin",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "clipValueMax",
                name: "clipValueMax",
                type: "number",
                defaultValue: 6
            }]
        }, {
            tfOpName: "Selu",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sigmoid",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sin",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sinh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sqrt",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Rsqrt",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Square",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Tan",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Tanh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Sign",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Round",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Expm1",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Log1p",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Reciprocal",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Softplus",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Asinh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Acosh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Atanh",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Erf",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Prod",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axes",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool",
                notSupported: !0
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "LeakyRelu",
            category: "basic_math",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "alpha",
                name: "alpha",
                type: "number",
                defaultValue: .2
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "sRrn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "LoopCond",
            category: "control",
            inputs: [{
                start: 0,
                name: "pred",
                type: "tensor"
            }]
        }, {
            tfOpName: "Switch",
            category: "control",
            inputs: [{
                start: 0,
                name: "data",
                type: "tensor"
            }, {
                start: 1,
                name: "pred",
                type: "tensor"
            }]
        }, {
            tfOpName: "Merge",
            category: "control",
            inputs: [{
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }]
        }, {
            tfOpName: "Enter",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "frame_name",
                name: "frameName",
                type: "string"
            }, {
                tfName: "is_constant",
                name: "isConstant",
                type: "bool"
            }]
        }, {
            tfOpName: "Exit",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "NextIteration",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "TensorArrayV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "size",
                type: "number"
            }],
            attrs: [{
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "element_shape",
                name: "elementShape",
                type: "shape"
            }, {
                tfName: "dynamic_size",
                name: "dynamicSize",
                type: "bool"
            }, {
                tfName: "clear_after_read",
                name: "clearAfterRead",
                type: "bool"
            }, {
                tfName: "identical_element_shapes",
                name: "identicalElementShapes",
                type: "bool"
            }, {
                tfName: "tensor_array_name",
                name: "name",
                type: "string"
            }]
        }, {
            tfOpName: "TensorArrayWriteV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "index",
                type: "number"
            }, {
                start: 2,
                name: "tensor",
                type: "tensor"
            }, {
                start: 3,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "TensorArrayReadV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "index",
                type: "number"
            }, {
                start: 2,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "dtype",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "TensorArrayGatherV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "number[]"
            }, {
                start: 2,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "element_shape",
                name: "elementShape",
                type: "shape"
            }]
        }, {
            tfOpName: "TensorArrayScatterV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "number[]"
            }, {
                start: 2,
                name: "tensor",
                type: "tensor"
            }, {
                start: 3,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorArrayConcatV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "element_shape_except0",
                name: "elementShapeExcept0",
                type: "shape",
                notSupported: !0
            }]
        }, {
            tfOpName: "TensorArraySplitV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "tensor",
                type: "tensor"
            }, {
                start: 2,
                name: "lengths",
                type: "number[]"
            }, {
                start: 3,
                name: "flowIn",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorArraySizeV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }, {
                start: 1,
                name: "flowIn",
                type: "number"
            }]
        }, {
            tfOpName: "TensorArrayCloseV3",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorArrayId",
                type: "tensor"
            }]
        }, {
            tfOpName: "StatelessIf",
            category: "control",
            inputs: [{
                start: 0,
                name: "cond",
                type: "tensor"
            }, {
                start: 1,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "then_branch",
                name: "thenBranch",
                type: "func"
            }, {
                tfName: "else_branch",
                name: "elseBranch",
                type: "func"
            }]
        }, {
            tfOpName: "If",
            category: "control",
            inputs: [{
                start: 0,
                name: "cond",
                type: "tensor"
            }, {
                start: 1,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "then_branch",
                name: "thenBranch",
                type: "func"
            }, {
                tfName: "else_branch",
                name: "elseBranch",
                type: "func"
            }]
        }, {
            tfOpName: "StatelessWhile",
            category: "control",
            inputs: [{
                start: 0,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "cond",
                name: "cond",
                type: "func"
            }, {
                tfName: "body",
                name: "body",
                type: "func"
            }]
        }, {
            tfOpName: "While",
            category: "control",
            inputs: [{
                start: 0,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "cond",
                name: "cond",
                type: "func"
            }, {
                tfName: "body",
                name: "body",
                type: "func"
            }]
        }, {
            tfOpName: "TensorListScatter",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "number[]"
            }, {
                start: 2,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListScatterV2",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "number[]"
            }, {
                start: 2,
                name: "elementShape",
                type: "shape"
            }, {
                start: 3,
                name: "numElements",
                type: "number"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListGather",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "number[]"
            }, {
                start: 2,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListGetItem",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "index",
                type: "number"
            }, {
                start: 2,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListSetItem",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "index",
                type: "number"
            }, {
                start: 2,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListReserve",
            category: "control",
            inputs: [{
                start: 0,
                name: "elementShape",
                type: "shape"
            }, {
                start: 1,
                name: "numElements",
                type: "number"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListFromTensor",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }, {
                start: 1,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListStack",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }, {
                tfName: "num_elements",
                name: "numElements",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListSplit",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }, {
                start: 1,
                name: "elementShape",
                type: "shape"
            }, {
                start: 2,
                name: "lengths",
                type: "number[]"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListConcat",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }],
            attrs: [{
                tfName: "element_shape",
                name: "elementShape",
                type: "shape"
            }, {
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListPopBack",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "elementShape",
                type: "shape"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }, {
            tfOpName: "TensorListPushBack",
            category: "control",
            inputs: [{
                start: 0,
                name: "tensorListId",
                type: "tensor"
            }, {
                start: 1,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "element_dtype",
                name: "elementDType",
                type: "dtype"
            }]
        }];
        exports.json = e;
    }, {}],
    "GT2x": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "AvgPool",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }, {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "MaxPool",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }, {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "MaxPoolWithArgmax",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            }, {
                tfName: "include_batch_in_index",
                name: "includeBatchInIndex",
                type: "bool"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "AvgPool3D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }, {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "MaxPool3D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }, {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Conv1D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "stride",
                name: "stride",
                type: "number"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NWC"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "dilation",
                name: "dilation",
                type: "number",
                defaultValue: 1
            }]
        }, {
            tfOpName: "Conv2D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "useCudnnOnGpu",
                name: "useCudnnOnGpu",
                type: "bool"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }]
        }, {
            tfOpName: "_FusedConv2D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }, {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            }, {
                tfName: "use_cudnn_on_gpu",
                name: "useCudnnOnGpu",
                type: "bool",
                defaultValue: !0
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]",
                defaultValue: [1, 1, 1, 1]
            }, {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            }, {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 1e-4
            }]
        }, {
            tfOpName: "Conv2DBackpropInput",
            category: "convolution",
            inputs: [{
                start: 2,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }, {
                start: 0,
                name: "outputShape",
                type: "number[]"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }, {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            }]
        }, {
            tfOpName: "DepthwiseConv2d",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "input",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }]
        }, {
            tfOpName: "DepthwiseConv2dNative",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "input",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }]
        }, {
            tfOpName: "FusedDepthwiseConv2dNative",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }, {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]",
                defaultValue: [1, 1, 1, 1]
            }, {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            }]
        }, {
            tfOpName: "Conv3D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            }, {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }]
        }, {
            tfOpName: "Dilation2D",
            category: "convolution",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "filter",
                type: "tensor"
            }],
            attrs: [{
                tfName: "strides",
                name: "strides",
                type: "number[]"
            }, {
                tfName: "rates",
                name: "dilations",
                type: "number[]"
            }, {
                tfName: "padding",
                name: "pad",
                type: "string"
            }]
        }];
        exports.json = t;
    }, {}],
    "A4xH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "Fill",
            category: "creation",
            inputs: [{
                start: 0,
                name: "shape",
                type: "number[]"
            }, {
                start: 1,
                name: "value",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "LinSpace",
            category: "creation",
            inputs: [{
                start: 0,
                name: "start",
                type: "number"
            }, {
                start: 1,
                name: "stop",
                type: "number"
            }, {
                start: 2,
                name: "num",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "OneHot",
            category: "creation",
            inputs: [{
                start: 0,
                name: "indices",
                type: "tensor"
            }, {
                start: 1,
                name: "depth",
                type: "number"
            }, {
                start: 2,
                name: "onValue",
                type: "number",
                defaultValue: 1
            }, {
                start: 3,
                name: "offValue",
                type: "number",
                defaultValue: 0
            }],
            attrs: [{
                tfName: "axis",
                name: "axis",
                type: "number",
                notSupported: !0
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Ones",
            category: "creation",
            inputs: [{
                start: 0,
                name: "shape",
                type: "number[]"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "OnesLike",
            category: "creation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "RandomUniform",
            category: "creation",
            inputs: [{
                start: 0,
                name: "shape",
                type: "number[]"
            }],
            attrs: [{
                tfName: "minval",
                name: "minval",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "maxval",
                name: "maxval",
                type: "number",
                defaultValue: 1
            }, {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "seed",
                name: "seed",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "seed2",
                name: "seed2",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            }, {
                tfName: "T",
                name: "T",
                type: "number",
                notSupported: !0
            }]
        }, {
            tfOpName: "Range",
            category: "creation",
            inputs: [{
                start: 0,
                name: "start",
                type: "number"
            }, {
                start: 1,
                name: "stop",
                type: "number"
            }, {
                start: 2,
                name: "step",
                type: "number",
                defaultValue: 0
            }],
            attrs: [{
                tfName: "Tidx",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "TruncatedNormal",
            category: "creation",
            inputs: [{
                start: 0,
                name: "shape",
                type: "number[]"
            }],
            attrs: [{
                tfName: "means",
                name: "mean",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "stddev",
                name: "stdDev",
                type: "number",
                defaultValue: 1
            }, {
                tfName: "seed",
                name: "seed",
                type: "number"
            }, {
                tfName: "seed2",
                name: "seed2",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            }, {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "T",
                name: "T",
                type: "number",
                notSupported: !0
            }]
        }, {
            tfOpName: "Zeros",
            category: "creation",
            inputs: [{
                start: 0,
                name: "shape",
                type: "number[]"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "ZerosLike",
            category: "creation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "Multinomial",
            category: "creation",
            inputs: [{
                start: 0,
                name: "logits",
                type: "tensor"
            }, {
                start: 1,
                name: "numSamples",
                type: "number"
            }],
            attrs: [{
                tfName: "seed",
                name: "seed",
                type: "number"
            }, {
                tfName: "seed2",
                name: "seed2",
                type: "number"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }, {
                tfName: "output_dtype",
                name: "output_dtype",
                type: "dtype"
            }]
        }];
        exports.json = e;
    }, {}],
    "N7t0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "NonMaxSuppressionV2",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "boxes",
                type: "tensor"
            }, {
                start: 1,
                name: "scores",
                type: "tensor"
            }, {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            }, {
                start: 3,
                name: "iouThreshold",
                type: "number"
            }]
        }, {
            tfOpName: "NonMaxSuppressionV3",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "boxes",
                type: "tensor"
            }, {
                start: 1,
                name: "scores",
                type: "tensor"
            }, {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            }, {
                start: 3,
                name: "iouThreshold",
                type: "number"
            }, {
                start: 4,
                name: "scoreThreshold",
                type: "number"
            }]
        }, {
            tfOpName: "NonMaxSuppressionV4",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "boxes",
                type: "tensor"
            }, {
                start: 1,
                name: "scores",
                type: "tensor"
            }, {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            }, {
                start: 3,
                name: "iouThreshold",
                type: "number"
            }, {
                start: 4,
                name: "scoreThreshold",
                type: "number"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "T_threshold",
                name: "threshold",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "pad_to_max_output_size",
                name: "padToMaxOutputSize",
                type: "bool"
            }]
        }, {
            tfOpName: "NonMaxSuppressionV5",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "boxes",
                type: "tensor"
            }, {
                start: 1,
                name: "scores",
                type: "tensor"
            }, {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            }, {
                start: 3,
                name: "iouThreshold",
                type: "number"
            }, {
                start: 4,
                name: "scoreThreshold",
                type: "number"
            }, {
                start: 5,
                name: "softNmsSigma",
                type: "number"
            }]
        }, {
            tfOpName: "Where",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "condition",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "ListDiff",
            category: "dynamic",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "y",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "gtBU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "TopKV2",
            category: "evaluation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "k",
                type: "number"
            }],
            attrs: [{
                tfName: "sorted",
                name: "sorted",
                type: "bool"
            }]
        }];
        exports.json = e;
    }, {}],
    "YWEf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "PlaceholderWithDefault",
            category: "graph",
            inputs: [{
                start: 0,
                name: "default",
                type: "tensor"
            }],
            attrs: [{
                tfName: "shape",
                name: "shape",
                type: "shape"
            }, {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "Placeholder",
            category: "graph",
            attrs: [{
                tfName: "shape",
                name: "shape",
                type: "shape"
            }, {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "Const",
            category: "graph"
        }, {
            tfOpName: "Identity",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "IdentityN",
            category: "graph",
            inputs: [{
                start: 0,
                end: 0,
                name: "x",
                type: "tensors"
            }]
        }, {
            tfOpName: "Snapshot",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "Rank",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "Size",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "Shape",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "ShapeN",
            category: "graph",
            inputs: [{
                start: 0,
                end: 0,
                name: "x",
                type: "tensors"
            }]
        }, {
            tfOpName: "Print",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "data",
                type: "tensors"
            }],
            attrs: [{
                tfName: "message",
                name: "message",
                type: "string"
            }, {
                tfName: "first_n",
                name: "firstN",
                type: "number",
                notSupported: !0
            }, {
                tfName: "summarize",
                name: "summarize",
                type: "number",
                defaultValue: 3
            }]
        }, {
            tfOpName: "NoOp",
            category: "graph",
            inputs: []
        }, {
            tfOpName: "StopGradient",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "FakeQuantWithMinMaxVars",
            category: "graph",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "min",
                name: "min",
                type: "number"
            }, {
                tfName: "max",
                name: "max",
                type: "number"
            }]
        }];
        exports.json = t;
    }, {}],
    "ooyd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "ResizeBilinear",
            category: "image",
            inputs: [{
                start: 0,
                name: "images",
                type: "tensor"
            }, {
                start: 1,
                name: "size",
                type: "number[]"
            }],
            attrs: [{
                tfName: "align_corners",
                name: "alignCorners",
                type: "bool"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "ResizeNearestNeighbor",
            category: "image",
            inputs: [{
                start: 0,
                name: "images",
                type: "tensor"
            }, {
                start: 1,
                name: "size",
                type: "number[]"
            }],
            attrs: [{
                tfName: "align_corners",
                name: "alignCorners",
                type: "bool"
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "CropAndResize",
            category: "image",
            inputs: [{
                start: 0,
                name: "image",
                type: "tensor"
            }, {
                start: 1,
                name: "boxes",
                type: "tensor"
            }, {
                start: 2,
                name: "boxInd",
                type: "tensor"
            }, {
                start: 3,
                name: "cropSize",
                type: "number[]"
            }],
            attrs: [{
                tfName: "method",
                name: "method",
                type: "string"
            }, {
                tfName: "extrapolation_value",
                name: "extrapolationValue",
                type: "number"
            }]
        }];
        exports.json = e;
    }, {}],
    "SvFw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "Equal",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "NotEqual",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Greater",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "GreaterEqual",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Less",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "LessEqual",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "LogicalAnd",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "LogicalNot",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "LogicalOr",
            category: "logical",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Select",
            category: "logical",
            inputs: [{
                start: 0,
                name: "condition",
                type: "tensor"
            }, {
                start: 1,
                name: "a",
                type: "tensor"
            }, {
                start: 2,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "SelectV2",
            category: "logical",
            inputs: [{
                start: 0,
                name: "condition",
                type: "tensor"
            }, {
                start: 1,
                name: "a",
                type: "tensor"
            }, {
                start: 2,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "vBB5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "_FusedMatMul",
            category: "matrices",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }, {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }],
            attrs: [{
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            }, {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            }, {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 1e-4
            }, {
                tfName: "transpose_a",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "transpose_b",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "MatMul",
            category: "matrices",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "transpose_a",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "transpose_b",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "BatchMatMul",
            category: "matrices",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "adj_x",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "adj_y",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "BatchMatMulV2",
            category: "matrices",
            inputs: [{
                start: 0,
                name: "a",
                type: "tensor"
            }, {
                start: 1,
                name: "b",
                type: "tensor"
            }],
            attrs: [{
                tfName: "adj_x",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "adj_y",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            }, {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }, {
            tfOpName: "Transpose",
            category: "matrices",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "perm",
                type: "number[]"
            }],
            attrs: [{
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }]
        }];
        exports.json = e;
    }, {}],
    "VBGq": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "FusedBatchNorm",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "scale",
                type: "tensor"
            }, {
                start: 2,
                name: "offset",
                type: "tensor"
            }, {
                start: 3,
                name: "mean",
                type: "tensor"
            }, {
                start: 4,
                name: "variance",
                type: "tensor"
            }],
            attrs: [{
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: .001
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }]
        }, {
            tfOpName: "FusedBatchNormV2",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "scale",
                type: "tensor"
            }, {
                start: 2,
                name: "offset",
                type: "tensor"
            }, {
                start: 3,
                name: "mean",
                type: "tensor"
            }, {
                start: 4,
                name: "variance",
                type: "tensor"
            }],
            attrs: [{
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: .001
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }]
        }, {
            tfOpName: "FusedBatchNormV3",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "scale",
                type: "tensor"
            }, {
                start: 2,
                name: "offset",
                type: "tensor"
            }, {
                start: 3,
                name: "mean",
                type: "tensor"
            }, {
                start: 4,
                name: "variance",
                type: "tensor"
            }],
            attrs: [{
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: .001
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }]
        }, {
            tfOpName: "LRN",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "depth_radius",
                name: "radius",
                type: "number",
                defaultValue: 5
            }, {
                tfName: "bias",
                name: "bias",
                type: "number",
                defaultValue: 1
            }, {
                tfName: "alpha",
                name: "alpha",
                type: "number",
                defaultValue: 1
            }, {
                tfName: "beta",
                name: "beta",
                type: "number",
                defaultValue: .5
            }]
        }, {
            tfOpName: "Softmax",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "LogSoftmax",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "SparseToDense",
            category: "normalization",
            inputs: [{
                start: 0,
                name: "sparseIndices",
                type: "tensor"
            }, {
                start: 1,
                name: "outputShape",
                type: "number[]"
            }, {
                start: 2,
                name: "sparseValues",
                type: "tensor"
            }, {
                start: 3,
                name: "defaultValue",
                type: "tensor"
            }],
            attrs: [{
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                defaultValue: !0,
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "tqog": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "Max",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "Mean",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "Min",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "Sum",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "All",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "Any",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "ArgMax",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number"
            }]
        }, {
            tfOpName: "ArgMin",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number"
            }]
        }, {
            tfOpName: "Prod",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }],
            attrs: [{
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }]
        }, {
            tfOpName: "Cumsum",
            category: "reduction",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number"
            }],
            attrs: [{
                tfName: "exclusive",
                name: "exclusive",
                type: "bool"
            }, {
                tfName: "reverse",
                name: "reverse",
                type: "bool"
            }]
        }];
        exports.json = e;
    }, {}],
    "N4YI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const e = [{
            tfOpName: "ConcatV2",
            category: "slice_join",
            inputs: [{
                start: 0,
                end: -1,
                name: "tensors",
                type: "tensors"
            }, {
                start: -1,
                name: "axis",
                type: "number"
            }],
            attrs: [{
                tfName: "N",
                name: "n",
                type: "number",
                defaultValue: 2
            }]
        }, {
            tfOpName: "Concat",
            category: "slice_join",
            inputs: [{
                start: 1,
                end: 0,
                name: "tensors",
                type: "tensors"
            }, {
                start: 0,
                name: "axis",
                type: "number"
            }],
            attrs: [{
                tfName: "N",
                name: "n",
                type: "number",
                defaultValue: 2
            }]
        }, {
            tfOpName: "GatherV2",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "tensor"
            }, {
                start: 2,
                name: "axis",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "Gather",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "tensor"
            }],
            attrs: [{
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                notSupported: !0
            }]
        }, {
            tfOpName: "Reverse",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "dims",
                type: "bool",
                notSupported: !0
            }]
        }, {
            tfOpName: "ReverseV2",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number[]"
            }]
        }, {
            tfOpName: "Slice",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "begin",
                type: "number[]"
            }, {
                start: 2,
                name: "size",
                type: "number[]"
            }]
        }, {
            tfOpName: "StridedSlice",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "begin",
                type: "number[]"
            }, {
                start: 2,
                name: "end",
                type: "number[]"
            }, {
                start: 3,
                name: "strides",
                type: "number[]"
            }],
            attrs: [{
                tfName: "begin_mask",
                name: "beginMask",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "end_mask",
                name: "endMask",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "new_axis_mask",
                name: "newAxisMask",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "ellipsis_mask",
                name: "ellipsisMask",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "shrink_axis_mask",
                name: "shrinkAxisMask",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "Pack",
            category: "slice_join",
            inputs: [{
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }],
            attrs: [{
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "Unpack",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "tensor",
                type: "tensor"
            }],
            attrs: [{
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            }, {
                tfName: "num",
                name: "num",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            }]
        }, {
            tfOpName: "Tile",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "reps",
                type: "number[]"
            }]
        }, {
            tfOpName: "Split",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "axis",
                type: "number",
                defaultValue: 0
            }, {
                start: 1,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "num_split",
                name: "numOrSizeSplits",
                type: "number",
                defaultValue: 1
            }]
        }, {
            tfOpName: "SplitV",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "numOrSizeSplits",
                type: "number[]"
            }, {
                start: 2,
                name: "axis",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "ScatterNd",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "indices",
                type: "tensor"
            }, {
                start: 1,
                name: "values",
                type: "tensor"
            }, {
                start: 2,
                name: "shape",
                type: "number[]"
            }]
        }, {
            tfOpName: "GatherNd",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "indices",
                type: "tensor"
            }]
        }, {
            tfOpName: "SparseToDense",
            category: "slice_join",
            inputs: [{
                start: 0,
                name: "sparseIndices",
                type: "tensor"
            }, {
                start: 1,
                name: "outputShape",
                type: "number[]"
            }, {
                start: 2,
                name: "sparseValues",
                type: "tensor"
            }, {
                start: 3,
                name: "defaultValue",
                type: "tensor"
            }],
            attrs: [{
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                defaultValue: !1,
                notSupported: !0
            }]
        }];
        exports.json = e;
    }, {}],
    "cAFT": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "FFT",
            category: "spectral",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "IFFT",
            category: "spectral",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }]
        }, {
            tfOpName: "RFFT",
            category: "spectral",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "fft_length",
                type: "number",
                notSupported: !0
            }]
        }, {
            tfOpName: "IRFFT",
            category: "spectral",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "fft_length",
                type: "number",
                notSupported: !0
            }]
        }];
        exports.json = t;
    }, {}],
    "Qjst": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.json = void 0;
        const t = [{
            tfOpName: "Cast",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "SrcT",
                name: "sdtype",
                type: "dtype",
                notSupported: !0
            }, {
                tfName: "DstT",
                name: "dtype",
                type: "dtype"
            }]
        }, {
            tfOpName: "ExpandDims",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "axis",
                type: "number"
            }]
        }, {
            tfOpName: "Pad",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "padding",
                type: "number[]"
            }],
            attrs: [{
                tfName: "constant_value",
                name: "constantValue",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "PadV2",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "padding",
                type: "number[]"
            }, {
                start: 2,
                name: "constantValue",
                type: "number",
                defaultValue: 0
            }]
        }, {
            tfOpName: "Reshape",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "shape",
                type: "number[]"
            }]
        }, {
            tfOpName: "Squeeze",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "axis",
                tfDeprecatedName: "squeeze_dims",
                name: "axis",
                type: "number[]"
            }]
        }, {
            tfOpName: "SpaceToBatchND",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "blockShape",
                type: "number[]"
            }, {
                start: 2,
                name: "paddings",
                type: "number[]"
            }]
        }, {
            tfOpName: "BatchToSpaceND",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "blockShape",
                type: "number[]"
            }, {
                start: 2,
                name: "crops",
                type: "number[]"
            }]
        }, {
            tfOpName: "DepthToSpace",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }],
            attrs: [{
                tfName: "block_size",
                name: "blockSize",
                type: "number"
            }, {
                tfName: "data_format",
                name: "dataFormat",
                type: "string"
            }]
        }, {
            tfOpName: "BroadcastTo",
            category: "transformation",
            inputs: [{
                start: 0,
                name: "x",
                type: "tensor"
            }, {
                start: 1,
                name: "shape",
                type: "number[]"
            }],
            attrs: []
        }];
        exports.json = t;
    }, {}],
    "SpEM": [function(require, module, exports) {
        var global = arguments[3];
        var Buffer = require("buffer").Buffer;
        var e = arguments[3],
            t = require("buffer").Buffer;
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.decodeBase64 = x, exports.parseStringParam = O, exports.getStringParam = A, exports.getBoolParam = k, exports.getNumberParam = V, exports.parseDtypeParam = q, exports.getFuncParam = I, exports.getDtypeParam = w, exports.getDtypeArrayParam = j, exports.parseTensorShapeParam = E, exports.getTensorShapeParam = S, exports.getNumericArrayParam = M, exports.getStringArrayParam = B, exports.getTensorShapeArrayParam = C, exports.getBoolArrayParam = z, exports.OperationMapper = void 0;
        var a = require("@tensorflow/tfjs-core"),
            r = v(require("../data/compiled_api")),
            n = require("./custom_op/register"),
            s = require("./executors/utils"),
            o = v(require("./op_list/arithmetic")),
            u = v(require("./op_list/basic_math")),
            i = v(require("./op_list/control")),
            p = v(require("./op_list/convolution")),
            c = v(require("./op_list/creation")),
            l = v(require("./op_list/dynamic")),
            f = v(require("./op_list/evaluation")),
            d = v(require("./op_list/graph")),
            m = v(require("./op_list/image")),
            g = v(require("./op_list/logical")),
            h = v(require("./op_list/matrices")),
            y = v(require("./op_list/normalization")),
            N = v(require("./op_list/reduction")),
            b = v(require("./op_list/slice_join")),
            D = v(require("./op_list/spectral")),
            T = v(require("./op_list/transformation"));

        function _() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return _ = function() {
                return e
            }, e
        }

        function v(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = _();
            if (t && t.has(e)) return t.get(e);
            var a = {},
                r = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var s = r ? Object.getOwnPropertyDescriptor(e, n) : null;
                    s && (s.get || s.set) ? Object.defineProperty(a, n, s) : a[n] = e[n]
                } return a.default = e, t && t.set(e, a), a
        }
        class P {
            static get Instance() {
                return this._instance || (this._instance = new this)
            }
            constructor() {
                const e = [].concat(...[o, u, i, p, c, l, f, g, m, d, h, y, N, b, D, T].map(e => e.json));
                this.opMappers = e.reduce((e, t) => (e[t.tfOpName] = t, e), {})
            }
            transformGraph(e, t = {}) {
                const a = e.node,
                    r = [],
                    n = [],
                    o = a.reduce((e, t) => (e[t.name] = this.mapNode(t), t.op.startsWith("Placeholder") && r.push(e[t.name]), "Const" === t.op && n.push(e[t.name]), e), {});
                let u = [];
                const i = [];
                let p = {},
                    c = {};
                null != t && (p = this.mapSignatureEntries(t.inputs), c = this.mapSignatureEntries(t.outputs));
                const l = Object.keys(o);
                l.forEach(e => {
                    const t = o[e];
                    t.inputNames.forEach(e => {
                        const [a] = (0, s.getNodeNameAndIndex)(e);
                        t.inputs.push(o[a]), o[a].children.push(t)
                    })
                }), 0 === Object.keys(c).length ? l.forEach(e => {
                    const t = o[e];
                    0 === t.children.length && i.push(t)
                }) : Object.keys(c).forEach(e => {
                    const [t] = (0, s.getNodeNameAndIndex)(e), a = o[t];
                    null != a && (a.signatureKey = c[e], i.push(a))
                }), Object.keys(p).length > 0 ? Object.keys(p).forEach(e => {
                    const [t] = (0, s.getNodeNameAndIndex)(e), a = o[t];
                    a && (a.signatureKey = p[e], u.push(a))
                }) : u = r;
                let f = {};
                return null != e.library && null != e.library.function && (f = e.library.function.reduce((e, t) => (e[t.signature.name] = this.mapFunction(t), e), {})), {
                    nodes: o,
                    inputs: u,
                    outputs: i,
                    weights: n,
                    placeholders: r,
                    signature: t,
                    functions: f
                }
            }
            mapSignatureEntries(e) {
                return Object.keys(e || {}).reduce((t, a) => (t[e[a].name] = a, t), {})
            }
            mapNode(e) {
                const t = (0, n.getRegisteredOp)(e.op) || this.opMappers[e.op] || {};
                null == e.attr && (e.attr = {});
                const a = {
                    name: e.name,
                    op: e.op,
                    category: t.category,
                    inputNames: (e.input || []).map(e => e.startsWith("^") ? e.substr(1) : e),
                    inputs: [],
                    children: [],
                    inputParams: {},
                    attrParams: {},
                    rawAttrs: e.attr
                };
                return null != t.inputs && (a.inputParams = t.inputs.reduce((e, t) => (e[t.name] = {
                    type: t.type,
                    inputIndexStart: t.start,
                    inputIndexEnd: t.end
                }, e), {})), null != t.attrs && (a.attrParams = t.attrs.reduce((t, a) => {
                    const r = a.type;
                    let n = void 0;
                    switch (a.type) {
                        case "string":
                            void 0 === (n = A(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = A(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "string[]":
                            void 0 === (n = B(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = B(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "number":
                            void 0 === (n = V(e.attr, a.tfName, a.defaultValue || 0)) && a.tfDeprecatedName && (n = V(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "number[]":
                            void 0 === (n = M(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = M(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "bool":
                            void 0 === (n = k(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = k(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "bool[]":
                            void 0 === (n = z(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = z(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "shape":
                            void 0 === (n = S(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = S(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "shape[]":
                            void 0 === (n = C(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = C(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "dtype":
                            void 0 === (n = w(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = w(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "dtype[]":
                            void 0 === (n = j(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = j(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "func":
                            void 0 === (n = I(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = I(e.attr, a.tfDeprecatedName, a.defaultValue));
                            break;
                        case "tensor":
                        case "tensors":
                            break;
                        default:
                            throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)
                    }
                    return t[a.name] = {
                        value: n,
                        type: r
                    }, t
                }, {})), a
            }
            mapFunction(e) {
                const t = e.nodeDef,
                    a = [];
                let r = {};
                null != t && (r = t.reduce((e, t) => (e[t.name] = this.mapNode(t), "Const" === t.op && a.push(e[t.name]), e), {}));
                const n = [],
                    o = [];
                e.signature.inputArg.forEach(e => {
                    const [t] = (0, s.getNodeNameAndIndex)(e.name), a = {
                        name: t,
                        op: "Placeholder",
                        inputs: [],
                        inputNames: [],
                        category: "graph",
                        inputParams: {},
                        attrParams: {
                            dtype: {
                                value: q(e.type),
                                type: "dtype"
                            }
                        },
                        children: []
                    };
                    a.signatureKey = e.name, n.push(a), r[t] = a
                }), Object.keys(r).forEach(e => {
                    const t = r[e];
                    t.inputNames.forEach(e => {
                        const [a] = (0, s.getNodeNameAndIndex)(e);
                        t.inputs.push(r[a]), r[a].children.push(t)
                    })
                });
                const u = e.ret;
                e.signature.outputArg.forEach(e => {
                    const [t, a] = (0, s.getNodeNameAndIndex)(u[e.name]), n = r[t];
                    null != n && (n.defaultOutput = a, o.push(n))
                });
                const i = this.mapArgsToSignature(e);
                return {
                    nodes: r,
                    inputs: n,
                    outputs: o,
                    weights: a,
                    placeholders: [],
                    signature: i
                }
            }
            mapArgsToSignature(e) {
                return {
                    methodName: e.signature.name,
                    inputs: e.signature.inputArg.reduce((e, t) => (e[t.name] = this.mapArgToTensorInfo(t), e), {}),
                    outputs: e.signature.outputArg.reduce((t, a) => (t[a.name] = this.mapArgToTensorInfo(a, e.ret), t), {})
                }
            }
            mapArgToTensorInfo(e, t) {
                let a = e.name;
                return null != t && (a = t[a]), {
                    name: a,
                    dtype: e.type
                }
            }
        }

        function x(e) {
            const r = (0, a.env)().global;
            if (void 0 !== r.atob) return r.atob(e);
            if (void 0 !== t) return new t(e, "base64").toString();
            throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
        }

        function O(e, t) {
            const a = Array.isArray(e) ? String.fromCharCode.apply(null, e) : x(e);
            return t ? a : a.toLowerCase()
        }

        function A(e, t, a, r = !1) {
            const n = e[t];
            return null != n ? O(n.s, r) : a
        }

        function k(e, t, a) {
            const r = e[t];
            return r ? r.b : a
        }

        function V(e, t, a) {
            const r = e[t] || {},
                n = null != r.i ? r.i : null != r.f ? r.f : a;
            return "number" == typeof n ? n : parseInt(n, 10)
        }

        function q(e) {
            switch ("string" == typeof e && (e = r.DataType[e]), e) {
                case r.DataType.DT_FLOAT:
                    return "float32";
                case r.DataType.DT_INT32:
                case r.DataType.DT_INT64:
                case r.DataType.DT_INT8:
                case r.DataType.DT_UINT8:
                    return "int32";
                case r.DataType.DT_BOOL:
                    return "bool";
                case r.DataType.DT_DOUBLE:
                    return "float32";
                case r.DataType.DT_STRING:
                    return "string";
                default:
                    return null
            }
        }

        function I(e, t, a) {
            const r = e[t];
            return r && r.func ? r.func.name : a
        }

        function w(e, t, a) {
            const r = e[t];
            return r && r.type ? q(r.type) : a
        }

        function j(e, t, a) {
            const r = e[t];
            return r && r.list && r.list.type ? r.list.type.map(e => q(e)) : a
        }

        function E(e) {
            if (!e.unknownRank) return null != e.dim ? e.dim.map(e => "number" == typeof e.size ? e.size : parseInt(e.size, 10)) : []
        }

        function S(e, t, a) {
            const r = e[t];
            return r && r.shape ? E(r.shape) : a
        }

        function M(e, t, a) {
            const r = e[t];
            return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(e => "number" == typeof e ? e : parseInt(e, 10)) : a
        }

        function B(e, t, a, r = !1) {
            const n = e[t];
            return n && n.list && n.list.s ? n.list.s.map(e => O(e, r)) : a
        }

        function C(e, t, a) {
            const r = e[t];
            return r && r.list && r.list.shape ? r.list.shape.map(e => E(e)) : a
        }

        function z(e, t, a) {
            const r = e[t];
            return r && r.list && r.list.b ? r.list.b : a
        }
        exports.OperationMapper = P;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../data/compiled_api": "pKMt",
        "./custom_op/register": "gQtl",
        "./executors/utils": "w10i",
        "./op_list/arithmetic": "cO5O",
        "./op_list/basic_math": "a7ub",
        "./op_list/control": "sRrn",
        "./op_list/convolution": "GT2x",
        "./op_list/creation": "A4xH",
        "./op_list/dynamic": "N7t0",
        "./op_list/evaluation": "gtBU",
        "./op_list/graph": "YWEf",
        "./op_list/image": "ooyd",
        "./op_list/logical": "SvFw",
        "./op_list/matrices": "vBB5",
        "./op_list/normalization": "VBGq",
        "./op_list/reduction": "tqog",
        "./op_list/slice_join": "N4YI",
        "./op_list/spectral": "cAFT",
        "./op_list/transformation": "Qjst",
        "buffer": "aMB2"
    }],
    "lSvz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.NodeValueImpl = void 0;
        var t = require("../executors/utils"),
            r = require("../operation_mapper");
        class e {
            constructor(t, r, e) {
                this.node = t, this.tensorMap = r, this.context = e, this.inputs = [], this.attrs = {}, this.inputs = t.inputNames.map(t => this.getInput(t)), null != t.rawAttrs && (this.attrs = Object.keys(t.rawAttrs).reduce((t, r) => (t[r] = this.getAttr(r), t), {}))
            }
            getInput(r) {
                return (0, t.getTensor)(r, this.tensorMap, this.context)
            }
            getAttr(e, s) {
                const n = this.node.rawAttrs[e];
                if (null != n.tensor) return (0, t.getTensor)(e, this.tensorMap, this.context);
                if (null != n.i || null != n.f) return (0, r.getNumberParam)(this.node.rawAttrs, e, s);
                if (null != n.s) return (0, r.getStringParam)(this.node.rawAttrs, e, s);
                if (null != n.b) return (0, r.getBoolParam)(this.node.rawAttrs, e, s);
                if (null != n.shape) return (0, r.getTensorShapeParam)(this.node.rawAttrs, e, s);
                if (null != n.type) return (0, r.getDtypeParam)(this.node.rawAttrs, e, s);
                if (null != n.list) {
                    if (null != n.list.i || null != n.list.f) return (0, r.getNumericArrayParam)(this.node.rawAttrs, e, s);
                    if (null != n.list.s) return (0, r.getStringArrayParam)(this.node.rawAttrs, e, s);
                    if (null != n.list.shape) return (0, r.getTensorShapeArrayParam)(this.node.rawAttrs, e, s);
                    if (null != n.list.b) return (0, r.getBoolArrayParam)(this.node.rawAttrs, e, s);
                    if (null != n.list.type) return (0, r.getDtypeArrayParam)(this.node.rawAttrs, e, s)
                }
                return s
            }
        }
        exports.NodeValueImpl = e;
    }, {
        "../executors/utils": "w10i",
        "../operation_mapper": "SpEM"
    }],
    "IGj9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = t(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function t(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = r();
            if (a && a.has(e)) return a.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var n = u ? Object.getOwnPropertyDescriptor(e, o) : null;
                    n && (n.get || n.set) ? Object.defineProperty(t, o, n) : t[o] = e[o]
                } return t.default = e, a && a.set(e, t), t
        }
        const u = (r, t, u) => {
            switch (r.op) {
                case "BiasAdd":
                case "AddV2":
                case "Add":
                    return [e.add((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "AddN":
                    return [e.addN((0, a.getParamValue)("tensors", r, t, u))];
                case "FloorMod":
                case "Mod":
                    return [e.mod((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Mul":
                    return [e.mul((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "RealDiv":
                case "Div":
                    return [e.div((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "DivNoNan":
                    return [e.divNoNan((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "FloorDiv":
                    return [e.floorDiv((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Sub":
                    return [e.sub((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Minimum":
                    return [e.minimum((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Maximum":
                    return [e.maximum((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Pow":
                    return [e.pow((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "SquaredDifference":
                    return [e.squaredDifference((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = u;
        const o = "arithmetic";
        exports.CATEGORY = o;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "dVEs": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = t(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function t(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = r();
            if (a && a.has(e)) return a.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var l in e)
                if (Object.prototype.hasOwnProperty.call(e, l)) {
                    var n = u ? Object.getOwnPropertyDescriptor(e, l) : null;
                    n && (n.get || n.set) ? Object.defineProperty(t, l, n) : t[l] = e[l]
                } return t.default = e, a && a.set(e, t), t
        }
        const u = (r, t, u) => {
            switch (r.op) {
                case "Abs":
                case "ComplexAbs":
                    return [e.abs((0, a.getParamValue)("x", r, t, u))];
                case "Acos":
                    return [e.acos((0, a.getParamValue)("x", r, t, u))];
                case "Acosh":
                    return [e.acosh((0, a.getParamValue)("x", r, t, u))];
                case "Asin":
                    return [e.asin((0, a.getParamValue)("x", r, t, u))];
                case "Asinh":
                    return [e.asinh((0, a.getParamValue)("x", r, t, u))];
                case "Atan":
                    return [e.atan((0, a.getParamValue)("x", r, t, u))];
                case "Atan2":
                    return [e.atan2((0, a.getParamValue)("x", r, t, u), (0, a.getParamValue)("y", r, t, u))];
                case "Atanh":
                    return [e.atanh((0, a.getParamValue)("x", r, t, u))];
                case "Ceil":
                    return [e.ceil((0, a.getParamValue)("x", r, t, u))];
                case "Complex":
                    return [e.complex((0, a.getParamValue)("real", r, t, u), (0, a.getParamValue)("imag", r, t, u))];
                case "Cos":
                    return [e.cos((0, a.getParamValue)("x", r, t, u))];
                case "Cosh":
                    return [e.cosh((0, a.getParamValue)("x", r, t, u))];
                case "Elu":
                    return [e.elu((0, a.getParamValue)("x", r, t, u))];
                case "Erf":
                    return [e.erf((0, a.getParamValue)("x", r, t, u))];
                case "Exp":
                    return [e.exp((0, a.getParamValue)("x", r, t, u))];
                case "Expm1":
                    return [e.expm1((0, a.getParamValue)("x", r, t, u))];
                case "Floor":
                    return [e.floor((0, a.getParamValue)("x", r, t, u))];
                case "Log":
                    return [e.log((0, a.getParamValue)("x", r, t, u))];
                case "Log1p":
                    return [e.log1p((0, a.getParamValue)("x", r, t, u))];
                case "Imag":
                    return [e.imag((0, a.getParamValue)("x", r, t, u))];
                case "Neg":
                    return [e.neg((0, a.getParamValue)("x", r, t, u))];
                case "Reciprocal":
                    return [e.reciprocal((0, a.getParamValue)("x", r, t, u))];
                case "Real":
                    return [e.real((0, a.getParamValue)("x", r, t, u))];
                case "Relu":
                    return [e.relu((0, a.getParamValue)("x", r, t, u))];
                case "Round":
                    return [e.round((0, a.getParamValue)("x", r, t, u))];
                case "Selu":
                    return [e.selu((0, a.getParamValue)("x", r, t, u))];
                case "Sigmoid":
                    return [e.sigmoid((0, a.getParamValue)("x", r, t, u))];
                case "Sin":
                    return [e.sin((0, a.getParamValue)("x", r, t, u))];
                case "Sign":
                    return [e.sign((0, a.getParamValue)("x", r, t, u))];
                case "Sinh":
                    return [e.sinh((0, a.getParamValue)("x", r, t, u))];
                case "Softplus":
                    return [e.softplus((0, a.getParamValue)("x", r, t, u))];
                case "Sqrt":
                    return [e.sqrt((0, a.getParamValue)("x", r, t, u))];
                case "Square":
                    return [e.square((0, a.getParamValue)("x", r, t, u))];
                case "Tanh":
                    return [e.tanh((0, a.getParamValue)("x", r, t, u))];
                case "Tan":
                    return [e.tan((0, a.getParamValue)("x", r, t, u))];
                case "Relu6":
                case "ClipByValue":
                    return [e.clipByValue((0, a.getParamValue)("x", r, t, u), (0, a.getParamValue)("clipValueMin", r, t, u), (0, a.getParamValue)("clipValueMax", r, t, u))];
                case "Rsqrt":
                    return [e.rsqrt((0, a.getTensor)(r.inputNames[0], t, u))];
                case "Prod":
                    return [e.prod((0, a.getParamValue)("x", r, t, u), (0, a.getParamValue)("axes", r, t, u))];
                case "LeakyRelu":
                    return [e.leakyRelu((0, a.getParamValue)("x", r, t, u), (0, a.getParamValue)("alpha", r, t, u))];
                case "Prelu":
                    return [e.prelu((0, a.getParamValue)("x", r, t, u), (0, a.getParamValue)("alpha", r, t, u))];
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = u;
        const l = "basic_math";
        exports.CATEGORY = l;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "QSgK": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.assertShapesMatchAllowUndefinedSize = t, exports.shapesEqualAllowUndefinedSize = r;
        var e = require("@tensorflow/tfjs-core");

        function t(t, n, s = "") {
            e.util.assert(r(t, n), () => s + ` Shapes ${t} and ${n} must match`)
        }

        function r(e, t) {
            if (e.length !== t.length) return !1;
            for (let r = 0; r < e.length; r++)
                if (-1 !== e[r] && -1 !== t[r] && e[r] !== t[r]) return !1;
            return !0
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "lFaL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TensorArray = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./tensor_utils");
        class s {
            constructor(t, s, r, i, n, a, h) {
                this.name = t, this.dtype = s, this.maxSize = r, this.elementShape = i, this.identicalElementShapes = n, this.dynamicSize = a, this.clearAfterRead = h, this.tensors = [], this.closed_ = !1, this.idTensor = (0, e.scalar)(0), (0, e.keep)(this.idTensor)
            }
            get id() {
                return this.idTensor.id
            }
            get closed() {
                return this.closed_
            }
            clearAndClose() {
                this.tensors.forEach(e => e.tensor.dispose()), this.tensors = [], this.closed_ = !0, this.idTensor.dispose()
            }
            size() {
                return this.tensors.length
            }
            read(e) {
                if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
                if (e < 0 || e >= this.size()) throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
                const t = this.tensors[e];
                if (t.cleared) throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read ` + "(perhaps try setting clear_after_read = false?).");
                return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor
            }
            readMany(e) {
                return e.map(e => this.read(e))
            }
            write(s, r) {
                if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
                if (s < 0 || !this.dynamicSize && s >= this.maxSize) throw new Error(`Tried to write to index ${s}, but array is not resizeable and size is: ${this.maxSize}`);
                const i = this.tensors[s] || {};
                if (r.dtype !== this.dtype) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s},\n          because the value dtype is ${r.dtype}, but TensorArray dtype is ${this.dtype}.`);
                if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = r.shape), (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, r.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${s}.`), i.read) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s}, because it has already been read.`);
                if (i.written) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s}, because it has already been written.`);
                i.tensor = r, (0, e.keep)(r), i.written = !0, this.tensors[s] = i
            }
            writeMany(e, t) {
                if (e.length !== t.length) throw new Error(`TensorArray ${this.name}: could not write multiple tensors,` + `because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
                e.forEach((e, s) => this.write(e, t[s]))
            }
            gather(s, r) {
                if (r && r !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${r}`);
                if (s) s = s.slice(0, this.size());
                else {
                    s = [];
                    for (let e = 0; e < this.size(); e++) s.push(e)
                }
                if (0 === s.length) return (0, e.tensor)([], [0].concat(this.elementShape));
                const i = this.readMany(s);
                return (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, i[0].shape, "TensorArray shape mismatch: "), (0, e.stack)(i, 0)
            }
            concat(s) {
                if (s && s !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${s}`);
                if (0 === this.size()) return (0, e.tensor)([], [0].concat(this.elementShape));
                const r = [];
                for (let e = 0; e < this.size(); e++) r.push(e);
                const i = this.readMany(r);
                return (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, i[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${i[0].shape})`), (0, e.concat)(i, 0)
            }
            scatter(t, s) {
                if (s.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${s.dtype}`);
                if (t.length !== s.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${s.shape[0]}`);
                const r = Math.max(...t);
                if (!this.dynamicSize && r >= this.maxSize) throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);
                this.writeMany(t, (0, e.unstack)(s, 0))
            }
            split(t, s) {
                if (s.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${s.dtype}`);
                let r = 0;
                const i = t.map(e => r += e);
                if (r !== s.shape[0]) throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${s.shape}`);
                if (!this.dynamicSize && t.length !== this.maxSize) throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), ` + "and the TensorArray is not marked as dynamically resizeable");
                const n = 0 === r ? 0 : s.size / r,
                    a = [];
                (0, e.tidy)(() => {
                    s = s.reshape([1, r, n]);
                    for (let r = 0; r < t.length; ++r) {
                        const h = [0, 0 === r ? 0 : i[r - 1], 0],
                            o = [1, t[r], n];
                        a[r] = (0, e.slice)(s, h, o).reshape(this.elementShape)
                    }
                    return a
                });
                const h = [];
                for (let e = 0; e < t.length; e++) h[e] = e;
                this.writeMany(h, a)
            }
        }
        exports.TensorArray = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./tensor_utils": "QSgK"
    }],
    "txuj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fromTensor = n, exports.reserve = r, exports.scatter = i, exports.split = h, exports.TensorList = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./tensor_utils");
        class s {
            constructor(s, n, r, i = -1) {
                this.tensors = s, this.elementShape = n, this.elementDtype = r, null != s && s.forEach(s => {
                    if (r !== s.dtype) throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);
                    (0, t.assertShapesMatchAllowUndefinedSize)(n, s.shape, "TensorList shape mismatch: "), (0, e.keep)(s)
                }), this.idTensor = (0, e.scalar)(0), this.maxNumElements = i, (0, e.keep)(this.idTensor)
            }
            get id() {
                return this.idTensor.id
            }
            copy() {
                return new s([...this.tensors], this.elementShape, this.elementDtype)
            }
            clearAndClose() {
                this.tensors.forEach(e => e.dispose()), this.tensors.length = 0, this.idTensor.dispose()
            }
            size() {
                return this.tensors.length
            }
            stack(s, n, r = -1) {
                if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
                if (-1 !== r && this.tensors.length !== r) throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);
                return (0, t.assertShapesMatchAllowUndefinedSize)(s, this.elementShape, "TensorList shape mismatch: "), (0, e.tidy)(() => {
                    const t = this.tensors.map(e => e.reshape(s));
                    return (0, e.stack)(t, 0)
                })
            }
            popBack(e, s) {
                if (s !== this.elementDtype) throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);
                if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
                const n = this.tensors.pop();
                return (0, t.assertShapesMatchAllowUndefinedSize)(n.shape, e, "TensorList shape mismatch: "), n.reshape(e)
            }
            pushBack(s) {
                if (s.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${this.elementDtype}`);
                if ((0, t.assertShapesMatchAllowUndefinedSize)(s.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
                (0, e.keep)(s), this.tensors.push(s)
            }
            resize(e) {
                if (e < 0) throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
                if (-1 !== this.maxNumElements && e > this.maxNumElements) throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
                this.tensors.length = e
            }
            getItem(e, s, n) {
                if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
                if (e < 0 || e > this.tensors.length) throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
                if (null == this.tensors[e]) throw new Error(`element at index ${e} is null.`);
                return (0, t.assertShapesMatchAllowUndefinedSize)(this.tensors[e].shape, s, "TensorList shape mismatch: "), this.tensors[e]
            }
            setItem(s, n) {
                if (n.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);
                if (s < 0 || -1 !== this.maxNumElements && s >= this.maxNumElements) throw new Error(`Trying to set element ${s} in a list with max ${this.maxNumElements} elements.`);
                (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, n.shape, "TensorList shape mismatch: "), (0, e.keep)(n), this.tensors[s] = n
            }
            gather(s, n, r) {
                if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
                return (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, r, "TensorList shape mismatch: "), 0 === (s = s.slice(0, this.size())).length ? (0, e.tensor)([], [0].concat(this.elementShape)) : (0, e.tidy)(() => {
                    const t = s.map(e => this.tensors[e].reshape(r));
                    return (0, e.stack)(t, 0)
                })
            }
            concat(s, n) {
                if (s && s !== this.elementDtype) throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${s}`);
                return (0, t.assertShapesMatchAllowUndefinedSize)(this.elementShape, n, "TensorList shape mismatch: "), 0 === this.size() ? (0, e.tensor)([], [0].concat(this.elementShape)) : (0, e.tidy)(() => {
                    const t = this.tensors.map(e => e.reshape(n));
                    return (0, e.concat)(t, 0)
                })
            }
        }

        function n(e, n, r) {
            const i = e.dtype;
            if (e.shape.length < 1) throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);
            if (e.dtype !== r) throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${r}`);
            const h = e.shape.slice(1);
            (0, t.assertShapesMatchAllowUndefinedSize)(h, n, "TensorList shape mismatch: ");
            const o = e.unstack();
            return new s(o, n, i)
        }

        function r(e, t, n) {
            return new s([], e, t, n)
        }

        function i(t, n, r, i) {
            if (n.length !== t.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);
            const h = Math.max(...n);
            if (null != i && -1 !== i && h >= i) throw new Error(`Max index must be < array size (${h}  vs. ${i})`);
            const o = new s([], r, t.dtype, i),
                a = (0, e.unstack)(t, 0);
            return n.forEach((e, t) => {
                o.setItem(e, a[t])
            }), o
        }

        function h(t, n, r) {
            let i = 0;
            const h = n.map(e => i += e);
            if (i !== t.shape[0]) throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${i}, and tensor's shape is: ${t.shape}`);
            const o = 0 === i ? 0 : t.size / i,
                a = (0, e.tidy)(() => {
                    const s = [];
                    t = t.reshape([1, i, o]);
                    for (let i = 0; i < n.length; ++i) {
                        const a = [0, 0 === i ? 0 : h[i - 1], 0],
                            l = [1, n[i], o];
                        s[i] = (0, e.slice)(t, a, l).reshape(r)
                    }
                    return t.dispose(), s
                }),
                l = new s([], r, t.dtype, n.length);
            for (let e = 0; e < a.length; e++) l.setItem(e, a[e]);
            return l
        }
        exports.TensorList = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./tensor_utils": "QSgK"
    }],
    "NqZC": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = require("@tensorflow/tfjs-core"),
            a = require("../../executor/tensor_array"),
            t = require("../../executor/tensor_list"),
            r = require("./utils");
        const n = async (n, s, o) => {
            switch (n.op) {
                case "If":
                case "StatelessIf": {
                    const e = (0, r.getParamValue)("thenBranch", n, s, o),
                        a = (0, r.getParamValue)("elseBranch", n, s, o),
                        t = (0, r.getParamValue)("cond", n, s, o),
                        i = (0, r.getParamValue)("args", n, s, o);
                    return (await t.data())[0] ? o.functionMap[e].executeFunctionAsync(i, o.tensorArrayMap, o.tensorListMap) : o.functionMap[a].executeFunctionAsync(i, o.tensorArrayMap, o.tensorListMap)
                }
                case "While":
                case "StatelessWhile": {
                    const e = (0, r.getParamValue)("body", n, s, o),
                        a = (0, r.getParamValue)("cond", n, s, o),
                        t = (0, r.getParamValue)("args", n, s, o),
                        i = await o.functionMap[a].executeFunctionAsync(t, o.tensorArrayMap, o.tensorListMap),
                        u = t.map(e => e.id);
                    let c = await i[0].data();
                    i.forEach(e => {
                        e.kept || -1 !== u.indexOf(e.id) || e.dispose()
                    });
                    let l = t;
                    for (; c[0];) {
                        const t = l,
                            r = (l = await o.functionMap[e].executeFunctionAsync(l, o.tensorArrayMap, o.tensorListMap)).map(e => e.id);
                        t.forEach(e => {
                            e.kept || -1 !== u.indexOf(e.id) || -1 !== r.indexOf(e.id) || e.dispose()
                        });
                        const n = await o.functionMap[a].executeFunctionAsync(l, o.tensorArrayMap, o.tensorListMap);
                        c = await n[0].data(), n.forEach(e => {
                            e.kept || -1 !== u.indexOf(e.id) || -1 !== r.indexOf(e.id) || e.dispose()
                        })
                    }
                    return l
                }
                case "LoopCond":
                    return [(0, r.getParamValue)("pred", n, s, o).clone()];
                case "Switch": {
                    const e = (0, r.getParamValue)("pred", n, s, o),
                        a = (0, r.getParamValue)("data", n, s, o);
                    return (await e.data())[0] ? [void 0, a.clone()] : [a.clone(), void 0]
                }
                case "Merge": {
                    const e = n.inputNames.find(e => void 0 !== (0, r.getTensor)(e, s, o));
                    return e ? [(0, r.getTensor)(e, s, o).clone()] : void 0
                }
                case "Enter": {
                    const e = (0, r.getParamValue)("frameName", n, s, o),
                        a = (0, r.getParamValue)("tensor", n, s, o);
                    return o.enterFrame(e), [a.clone()]
                }
                case "Exit": {
                    const e = (0, r.getParamValue)("tensor", n, s, o);
                    return o.exitFrame(), [e.clone()]
                }
                case "NextIteration": {
                    const e = (0, r.getParamValue)("tensor", n, s, o);
                    return o.nextIteration(), [e.clone()]
                }
                case "TensorArrayV3": {
                    const t = (0, r.getParamValue)("size", n, s, o),
                        i = (0, r.getParamValue)("dtype", n, s, o),
                        u = (0, r.getParamValue)("elementShape", n, s, o),
                        c = (0, r.getParamValue)("dynamicSize", n, s, o),
                        l = (0, r.getParamValue)("clearAfterRead", n, s, o),
                        m = (0, r.getParamValue)("identicalElementShapes", n, s, o),
                        d = (0, r.getParamValue)("name", n, s, o),
                        g = new a.TensorArray(d, i, t, u, m, c, l);
                    return o.addTensorArray(g), [g.idTensor, (0, e.scalar)(1)]
                }
                case "TensorArrayWriteV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = (0, r.getParamValue)("index", n, s, o),
                        t = (0, r.getParamValue)("tensor", n, s, o),
                        i = o.getTensorArray(e.id);
                    return i.write(a, t), [i.idTensor]
                }
                case "TensorArrayReadV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = (0, r.getParamValue)("index", n, s, o);
                    return [o.getTensorArray(e.id).read(a)]
                }
                case "TensorArrayGatherV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = (0, r.getParamValue)("indices", n, s, o),
                        t = (0, r.getParamValue)("dtype", n, s, o);
                    return [o.getTensorArray(e.id).gather(a, t)]
                }
                case "TensorArrayScatterV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = (0, r.getParamValue)("indices", n, s, o),
                        t = (0, r.getParamValue)("tensor", n, s, o),
                        i = o.getTensorArray(e.id);
                    return i.scatter(a, t), [i.idTensor]
                }
                case "TensorArrayConcatV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = o.getTensorArray(e.id),
                        t = (0, r.getParamValue)("dtype", n, s, o);
                    return [a.concat(t)]
                }
                case "TensorArraySplitV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = (0, r.getParamValue)("tensor", n, s, o),
                        t = (0, r.getParamValue)("lengths", n, s, o),
                        i = o.getTensorArray(e.id);
                    return i.split(t, a), [i.idTensor]
                }
                case "TensorArraySizeV3": {
                    const a = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        t = o.getTensorArray(a.id);
                    return [(0, e.scalar)(t.size(), "int32")]
                }
                case "TensorArrayCloseV3": {
                    const e = (0, r.getParamValue)("tensorArrayId", n, s, o),
                        a = o.getTensorArray(e.id);
                    return a.clearAndClose(), [a.idTensor]
                }
                case "TensorListSetItem": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("index", n, s, o),
                        t = (0, r.getParamValue)("tensor", n, s, o),
                        i = o.getTensorList(e.id);
                    return i.setItem(a, t), [i.idTensor]
                }
                case "TensorListGetItem": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("index", n, s, o),
                        t = (0, r.getParamValue)("elementShape", n, s, o),
                        i = (0, r.getParamValue)("elementDType", n, s, o);
                    return [o.getTensorList(e.id).getItem(a, t, i)]
                }
                case "TensorListScatterV2":
                case "TensorListScatter": {
                    const e = (0, r.getParamValue)("indices", n, s, o),
                        a = (0, r.getParamValue)("tensor", n, s, o),
                        i = (0, r.getParamValue)("elementShape", n, s, o),
                        u = (0, r.getParamValue)("numElements", n, s, o),
                        c = (0, t.scatter)(a, e, i, u);
                    return o.addTensorList(c), [c.idTensor]
                }
                case "TensorListReserve": {
                    const e = (0, r.getParamValue)("elementShape", n, s, o),
                        a = (0, r.getParamValue)("elementDType", n, s, o),
                        i = (0, r.getParamValue)("numElements", n, s, o),
                        u = (0, t.reserve)(e, a, i);
                    return o.addTensorList(u), [u.idTensor]
                }
                case "TensorListGather": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("indices", n, s, o),
                        t = (0, r.getParamValue)("elementShape", n, s, o),
                        i = (0, r.getParamValue)("elementDType", n, s, o);
                    return [o.getTensorList(e.id).gather(a, i, t)]
                }
                case "TensorListStack": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("elementShape", n, s, o),
                        t = (0, r.getParamValue)("elementDType", n, s, o),
                        i = (0, r.getParamValue)("numElements", n, s, o);
                    return [o.getTensorList(e.id).stack(a, t, i)]
                }
                case "TensorListFromTensor": {
                    const e = (0, r.getParamValue)("tensor", n, s, o),
                        a = (0, r.getParamValue)("elementShape", n, s, o),
                        i = (0, r.getParamValue)("elementDType", n, s, o),
                        u = (0, t.fromTensor)(e, a, i);
                    return o.addTensorList(u), [u.idTensor]
                }
                case "TensorListConcat": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = o.getTensorList(e.id),
                        t = (0, r.getParamValue)("dtype", n, s, o),
                        i = (0, r.getParamValue)("elementShape", n, s, o);
                    return [a.concat(t, i)]
                }
                case "TensorListPushBack": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("tensor", n, s, o),
                        t = o.getTensorList(e.id);
                    return t.pushBack(a), [t.idTensor]
                }
                case "TensorListPopBack": {
                    const e = (0, r.getParamValue)("tensorListId", n, s, o),
                        a = (0, r.getParamValue)("elementShape", n, s, o),
                        t = (0, r.getParamValue)("elementDType", n, s, o);
                    return [o.getTensorList(e.id).popBack(a, t)]
                }
                case "TensorListSplit": {
                    const e = (0, r.getParamValue)("tensor", n, s, o),
                        a = (0, r.getParamValue)("elementShape", n, s, o),
                        i = (0, r.getParamValue)("lengths", n, s, o),
                        u = (0, t.split)(e, i, a);
                    return o.addTensorList(u), [u.idTensor]
                }
                default:
                    throw TypeError(`Node type ${n.op} is not implemented`)
            }
        };
        exports.executeOp = n;
        const s = "control";
        exports.CATEGORY = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../../executor/tensor_array": "lFaL",
        "../../executor/tensor_list": "txuj",
        "./utils": "w10i"
    }],
    "Gr2b": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = t();
            if (a && a.has(e)) return a.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var u = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    u && (u.get || u.set) ? Object.defineProperty(r, s, u) : r[s] = e[s]
                } return r.default = e, a && a.set(e, r), r
        }
        const o = (t, r, o) => {
            switch (t.op) {
                case "Conv1D": {
                    const s = (0, a.getParamValue)("stride", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase(),
                        l = (0, a.getParamValue)("dilation", t, r, o);
                    return [e.conv1d((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("filter", t, r, o), s, u, n, l)]
                }
                case "Conv2D": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getPadding)(t, r, o),
                        n = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase(),
                        l = (0, a.getParamValue)("dilations", t, r, o);
                    return [e.conv2d((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("filter", t, r, o), [s[1], s[2]], u, n, [l[1], l[2]])]
                }
                case "_FusedConv2D":
                case "FusedDepthwiseConv2dNative": {
                    const [s, u] = (0, a.getParamValue)("fusedOps", t, r, o), n = "biasadd" === s, l = "prelu" === u, i = "fusedbatchnorm" === s, d = (0, a.getParamValue)("numArgs", t, r, o);
                    if (n) {
                        if (l && 2 !== d) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                        if (!l && 1 !== d) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
                    }
                    if (i) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
                    const g = (0, a.getParamValue)("strides", t, r, o),
                        P = (0, a.getPadding)(t, r, o),
                        m = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase(),
                        p = (0, a.getParamValue)("dilations", t, r, o),
                        [c, V] = (0, a.getParamValue)("args", t, r, o);
                    return [("_FusedConv2D" === t.op ? e.fused.conv2d : e.fused.depthwiseConv2d)({
                        x: (0, a.getParamValue)("x", t, r, o),
                        filter: (0, a.getParamValue)("filter", t, r, o),
                        strides: [g[1], g[2]],
                        pad: P,
                        dataFormat: m,
                        dilations: [p[1], p[2]],
                        bias: c,
                        activation: u,
                        preluActivationWeights: V
                    })]
                }
                case "Conv2DBackpropInput":
                case "Conv2dTranspose": {
                    const s = (0, a.getParamValue)("outputShape", t, r, o),
                        u = (0, a.getParamValue)("strides", t, r, o),
                        n = (0, a.getPadding)(t, r, o);
                    return [e.conv2dTranspose((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("filter", t, r, o), s, [u[1], u[2]], n)]
                }
                case "DepthwiseConv2dNative":
                case "DepthwiseConv2d": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getPadding)(t, r, o),
                        n = (0, a.getParamValue)("dilations", t, r, o),
                        l = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase();
                    return [e.depthwiseConv2d((0, a.getParamValue)("input", t, r, o), (0, a.getParamValue)("filter", t, r, o), [s[1], s[2]], u, l, [n[1], n[2]])]
                }
                case "Conv3D": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase(),
                        l = (0, a.getParamValue)("dilations", t, r, o);
                    return [e.conv3d((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("filter", t, r, o), [s[1], s[2], s[3]], u, n, [l[1], l[2], l[3]])]
                }
                case "AvgPool": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("kernelSize", t, r, o);
                    return [e.avgPool((0, a.getParamValue)("x", t, r, o), [n[1], n[2]], [s[1], s[2]], u)]
                }
                case "MaxPool": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("kernelSize", t, r, o);
                    return [e.maxPool((0, a.getParamValue)("x", t, r, o), [n[1], n[2]], [s[1], s[2]], u)]
                }
                case "MaxPoolWithArgmax": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("kernelSize", t, r, o),
                        l = (0, a.getParamValue)("includeBatchInIndex", t, r, o),
                        {
                            result: i,
                            indexes: d
                        } = e.maxPoolWithArgmax((0, a.getParamValue)("x", t, r, o), [n[1], n[2]], [s[1], s[2]], u, l);
                    return [i, d]
                }
                case "AvgPool3D": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("kernelSize", t, r, o);
                    return [e.avgPool3d((0, a.getParamValue)("x", t, r, o), [n[1], n[2], n[3]], [s[1], s[2], s[3]], u)]
                }
                case "MaxPool3D": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("kernelSize", t, r, o);
                    return [e.maxPool3d((0, a.getParamValue)("x", t, r, o), [n[1], n[2], n[3]], [s[1], s[2], s[3]], u)]
                }
                case "Dilation2D": {
                    const s = (0, a.getParamValue)("strides", t, r, o),
                        u = (0, a.getParamValue)("pad", t, r, o),
                        n = (0, a.getParamValue)("dilations", t, r, o),
                        l = s[1],
                        i = s[2],
                        d = n[1],
                        g = n[2];
                    return [e.dilation2d((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("filter", t, r, o), [l, i], u, [d, g], "NHWC")]
                }
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = o;
        const s = "convolution";
        exports.CATEGORY = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "BxKJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = t();
            if (a && a.has(e)) return a.get(e);
            var r = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var n in e)
                if (Object.prototype.hasOwnProperty.call(e, n)) {
                    var o = u ? Object.getOwnPropertyDescriptor(e, n) : null;
                    o && (o.get || o.set) ? Object.defineProperty(r, n, o) : r[n] = e[n]
                } return r.default = e, a && a.set(e, r), r
        }
        const u = (t, r, u) => {
            switch (t.op) {
                case "Fill": {
                    const n = (0, a.getParamValue)("shape", t, r, u),
                        o = (0, a.getParamValue)("dtype", t, r, u),
                        l = (0, a.getParamValue)("value", t, r, u);
                    return [e.fill(n, l, o)]
                }
                case "LinSpace": {
                    const n = (0, a.getParamValue)("start", t, r, u),
                        o = (0, a.getParamValue)("stop", t, r, u),
                        l = (0, a.getParamValue)("num", t, r, u);
                    return [e.linspace(n, o, l)]
                }
                case "Multinomial": {
                    const n = (0, a.getParamValue)("logits", t, r, u),
                        o = (0, a.getParamValue)("numSamples", t, r, u),
                        l = (0, a.getParamValue)("seed", t, r, u);
                    return [e.multinomial(n, o, l)]
                }
                case "OneHot": {
                    const n = (0, a.getParamValue)("indices", t, r, u),
                        o = (0, a.getParamValue)("depth", t, r, u),
                        l = (0, a.getParamValue)("onValue", t, r, u),
                        s = (0, a.getParamValue)("offValue", t, r, u);
                    return [e.oneHot(n, o, l, s)]
                }
                case "Ones":
                    return [e.ones((0, a.getParamValue)("shape", t, r, u), (0, a.getParamValue)("dtype", t, r, u))];
                case "OnesLike":
                    return [e.onesLike((0, a.getParamValue)("x", t, r, u))];
                case "RandomUniform":
                    return [e.randomUniform((0, a.getParamValue)("shape", t, r, u), (0, a.getParamValue)("minval", t, r, u), (0, a.getParamValue)("maxval", t, r, u), (0, a.getParamValue)("dtype", t, r, u))];
                case "Range": {
                    const n = (0, a.getParamValue)("start", t, r, u),
                        o = (0, a.getParamValue)("stop", t, r, u),
                        l = (0, a.getParamValue)("step", t, r, u);
                    return [e.range(n, o, l, (0, a.getParamValue)("dtype", t, r, u))]
                }
                case "TruncatedNormal": {
                    const n = (0, a.getParamValue)("shape", t, r, u),
                        o = (0, a.getParamValue)("mean", t, r, u),
                        l = (0, a.getParamValue)("stdDev", t, r, u),
                        s = (0, a.getParamValue)("seed", t, r, u);
                    return [e.truncatedNormal(n, o, l, (0, a.getParamValue)("dtype", t, r, u), s)]
                }
                case "Zeros":
                    return [e.zeros((0, a.getParamValue)("shape", t, r, u), (0, a.getParamValue)("dtype", t, r, u))];
                case "ZerosLike":
                    return [e.zerosLike((0, a.getParamValue)("x", t, r, u))];
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = u;
        const n = "creation";
        exports.CATEGORY = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "QjK5": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = a(require("@tensorflow/tfjs-core")),
            t = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = r();
            if (t && t.has(e)) return t.get(e);
            var a = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var n = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    n && (n.get || n.set) ? Object.defineProperty(a, s, n) : a[s] = e[s]
                } return a.default = e, t && t.set(e, a), a
        }
        const o = async (r, a, o) => {
            switch (r.op) {
                case "NonMaxSuppressionV5":
                case "NonMaxSuppressionV4":
                case "NonMaxSuppressionV3":
                case "NonMaxSuppressionV2": {
                    const s = (0, t.getParamValue)("boxes", r, a, o),
                        n = (0, t.getParamValue)("scores", r, a, o),
                        u = (0, t.getParamValue)("maxOutputSize", r, a, o),
                        i = (0, t.getParamValue)("iouThreshold", r, a, o),
                        p = (0, t.getParamValue)("scoreThreshold", r, a, o);
                    if ("NonMaxSuppressionV5" === r.op) {
                        const c = (0, t.getParamValue)("softNmsSigma", r, a, o),
                            l = await e.image.nonMaxSuppressionWithScoreAsync(s, n, u, i, p, c);
                        return [l.selectedIndices, l.selectedScores]
                    }
                    if ("NonMaxSuppressionV4" === r.op) {
                        const c = (0, t.getParamValue)("padToMaxOutputSize", r, a, o),
                            l = await e.image.nonMaxSuppressionPaddedAsync(s, n, u, i, p, c);
                        return [l.selectedIndices, l.validOutputs]
                    }
                    return [await e.image.nonMaxSuppressionAsync(s, n, u, i, p)]
                }
                case "Where": {
                    const s = (0, t.getParamValue)("condition", r, a, o).asType("bool"),
                        n = [await e.whereAsync(s)];
                    return s.dispose(), n
                }
                case "ListDiff":
                    return e.setdiff1dAsync((0, t.getParamValue)("x", r, a, o), (0, t.getParamValue)("y", r, a, o));
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = o;
        const s = "dynamic";
        exports.CATEGORY = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "AFyh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = o(require("@tensorflow/tfjs-core")),
            t = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = r();
            if (t && t.has(e)) return t.get(e);
            var o = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    a && (a.get || a.set) ? Object.defineProperty(o, u, a) : o[u] = e[u]
                } return o.default = e, t && t.set(e, o), o
        }
        const n = (r, o, n) => {
            switch (r.op) {
                case "TopKV2": {
                    const u = (0, t.getParamValue)("x", r, o, n),
                        a = (0, t.getParamValue)("k", r, o, n),
                        p = (0, t.getParamValue)("sorted", r, o, n),
                        i = e.topk(u, a, p);
                    return [i.values, i.indices]
                }
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = n;
        const u = "evaluation";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "jyBO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = a(require("@tensorflow/tfjs-core")),
            r = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var a = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(a, o, s) : a[o] = e[o]
                } return a.default = e, r && r.set(e, a), a
        }
        const n = (t, a, n) => {
            switch (t.op) {
                case "Const":
                    return a[t.name];
                case "PlaceholderWithDefault":
                    const o = (0, r.getParamValue)("default", t, a, n);
                    return [(0, r.getTensor)(t.name, a, n) || o];
                case "Placeholder":
                    return [(0, r.getTensor)(t.name, a, n)];
                case "Identity":
                case "StopGradient":
                case "FakeQuantWithMinMaxVars":
                    return [(0, r.getParamValue)("x", t, a, n).clone()];
                case "IdentityN":
                    return (0, r.getParamValue)("x", t, a, n).map(e => e.clone());
                case "Snapshot":
                    return [(0, r.getParamValue)("x", t, a, n).clone()];
                case "Shape":
                    return [e.tensor1d((0, r.getParamValue)("x", t, a, n).shape, "int32")];
                case "ShapeN":
                    return (0, r.getParamValue)("x", t, a, n).map(r => e.tensor1d(r.shape));
                case "Size":
                    return [e.scalar((0, r.getParamValue)("x", t, a, n).size, "int32")];
                case "Rank":
                    return [e.scalar((0, r.getParamValue)("x", t, a, n).rank, "int32")];
                case "NoOp":
                    return [e.scalar(1)];
                case "Print":
                    const s = (0, r.getParamValue)("x", t, a, n),
                        u = (0, r.getParamValue)("data", t, a, n),
                        c = (0, r.getParamValue)("message", t, a, n),
                        l = (0, r.getParamValue)("summarize", t, a, n);
                    console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(c);
                    for (let e = 0; e < u.length; e++) console.log(Array.prototype.slice.call(u[e].dataSync()).slice(0, l));
                    return [s];
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = n;
        const o = "graph";
        exports.CATEGORY = "graph";
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "KNLe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = a(require("@tensorflow/tfjs-core")),
            r = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = t();
            if (r && r.has(e)) return r.get(e);
            var a = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var n = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    n && (n.get || n.set) ? Object.defineProperty(a, i, n) : a[i] = e[i]
                } return a.default = e, r && r.set(e, a), a
        }
        const o = (t, a, o) => {
            switch (t.op) {
                case "ResizeBilinear": {
                    const i = (0, r.getParamValue)("images", t, a, o),
                        n = (0, r.getParamValue)("size", t, a, o),
                        s = (0, r.getParamValue)("alignCorners", t, a, o);
                    return [e.image.resizeBilinear(i, [n[0], n[1]], s)]
                }
                case "ResizeNearestNeighbor": {
                    const i = (0, r.getParamValue)("images", t, a, o),
                        n = (0, r.getParamValue)("size", t, a, o),
                        s = (0, r.getParamValue)("alignCorners", t, a, o);
                    return [e.image.resizeNearestNeighbor(i, [n[0], n[1]], s)]
                }
                case "CropAndResize": {
                    const i = (0, r.getParamValue)("image", t, a, o),
                        n = (0, r.getParamValue)("boxes", t, a, o),
                        s = (0, r.getParamValue)("boxInd", t, a, o),
                        u = (0, r.getParamValue)("cropSize", t, a, o),
                        l = (0, r.getParamValue)("method", t, a, o),
                        p = (0, r.getParamValue)("extrapolationValue", t, a, o);
                    return [e.image.cropAndResize(i, n, s, u, l, p)]
                }
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = o;
        const i = "image";
        exports.CATEGORY = "image";
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "Ehox": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = t(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function t(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = r();
            if (a && a.has(e)) return a.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var l in e)
                if (Object.prototype.hasOwnProperty.call(e, l)) {
                    var o = u ? Object.getOwnPropertyDescriptor(e, l) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, l, o) : t[l] = e[l]
                } return t.default = e, a && a.set(e, t), t
        }
        const u = (r, t, u) => {
            switch (r.op) {
                case "Equal":
                    return [e.equal((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "NotEqual":
                    return [e.notEqual((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Greater":
                    return [e.greater((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "GreaterEqual":
                    return [e.greaterEqual((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Less":
                    return [e.less((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "LessEqual":
                    return [e.lessEqual((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "LogicalAnd":
                    return [e.logicalAnd((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "LogicalNot":
                    return [e.logicalNot((0, a.getParamValue)("a", r, t, u))];
                case "LogicalOr":
                    return [e.logicalOr((0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                case "Select":
                case "SelectV2":
                    return [e.where((0, a.getParamValue)("condition", r, t, u), (0, a.getParamValue)("a", r, t, u), (0, a.getParamValue)("b", r, t, u))];
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = u;
        const l = "logical";
        exports.CATEGORY = l;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "lcpM": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            t = require("./utils");

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var o = s ? Object.getOwnPropertyDescriptor(e, u) : null;
                    o && (o.get || o.set) ? Object.defineProperty(r, u, o) : r[u] = e[u]
                } return r.default = e, t && t.set(e, r), r
        }
        const s = (a, r, s) => {
            switch (a.op) {
                case "BatchMatMul":
                case "BatchMatMulV2":
                case "MatMul":
                    return [e.matMul((0, t.getParamValue)("a", a, r, s), (0, t.getParamValue)("b", a, r, s), (0, t.getParamValue)("transposeA", a, r, s), (0, t.getParamValue)("transposeB", a, r, s))];
                case "Transpose":
                    return [e.transpose((0, t.getParamValue)("x", a, r, s), (0, t.getParamValue)("perm", a, r, s))];
                case "_FusedMatMul":
                    const [u, o] = (0, t.getParamValue)("fusedOps", a, r, s), n = "biasadd" === u, l = "prelu" === o, i = (0, t.getParamValue)("numArgs", a, r, s);
                    if (n) {
                        if (l && 2 !== i) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                        if (!l && 1 !== i) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
                    }
                    const [p, c] = (0, t.getParamValue)("args", a, r, s);
                    return [e.fused.matMul({
                        a: (0, t.getParamValue)("a", a, r, s),
                        b: (0, t.getParamValue)("b", a, r, s),
                        transposeA: (0, t.getParamValue)("transposeA", a, r, s),
                        transposeB: (0, t.getParamValue)("transposeB", a, r, s),
                        bias: p,
                        activation: o,
                        preluActivationWeights: c
                    })];
                default:
                    throw TypeError(`Node type ${a.op} is not implemented`)
            }
        };
        exports.executeOp = s;
        const u = "matrices";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "kX2x": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = t();
            if (a && a.has(e)) return a.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, u) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, u, s) : r[u] = e[u]
                } return r.default = e, a && a.set(e, r), r
        }
        const o = (t, r, o) => {
            switch (t.op) {
                case "FusedBatchNorm":
                case "FusedBatchNormV2":
                case "FusedBatchNormV3":
                    return [e.batchNorm((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("mean", t, r, o), (0, a.getParamValue)("variance", t, r, o), (0, a.getParamValue)("offset", t, r, o), (0, a.getParamValue)("scale", t, r, o), (0, a.getParamValue)("epsilon", t, r, o))];
                case "LRN":
                    return [e.localResponseNormalization((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("radius", t, r, o), (0, a.getParamValue)("bias", t, r, o), (0, a.getParamValue)("alpha", t, r, o), (0, a.getParamValue)("beta", t, r, o))];
                case "Softmax":
                    return [e.softmax((0, a.getParamValue)("x", t, r, o))];
                case "LogSoftmax":
                    return [e.logSoftmax((0, a.getParamValue)("x", t, r, o))];
                case "SparseToDense":
                    return [e.sparseToDense((0, a.getParamValue)("sparseIndices", t, r, o), (0, a.getParamValue)("outputShape", t, r, o), (0, a.getParamValue)("sparseValues", t, r, o), (0, a.getParamValue)("defaultValue", t, r, o))];
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = o;
        const u = "normalization";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "qW2A": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = t(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function t(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = r();
            if (a && a.has(e)) return a.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var n = u ? Object.getOwnPropertyDescriptor(e, s) : null;
                    n && (n.get || n.set) ? Object.defineProperty(t, s, n) : t[s] = e[s]
                } return t.default = e, a && a.set(e, t), t
        }
        const u = (r, t, u) => {
            switch (r.op) {
                case "Max": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.max((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "Mean": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.mean((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "Min": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.min((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "Sum": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.sum((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "All": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.all((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "Any": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.any((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "ArgMax": {
                    const s = (0, a.getParamValue)("axis", r, t, u);
                    return [e.argMax((0, a.getParamValue)("x", r, t, u), s)]
                }
                case "ArgMin": {
                    const s = (0, a.getParamValue)("axis", r, t, u);
                    return [e.argMin((0, a.getParamValue)("x", r, t, u), s)]
                }
                case "Prod": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("keepDims", r, t, u);
                    return [e.prod((0, a.getParamValue)("x", r, t, u), s, n)]
                }
                case "Cumsum": {
                    const s = (0, a.getParamValue)("axis", r, t, u),
                        n = (0, a.getParamValue)("exclusive", r, t, u),
                        o = (0, a.getParamValue)("reverse", r, t, u);
                    return [e.cumsum((0, a.getParamValue)("x", r, t, u), s, n, o)]
                }
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = u;
        const s = "reduction";
        exports.CATEGORY = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "Jy49": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = t();
            if (a && a.has(e)) return a.get(e);
            var r = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var n = s ? Object.getOwnPropertyDescriptor(e, u) : null;
                    n && (n.get || n.set) ? Object.defineProperty(r, u, n) : r[u] = e[u]
                } return r.default = e, a && a.set(e, r), r
        }
        const s = (t, r, s) => {
            switch (t.op) {
                case "ConcatV2":
                case "Concat": {
                    const u = (0, a.getParamValue)("n", t, r, s),
                        n = (0, a.getParamValue)("axis", t, r, s);
                    let l = (0, a.getParamValue)("tensors", t, r, s);
                    return l = l.slice(0, u), [e.concat(l, n)]
                }
                case "GatherV2":
                case "Gather": {
                    const u = (0, a.getParamValue)("axis", t, r, s),
                        n = (0, a.getParamValue)("x", t, r, s),
                        l = (0, a.getParamValue)("indices", t, r, s);
                    return [e.gather(n, l.asType("int32"), u)]
                }
                case "ReverseV2":
                case "Reverse": {
                    const u = (0, a.getParamValue)("axis", t, r, s),
                        n = (0, a.getParamValue)("x", t, r, s);
                    return [e.reverse(n, u)]
                }
                case "Slice": {
                    const u = (0, a.getParamValue)("begin", t, r, s),
                        n = (0, a.getParamValue)("size", t, r, s);
                    return [e.slice((0, a.getParamValue)("x", t, r, s), u, n)]
                }
                case "StridedSlice": {
                    const u = (0, a.getParamValue)("begin", t, r, s),
                        n = (0, a.getParamValue)("end", t, r, s),
                        l = (0, a.getParamValue)("strides", t, r, s),
                        c = (0, a.getParamValue)("beginMask", t, r, s),
                        i = (0, a.getParamValue)("endMask", t, r, s),
                        o = (0, a.getParamValue)("ellipsisMask", t, r, s),
                        p = (0, a.getParamValue)("newAxisMask", t, r, s),
                        g = (0, a.getParamValue)("shrinkAxisMask", t, r, s),
                        P = (0, a.getParamValue)("x", t, r, s);
                    return [e.stridedSlice(P, u, n, l, c, i, o, p, g)]
                }
                case "Pack":
                    return e.tidy(() => {
                        const u = (0, a.getParamValue)("axis", t, r, s),
                            n = (0, a.getParamValue)("tensors", t, r, s),
                            l = n[0].shape,
                            c = n[0].squeeze().shape,
                            i = n.map(a => {
                                const t = e.util.arraysEqual(a.shape, l);
                                if (!t && !e.util.arraysEqual(a.squeeze().shape, c)) throw new Error("the input tensors shape does not match");
                                return t ? a : a.reshape(l)
                            });
                        return [e.stack(i, u)]
                    });
                case "Unpack":
                    return e.tidy(() => {
                        const u = (0, a.getParamValue)("axis", t, r, s),
                            n = (0, a.getParamValue)("tensor", t, r, s);
                        return e.unstack(n, u)
                    });
                case "Tile": {
                    const u = (0, a.getParamValue)("reps", t, r, s);
                    return [e.tile((0, a.getParamValue)("x", t, r, s), u)]
                }
                case "Split":
                case "SplitV": {
                    const u = (0, a.getParamValue)("axis", t, r, s),
                        n = (0, a.getParamValue)("numOrSizeSplits", t, r, s),
                        l = (0, a.getParamValue)("x", t, r, s);
                    return e.split(l, n, u)
                }
                case "ScatterNd": {
                    const u = (0, a.getParamValue)("indices", t, r, s),
                        n = (0, a.getParamValue)("values", t, r, s),
                        l = (0, a.getParamValue)("shape", t, r, s);
                    return [e.scatterND(u, n, l)]
                }
                case "GatherNd": {
                    const u = (0, a.getParamValue)("x", t, r, s),
                        n = (0, a.getParamValue)("indices", t, r, s);
                    return [e.gatherND(u, n)]
                }
                case "SparseToDense": {
                    const u = (0, a.getParamValue)("sparseIndices", t, r, s),
                        n = (0, a.getParamValue)("outputShape", t, r, s),
                        l = (0, a.getParamValue)("sparseValues", t, r, s),
                        c = (0, a.getParamValue)("defaultValue", t, r, s);
                    return [e.sparseToDense(u, l, n, l.dtype === c.dtype ? c : c.asType(l.dtype))]
                }
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = s;
        const u = "slice_join";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "A7QN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = o(require("@tensorflow/tfjs-core")),
            t = require("./utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return r = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = r();
            if (t && t.has(e)) return t.get(e);
            var o = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var a = n ? Object.getOwnPropertyDescriptor(e, u) : null;
                    a && (a.get || a.set) ? Object.defineProperty(o, u, a) : o[u] = e[u]
                } return o.default = e, t && t.set(e, o), o
        }
        const n = (r, o, n) => {
            switch (r.op) {
                case "FFT":
                    return [e.fft((0, t.getParamValue)("x", r, o, n))];
                case "IFFT":
                    return [e.ifft((0, t.getParamValue)("x", r, o, n))];
                case "RFFT":
                    return [e.rfft((0, t.getParamValue)("x", r, o, n))];
                case "IRFFT":
                    return [e.irfft((0, t.getParamValue)("x", r, o, n))];
                default:
                    throw TypeError(`Node type ${r.op} is not implemented`)
            }
        };
        exports.executeOp = n;
        const u = "spectral";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "oReL": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CATEGORY = exports.executeOp = void 0;
        var e = r(require("@tensorflow/tfjs-core")),
            a = require("./utils");

        function t() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return t = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var a = t();
            if (a && a.has(e)) return a.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, u) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, u, s) : r[u] = e[u]
                } return r.default = e, a && a.set(e, r), r
        }
        const o = (t, r, o) => {
            switch (t.op) {
                case "Cast":
                    return [e.cast((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("dtype", t, r, o))];
                case "ExpandDims": {
                    const u = (0, a.getParamValue)("axis", t, r, o);
                    return [e.expandDims((0, a.getParamValue)("x", t, r, o), u)]
                }
                case "Squeeze": {
                    const u = (0, a.getParamValue)("axis", t, r, o);
                    return [e.squeeze((0, a.getParamValue)("x", t, r, o), u)]
                }
                case "Reshape":
                    return [e.reshape((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("shape", t, r, o))];
                case "PadV2":
                case "Pad":
                    return [e.pad((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("padding", t, r, o), (0, a.getParamValue)("constantValue", t, r, o))];
                case "SpaceToBatchND": {
                    const u = (0, a.getParamValue)("blockShape", t, r, o),
                        s = (0, a.getParamValue)("paddings", t, r, o);
                    return [e.spaceToBatchND((0, a.getParamValue)("x", t, r, o), u, s)]
                }
                case "BatchToSpaceND": {
                    const u = (0, a.getParamValue)("blockShape", t, r, o),
                        s = (0, a.getParamValue)("crops", t, r, o);
                    return [e.batchToSpaceND((0, a.getParamValue)("x", t, r, o), u, s)]
                }
                case "DepthToSpace": {
                    const u = (0, a.getParamValue)("blockSize", t, r, o),
                        s = (0, a.getParamValue)("dataFormat", t, r, o).toUpperCase();
                    return [e.depthToSpace((0, a.getParamValue)("x", t, r, o), u, s)]
                }
                case "BroadcastTo":
                    return [e.broadcastTo((0, a.getParamValue)("x", t, r, o), (0, a.getParamValue)("shape", t, r, o))];
                default:
                    throw TypeError(`Node type ${t.op} is not implemented`)
            }
        };
        exports.executeOp = o;
        const u = "transformation";
        exports.CATEGORY = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./utils": "w10i"
    }],
    "aGmR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.executeOp = h;
        var e = g(require("@tensorflow/tfjs-core")),
            r = require("./custom_op/node_value_impl"),
            t = require("./custom_op/register"),
            u = g(require("./executors/arithmetic_executor")),
            c = g(require("./executors/basic_math_executor")),
            o = g(require("./executors/control_executor")),
            i = g(require("./executors/convolution_executor")),
            n = g(require("./executors/creation_executor")),
            s = g(require("./executors/dynamic_executor")),
            a = g(require("./executors/evaluation_executor")),
            x = g(require("./executors/graph_executor")),
            p = g(require("./executors/image_executor")),
            l = g(require("./executors/logical_executor")),
            d = g(require("./executors/matrices_executor")),
            f = g(require("./executors/normalization_executor")),
            y = g(require("./executors/reduction_executor")),
            O = g(require("./executors/slice_join_executor")),
            _ = g(require("./executors/spectral_executor")),
            m = g(require("./executors/transformation_executor"));

        function q() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return q = function() {
                return e
            }, e
        }

        function g(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = q();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                u = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var c in e)
                if (Object.prototype.hasOwnProperty.call(e, c)) {
                    var o = u ? Object.getOwnPropertyDescriptor(e, c) : null;
                    o && (o.get || o.set) ? Object.defineProperty(t, c, o) : t[c] = e[c]
                } return t.default = e, r && r.set(e, t), t
        }

        function h(q, g, h) {
            const w = ((q, g, h) => {
                switch (q.category) {
                    case "arithmetic":
                        return e.tidy(() => u.executeOp(q, g, h));
                    case "basic_math":
                        return e.tidy(() => c.executeOp(q, g, h));
                    case "control":
                        return o.executeOp(q, g, h);
                    case "convolution":
                        return e.tidy(() => i.executeOp(q, g, h));
                    case "creation":
                        return e.tidy(() => n.executeOp(q, g, h));
                    case "dynamic":
                        return s.executeOp(q, g, h);
                    case "evaluation":
                        return e.tidy(() => a.executeOp(q, g, h));
                    case "image":
                        return e.tidy(() => p.executeOp(q, g, h));
                    case "graph":
                        return e.tidy(() => x.executeOp(q, g, h));
                    case "logical":
                        return e.tidy(() => l.executeOp(q, g, h));
                    case "matrices":
                        return e.tidy(() => d.executeOp(q, g, h));
                    case "normalization":
                        return e.tidy(() => f.executeOp(q, g, h));
                    case "reduction":
                        return e.tidy(() => y.executeOp(q, g, h));
                    case "slice_join":
                        return e.tidy(() => O.executeOp(q, g, h));
                    case "spectral":
                        return e.tidy(() => _.executeOp(q, g, h));
                    case "transformation":
                        return e.tidy(() => m.executeOp(q, g, h));
                    case "custom":
                        const w = (0, t.getRegisteredOp)(q.op);
                        if (w && w.customExecutor) return w.customExecutor(new r.NodeValueImpl(q, g, h));
                        throw TypeError(`Custom op ${q.op} is not registered.`);
                    default:
                        throw TypeError(`Unknown op '${q.op}'. File an issue at ` + "https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")
                }
            })(q, g, h);
            return w instanceof Promise ? w.then(e => [].concat(e)) : [].concat(w)
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./custom_op/node_value_impl": "lSvz",
        "./custom_op/register": "gQtl",
        "./executors/arithmetic_executor": "IGj9",
        "./executors/basic_math_executor": "dVEs",
        "./executors/control_executor": "NqZC",
        "./executors/convolution_executor": "Gr2b",
        "./executors/creation_executor": "BxKJ",
        "./executors/dynamic_executor": "QjK5",
        "./executors/evaluation_executor": "AFyh",
        "./executors/graph_executor": "jyBO",
        "./executors/image_executor": "KNLe",
        "./executors/logical_executor": "Ehox",
        "./executors/matrices_executor": "lcpM",
        "./executors/normalization_executor": "kX2x",
        "./executors/reduction_executor": "qW2A",
        "./executors/slice_join_executor": "Jy49",
        "./executors/spectral_executor": "A7QN",
        "./executors/transformation_executor": "oReL"
    }],
    "rYIb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ExecutionContext = void 0;
        class t {
            constructor(t = {}, e = {}, s = {}, n = {}) {
                this.weightMap = t, this.tensorArrayMap = e, this.tensorListMap = s, this.functionMap = n, this.rootContext = {
                    id: 0,
                    frameName: "",
                    iterationId: 0
                }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
            }
            newFrame(t, e) {
                return {
                    id: t,
                    frameName: e,
                    iterationId: 0
                }
            }
            set currentContext(t) {
                this.contexts !== t && (this.contexts = t, this.generateCurrentContextIds())
            }
            get currentContext() {
                return this.contexts
            }
            get currentContextId() {
                return this._currentContextIds[0]
            }
            get currentContextIds() {
                return this._currentContextIds
            }
            generateCurrentContextIds() {
                const t = [];
                for (let e = 0; e < this.contexts.length - 1; e++) {
                    const s = this.contexts.slice(0, this.contexts.length - e);
                    t.push(this.contextIdforContexts(s))
                }
                t.push(""), this._currentContextIds = t
            }
            contextIdforContexts(t) {
                return t ? t.map(t => 0 === t.id && 0 === t.iterationId ? "" : `${t.frameName}-${t.iterationId}`).join("/") : ""
            }
            enterFrame(t) {
                this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, t)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
            }
            exitFrame() {
                if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
                this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
            }
            nextIteration() {
                if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty"); {
                    this.contexts = this.contexts.slice(), this.lastId++;
                    const t = Object.assign({}, this.contexts[this.contexts.length - 1]);
                    t.iterationId += 1, t.id = this.lastId, this.contexts.splice(-1, 1, t), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
                }
            }
            getWeight(t) {
                return this.weightMap[t]
            }
            addTensorArray(t) {
                this.tensorArrayMap[t.id] = t
            }
            getTensorArray(t) {
                return this.tensorArrayMap[t]
            }
            addTensorList(t) {
                this.tensorListMap[t.id] = t
            }
            getTensorList(t) {
                return this.tensorListMap[t]
            }
            dispose() {
                for (const t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose();
                for (const t in this.tensorListMap) this.tensorListMap[t].clearAndClose()
            }
        }
        exports.ExecutionContext = t;
    }, {}],
    "pWc7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getExecutionSubgraph = n, exports.getNodesInTopologicalOrder = s, exports.isControlFlow = a, exports.isDynamicShape = r;
        var e = require("../operations/executors/utils");

        function n(n, s, t) {
            const o = new Set,
                p = [];
            let u = null,
                i = null;
            const h = new Set,
                c = Object.keys(n).map(n => (0, e.parseNodeName)(n)[0]),
                l = [...s];
            for (; l.length > 0;) {
                const e = l.pop();
                (a(e) || r(e)) && null == u && (i = (u = e).children.map(e => e.name).filter(e => o.has(e))), o.add(e.name), null == t[e.name] && (-1 === c.indexOf(e.name) && (0 !== e.inputs.length ? e.inputs.forEach(e => {
                    h.has(e.name) || (h.add(e.name), l.push(e))
                }) : p.push(e.name)))
            }
            return {
                inputs: n,
                outputs: s,
                usedNodes: o,
                missingInputs: p,
                dynamicNode: u,
                syncInputs: i
            }
        }

        function s(n, s, t) {
            const {
                usedNodes: o,
                inputs: a
            } = t, r = [];
            Object.keys(a).map(n => (0, e.parseNodeName)(n)[0]).map(e => n.nodes[e]).forEach(e => {
                o.has(e.name) && r.push(e)
            }), n.weights.forEach(e => {
                o.has(e.name) && r.push(e)
            });
            const p = new Set,
                u = [];
            for (; r.length > 0;) {
                const e = r.pop();
                p.add(e.name), s[e.name] || u.push(e), e.children.forEach(e => {
                    !p.has(e.name) && o.has(e.name) && e.inputs.every(e => p.has(e.name)) && r.push(e)
                })
            }
            return u
        }
        const t = ["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"],
            o = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"];

        function a(e) {
            return t.indexOf(e.op) >= 0
        }

        function r(e) {
            return o.indexOf(e.op) >= 0
        }
    }, {
        "../operations/executors/utils": "w10i"
    }],
    "X0ED": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.GraphExecutor = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("../operations/executors/utils"),
            s = require("../operations/operation_executor"),
            n = require("./execution_context"),
            o = require("./model_analysis");
        class i {
            constructor(e, t) {
                this.graph = e, this.parent = t, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this._outputs = e.outputs, this._inputs = e.inputs, this._signature = e.signature, this._functions = e.functions, null != e.functions && Object.keys(e.functions).forEach(t => {
                    this._functionExecutorMap[t] = new i(e.functions[t], this)
                })
            }
            get weightIds() {
                return this.parent ? this.parent.weightIds : this._weightIds
            }
            get functionExecutorMap() {
                return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap
            }
            get weightMap() {
                return this.parent ? this.parent.weightMap : this._weightMap
            }
            set weightMap(e) {
                const t = Object.keys(e).map(t => e[t].map(e => e.id));
                this._weightIds = [].concat(...t), this._weightMap = e
            }
            get inputs() {
                return this._inputs.map(e => ({
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                }))
            }
            get outputs() {
                return this._outputs.map(e => ({
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                }))
            }
            get inputNodes() {
                return this._inputs.map(e => e.signatureKey || e.name)
            }
            get outputNodes() {
                return this._outputs.map(e => {
                    const t = e.signatureKey || e.name;
                    return e.defaultOutput ? `${t}:${e.defaultOutput}` : t
                })
            }
            get functions() {
                return Object.keys(this._functions).reduce((e, t) => (e[t] = this._functions[t].signature, e), {})
            }
            getCompilationKey(e, t) {
                const s = e.map(e => e.name).sort(),
                    n = t.map(e => e.name).sort();
                return s.join(this.SEPERATOR) + "--" + n.join(this.SEPERATOR)
            }
            compile(e, t) {
                const s = (0, o.getExecutionSubgraph)(e, t, this.weightMap),
                    {
                        missingInputs: n,
                        dynamicNode: i,
                        syncInputs: a
                    } = s;
                if (null != i) throw new Error(`This execution contains the node '${i.name}', which has ` + `the dynamic op '${i.op}'. Please use ` + "model.executeAsync() instead. Alternatively, to avoid the " + `dynamic ops, specify the inputs [${a}]`);
                if (n.length > 0) {
                    const s = t.map(e => e.name),
                        o = Object.keys(e);
                    throw new Error(`Cannot compute the outputs [${s}] from the provided inputs ` + `[${o}]. Missing the following inputs: [${n}]`)
                }
                return (0, o.getNodesInTopologicalOrder)(this.graph, this.weightMap, s)
            }
            execute(o, i) {
                o = this.mapInputs(o);
                const a = Object.keys(o).sort();
                this.checkInputs(o), this.checkInputShapeAndType(o), i = this.mapOutputs(i), this.checkOutputs(i);
                const r = a.map(e => this.graph.nodes[(0, t.parseNodeName)(e)[0]]),
                    p = i.map(e => this.graph.nodes[(0, t.parseNodeName)(e)[0]]),
                    u = this.getCompilationKey(r, p);
                let h = this.compiledMap.get(u);
                null == h && (h = this.compile(o, p), this.compiledMap.set(u, h));
                const c = {},
                    d = {};
                return (0, e.tidy)(() => {
                    const e = new n.ExecutionContext(this.weightMap, c, d, this.functionExecutorMap),
                        a = Object.assign({}, this.weightMap);
                    Object.keys(o).forEach(e => {
                        const [s, n] = (0, t.parseNodeName)(e), i = [];
                        i[n] = o[e], a[s] = i
                    });
                    const r = this.getFrozenTensorIds(a),
                        p = {};
                    for (let t = 0; t < h.length; t++) {
                        const n = h[t];
                        if (!a[n.name]) {
                            const t = (0, s.executeOp)(n, a, e);
                            if (t instanceof Promise) throw new Error(`The execution of the op '${n.op}' returned a promise. ` + "Please use model.executeAsync() instead.");
                            a[n.name] = t, this.checkTensorForDisposal(n.name, n, a, e, r, i, p)
                        }
                    }
                    return null == this.parent && e.dispose(), i.map(s => (0, t.getTensor)(s, a, e))
                })
            }
            getFrozenTensorIds(e) {
                const t = [].concat.apply([], Object.keys(e).map(t => e[t]).map(e => e.map(e => e.id)));
                return new Set(t)
            }
            checkTensorForDisposal(e, s, n, o, i, a, r) {
                "control" !== s.category && -1 === a.indexOf(e) && (n[e].forEach(e => {
                    null != e && (r[e.id] = (r[e.id] || 0) + s.children.length)
                }), s.inputs.forEach(e => {
                    if ("control" !== e.category) {
                        const s = (0, t.getTensorsForCurrentContenxt)(e.name, n, o);
                        null != s && s.forEach(e => {
                            if (e && !i.has(e.id)) {
                                const t = r[e.id];
                                1 === t ? (e.dispose(), delete r[e.id]) : null != t && r[e.id]--
                            }
                        })
                    }
                }))
            }
            async executeAsync(e, t) {
                return this._executeAsync(e, t)
            }
            async _executeAsync(e, s, o = !1, i = {}, a = {}) {
                o || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), s = this.mapOutputs(s), this.checkOutputs(s));
                const r = new n.ExecutionContext(this.weightMap, i, a, this.functionExecutorMap),
                    p = await this.executeWithControlFlow(e, r, s, o),
                    u = s.map(e => (0, t.getTensor)(e, p, r)),
                    h = new Set(u.map(e => e.id)),
                    c = new Set(Object.keys(e).map(t => e[t].id));
                return Object.keys(p).forEach(e => {
                    p[e].forEach(e => {
                        !e || e.isDisposed || h.has(e.id) || c.has(e.id) || -1 !== this.weightIds.indexOf(e.id) || e.dispose()
                    })
                }), null == this.parent && r.dispose(), u
            }
            async executeFunctionAsync(e, t, s) {
                const n = e.reduce((e, t, s) => (e[this.inputs[s].name] = t, e), {});
                return this._executeAsync(n, this.outputNodes, !0, t, s)
            }
            async executeWithControlFlow(e, s, n, i) {
                const a = Object.keys(e),
                    r = a.map(e => this.graph.nodes[(0, t.parseNodeName)(e)[0]]),
                    p = n.map(e => this.graph.nodes[(0, t.parseNodeName)(e)[0]]),
                    {
                        usedNodes: u,
                        missingInputs: h,
                        dynamicNode: c,
                        syncInputs: d
                    } = (0, o.getExecutionSubgraph)(e, p, this.weightMap),
                    l = [...r, ...this.graph.weights].map(e => ({
                        node: e,
                        contexts: s.currentContext
                    })),
                    m = Object.assign({}, this.weightMap);
                Object.keys(e).forEach(s => {
                    const [n, o] = (0, t.parseNodeName)(s), i = [];
                    i[o] = e[s], m[n] = i
                });
                const g = {},
                    f = this.getFrozenTensorIds(m),
                    y = {};
                for (; l.length > 0;) {
                    const e = this.processStack(r, l, s, m, y, f, n, g, u);
                    await Promise.all(e)
                }
                null != c || i || console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
                const x = p.filter(e => !(0, o.isControlFlow)(e) && !(0, t.getTensor)(e.name, m, s)).map(e => e.name);
                if (x.length > 0) {
                    let e = "";
                    throw null != c && (e = "Alternatively, to avoid the dynamic ops, use model.execute() " + `and specify the inputs [${d}]`), new Error(`Cannot compute the outputs [${x}] from the provided ` + `inputs [${a}]. Consider providing the following inputs: ` + `[${h}]. ${e}`)
                }
                return m
            }
            processStack(e, n, o, i, a, r, p, u, h) {
                const c = [];
                for (; n.length > 0;) {
                    const d = n.pop();
                    o.currentContext = d.contexts;
                    let l = "";
                    if ("Enter" === d.node.op && (0, t.getParamValue)("isConstant", d.node, i, o) && ([l] = (0, t.getNodeNameAndIndex)(d.node.name, o)), -1 === e.indexOf(d.node)) {
                        const e = (0, s.executeOp)(d.node, i, o);
                        l || ([l] = (0, t.getNodeNameAndIndex)(d.node.name, o));
                        const m = o.currentContext;
                        e instanceof Promise ? c.push(e.then(e => (i[l] = e, o.currentContext = m, this.checkTensorForDisposal(l, d.node, i, o, r, p, u), this.processChildNodes(d.node, n, o, i, a, h), e))) : (i[l] = e, this.checkTensorForDisposal(l, d.node, i, o, r, p, u), this.processChildNodes(d.node, n, o, i, a, h))
                    } else this.processChildNodes(d.node, n, o, i, a, h)
                }
                return c
            }
            processChildNodes(e, s, n, o, i, a) {
                e.children.forEach(e => {
                    const [r] = (0, t.getNodeNameAndIndex)(e.name, n);
                    !i[r] && a.has(e.name) && ("Merge" === e.op ? e.inputNames.some(e => !!(0, t.getTensor)(e, o, n)) && (i[r] = !0, s.push({
                        contexts: n.currentContext,
                        node: e
                    })) : e.inputNames.every(e => !!(0, t.getTensor)(e, o, n)) && (i[r] = !0, s.push({
                        contexts: n.currentContext,
                        node: e
                    })))
                })
            }
            dispose() {
                Object.keys(this.weightMap).forEach(e => this.weightMap[e].forEach(e => e.dispose()))
            }
            checkInputShapeAndType(s) {
                Object.keys(s).forEach(n => {
                    const o = s[n],
                        [i] = (0, t.parseNodeName)(n),
                        a = this.graph.nodes[i];
                    if (a.attrParams.shape && a.attrParams.shape.value) {
                        const t = a.attrParams.shape.value,
                            s = t.length === o.shape.length && o.shape.every((e, s) => -1 === t[s] || t[s] === e);
                        e.util.assert(s, () => `The shape of dict['${a.name}'] provided in ` + `model.execute(dict) must be [${t}], but was ` + `[${o.shape}]`)
                    }
                    a.attrParams.dtype && a.attrParams.dtype.value && e.util.assert(o.dtype === a.attrParams.dtype.value, () => `The dtype of dict['${a.name}'] provided in ` + "model.execute(dict) must be " + `${a.attrParams.dtype.value}, but was ${o.dtype}`)
                })
            }
            mapInputs(e) {
                const t = {};
                for (const s in e)
                    if (null != this._signature && null != this._signature.inputs && null != this._signature.inputs[s]) {
                        t[this._signature.inputs[s].name] = e[s]
                    } else t[s] = e[s];
                return t
            }
            checkInputs(e) {
                const s = Object.keys(e).filter(e => {
                    const [s] = (0, t.parseNodeName)(e);
                    return null == this.graph.nodes[s]
                });
                if (s.length > 0) throw new Error("The dict provided in model.execute(dict) has " + `keys: [${s}] that are not part of graph`)
            }
            mapOutputs(e) {
                return e.map(e => {
                    if (null != this._signature && null != this._signature.outputs && null != this._signature.outputs[e]) {
                        return this._signature.outputs[e].name
                    }
                    return e
                }, {})
            }
            checkOutputs(e) {
                e.forEach(e => {
                    const [s] = (0, t.parseNodeName)(e);
                    if (!this.graph.nodes[s]) throw new Error(`The output '${e}' is not found in the graph`)
                })
            }
        }
        exports.GraphExecutor = i;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../operations/executors/utils": "w10i",
        "../operations/operation_executor": "aGmR",
        "./execution_context": "rYIb",
        "./model_analysis": "pWc7"
    }],
    "JWGp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.loadGraphModel = i, exports.GraphModel = exports.DEFAULT_MODEL_NAME = exports.TFHUB_SEARCH_PARAM = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("../operations/operation_mapper"),
            r = require("./graph_executor");
        const o = "?tfjs-format=file";
        exports.TFHUB_SEARCH_PARAM = o;
        const s = "model.json";
        exports.DEFAULT_MODEL_NAME = s;
        class n {
            constructor(e, t = {}) {
                this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {})
            }
            get modelVersion() {
                return this.version
            }
            get inputNodes() {
                return this.executor.inputNodes
            }
            get outputNodes() {
                return this.executor.outputNodes
            }
            get inputs() {
                return this.executor.inputs
            }
            get outputs() {
                return this.executor.outputs
            }
            get weights() {
                return this.executor.weightMap
            }
            findIOHandler() {
                const t = this.modelUrl;
                if (null != t.load) this.handler = t;
                else if (null != this.loadOptions.requestInit) this.handler = e.io.browserHTTPRequest(t, this.loadOptions);
                else {
                    const r = e.io.getLoadHandlers(t, this.loadOptions);
                    if (0 === r.length) r.push(e.io.browserHTTPRequest(t, this.loadOptions));
                    else if (r.length > 1) throw new Error(`Found more than one (${r.length}) load handlers for ` + `URL '${[t]}'`);
                    this.handler = r[0]
                }
            }
            async load() {
                if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                const e = await this.handler.load();
                return this.loadSync(e)
            }
            loadSync(o) {
                this.artifacts = o;
                const s = this.artifacts.modelTopology;
                let n = {};
                null != this.artifacts.userDefinedMetadata && (n = this.artifacts.userDefinedMetadata.signature), this.version = `${s.versions.producer}.${s.versions.minConsumer}`;
                const i = e.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
                return this.executor = new r.GraphExecutor(t.OperationMapper.Instance.transformGraph(s, n)), this.executor.weightMap = this.convertTensorMapToTensorsMap(i), !0
            }
            async save(t, r) {
                if ("string" == typeof t) {
                    const r = e.io.getSaveHandlers(t);
                    if (0 === r.length) throw new Error(`Cannot find any save handlers for URL '${t}'`);
                    if (r.length > 1) throw new Error(`Found more than one (${r.length}) save handlers for ` + `URL '${t}'`);
                    t = r[0]
                }
                if (null == t.save) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                return t.save(this.artifacts)
            }
            predict(e, t) {
                return this.execute(e, this.outputNodes)
            }
            normalizeInputs(t) {
                if (!(t instanceof e.Tensor || Array.isArray(t))) return t;
                if ((t = Array.isArray(t) ? t : [t]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch," + `the graph model has ${this.inputNodes.length} placeholders, ` + `while there are ${t.length} input tensors.`);
                return this.inputNodes.reduce((e, r, o) => (e[r] = t[o], e), {})
            }
            normalizeOutputs(e) {
                return e = e || this.outputNodes, Array.isArray(e) ? e : [e]
            }
            execute(e, t) {
                e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                const r = this.executor.execute(e, t);
                return r.length > 1 ? r : r[0]
            }
            async executeAsync(e, t) {
                e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                const r = await this.executor.executeAsync(e, t);
                return r.length > 1 ? r : r[0]
            }
            convertTensorMapToTensorsMap(e) {
                return Object.keys(e).reduce((t, r) => (t[r] = [e[r]], t), {})
            }
            dispose() {
                this.executor.dispose()
            }
        }
        async function i(e, t = {}) {
            if (null == e) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
            null == t && (t = {}), t.fromTFHub && null == e.load && (e.endsWith("/") || (e += "/"), e = `${e}${s}${o}`);
            const r = new n(e, t);
            return await r.load(), r
        }
        exports.GraphModel = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../operations/operation_mapper": "SpEM",
        "./graph_executor": "X0ED"
    }],
    "OiNd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "GraphModel", {
            enumerable: !0,
            get: function() {
                return e.GraphModel
            }
        }), Object.defineProperty(exports, "loadGraphModel", {
            enumerable: !0,
            get: function() {
                return e.loadGraphModel
            }
        }), Object.defineProperty(exports, "deregisterOp", {
            enumerable: !0,
            get: function() {
                return r.deregisterOp
            }
        }), Object.defineProperty(exports, "registerOp", {
            enumerable: !0,
            get: function() {
                return r.registerOp
            }
        }), Object.defineProperty(exports, "version_converter", {
            enumerable: !0,
            get: function() {
                return t.version
            }
        });
        var e = require("./executor/graph_model"),
            r = require("./operations/custom_op/register"),
            t = require("./version");
    }, {
        "./executor/graph_model": "JWGp",
        "./operations/custom_op/register": "gQtl",
        "./version": "SdA6"
    }],
    "dGni": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.load = L, exports.HandPose = void 0;
        var t = require("@tensorflow/tfjs-converter"),
            n = require("@tensorflow/tfjs-core");

        function e(t, n, e, r) {
            return new(e || (e = Promise))(function(i, o) {
                function s(t) {
                    try {
                        u(r.next(t))
                    } catch (t) {
                        o(t)
                    }
                }

                function a(t) {
                    try {
                        u(r.throw(t))
                    } catch (t) {
                        o(t)
                    }
                }

                function u(t) {
                    var n;
                    t.done ? i(t.value) : (n = t.value, n instanceof e ? n : new e(function(t) {
                        t(n)
                    })).then(s, a)
                }
                u((r = r.apply(t, n || [])).next())
            })
        }

        function r(t, n) {
            var e, r, i, o, s = {
                label: 0,
                sent: function() {
                    if (1 & i[0]) throw i[1];
                    return i[1]
                },
                trys: [],
                ops: []
            };
            return o = {
                next: a(0),
                throw: a(1),
                return: a(2)
            }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                return this
            }), o;

            function a(o) {
                return function(a) {
                    return function(o) {
                        if (e) throw new TypeError("Generator is already executing.");
                        for (; s;) try {
                            if (e = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                            switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                case 0:
                                case 1:
                                    i = o;
                                    break;
                                case 4:
                                    return s.label++, {
                                        value: o[1],
                                        done: !1
                                    };
                                case 5:
                                    s.label++, r = o[1], o = [0];
                                    continue;
                                case 7:
                                    o = s.ops.pop(), s.trys.pop();
                                    continue;
                                default:
                                    if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                        s = 0;
                                        continue
                                    }
                                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                        s.label = o[1];
                                        break
                                    }
                                    if (6 === o[0] && s.label < i[1]) {
                                        s.label = i[1], i = o;
                                        break
                                    }
                                    if (i && s.label < i[2]) {
                                        s.label = i[2], s.ops.push(o);
                                        break
                                    }
                                    i[2] && s.ops.pop(), s.trys.pop();
                                    continue
                            }
                            o = n.call(t, s)
                        } catch (t) {
                            o = [6, t], r = 0
                        } finally {
                            e = i = 0
                        }
                        if (5 & o[0]) throw o[1];
                        return {
                            value: o[0] ? o[1] : void 0,
                            done: !0
                        }
                    }([o, a])
                }
            }
        }

        function i(t) {
            return [Math.abs(t.endPoint[0] - t.startPoint[0]), Math.abs(t.endPoint[1] - t.startPoint[1])]
        }

        function o(t) {
            return [t.startPoint[0] + (t.endPoint[0] - t.startPoint[0]) / 2, t.startPoint[1] + (t.endPoint[1] - t.startPoint[1]) / 2]
        }

        function s(t, n) {
            void 0 === n && (n = 1.5);
            var e = o(t),
                r = i(t),
                s = [n * r[0] / 2, n * r[1] / 2];
            return {
                startPoint: [e[0] - s[0], e[1] - s[1]],
                endPoint: [e[0] + s[0], e[1] + s[1]],
                palmLandmarks: t.palmLandmarks
            }
        }

        function a(t) {
            var n = o(t),
                e = i(t),
                r = Math.max.apply(Math, e) / 2;
            return {
                startPoint: [n[0] - r, n[1] - r],
                endPoint: [n[0] + r, n[1] + r],
                palmLandmarks: t.palmLandmarks
            }
        }

        function u(t, n) {
            var e = [t.endPoint[0] - t.startPoint[0], t.endPoint[1] - t.startPoint[1]],
                r = [e[0] * n[0], e[1] * n[1]];
            return {
                startPoint: [t.startPoint[0] + r[0], t.startPoint[1] + r[1]],
                endPoint: [t.endPoint[0] + r[0], t.endPoint[1] + r[1]],
                palmLandmarks: t.palmLandmarks
            }
        }
        var d = function() {
                function t(t, e, r, i, o, s) {
                    this.model = t, this.width = e, this.height = r, this.iouThreshold = o, this.scoreThreshold = s, this.anchors = i.map(function(t) {
                        return [t.x_center, t.y_center]
                    }), this.anchorsTensor = (0, n.tensor2d)(this.anchors), this.inputSizeTensor = (0, n.tensor1d)([e, r]), this.doubleInputSizeTensor = (0, n.tensor1d)([2 * e, 2 * r])
                }
                return t.prototype.normalizeBoxes = function(t) {
                    var e = this;
                    return (0, n.tidy)(function() {
                        var r = (0, n.slice)(t, [0, 0], [-1, 2]),
                            i = (0, n.slice)(t, [0, 2], [-1, 2]),
                            o = (0, n.add)((0, n.div)(r, e.inputSizeTensor), e.anchorsTensor),
                            s = (0, n.div)(i, e.doubleInputSizeTensor),
                            a = (0, n.mul)((0, n.sub)(o, s), e.inputSizeTensor),
                            u = (0, n.mul)((0, n.add)(o, s), e.inputSizeTensor);
                        return (0, n.concat2d)([a, u], 1)
                    })
                }, t.prototype.normalizeLandmarks = function(t, e) {
                    var r = this;
                    return (0, n.tidy)(function() {
                        var i = (0, n.add)((0, n.div)(t.reshape([-1, 7, 2]), r.inputSizeTensor), r.anchors[e]);
                        return (0, n.mul)(i, r.inputSizeTensor)
                    })
                }, t.prototype.getBoundingBoxes = function(t) {
                    return e(this, void 0, void 0, function() {
                        var e, i, o, s, a, u, d, h, c, l, f, p, m, v, P, g = this;
                        return r(this, function(r) {
                            switch (r.label) {
                                case 0:
                                    return e = (0, n.tidy)(function() {
                                        return (0, n.mul)((0, n.sub)(t, .5), 2)
                                    }), "webgl" === (0, n.getBackend)() ? (o = (0, n.env)().get("WEBGL_PACK_DEPTHWISECONV"), (0, n.env)().set("WEBGL_PACK_DEPTHWISECONV", !0), i = this.model.predict(e), (0, n.env)().set("WEBGL_PACK_DEPTHWISECONV", o)) : i = this.model.predict(e), s = i.squeeze(), a = (0, n.tidy)(function() {
                                        return (0, n.sigmoid)((0, n.slice)(s, [0, 0], [-1, 1])).squeeze()
                                    }), u = (0, n.slice)(s, [0, 1], [-1, 4]), d = this.normalizeBoxes(u), h = console.warn, console.warn = function() {}, c = n.image.nonMaxSuppression(d, a, 1, this.iouThreshold, this.scoreThreshold), console.warn = h, [4, c.array()];
                                case 1:
                                    return l = r.sent(), f = [e, i, c, s, d, u, a], 0 === l.length ? (f.forEach(function(t) {
                                        return t.dispose()
                                    }), [2, null]) : (p = l[0], m = (0, n.slice)(d, [p, 0], [1, -1]), v = (0, n.slice)(s, [p, 5], [1, 14]), P = (0, n.tidy)(function() {
                                        return g.normalizeLandmarks(v, p).reshape([-1, 2])
                                    }), f.push(v), f.forEach(function(t) {
                                        return t.dispose()
                                    }), [2, {
                                        boxes: m,
                                        palmLandmarks: P
                                    }])
                            }
                        })
                    })
                }, t.prototype.estimateHandBounds = function(t) {
                    return e(this, void 0, void 0, function() {
                        var e, i, o, s, a, u, d, h, c = this;
                        return r(this, function(r) {
                            switch (r.label) {
                                case 0:
                                    return e = t.shape[1], i = t.shape[2], o = (0, n.tidy)(function() {
                                        return t.resizeBilinear([c.width, c.height]).div(255)
                                    }), [4, this.getBoundingBoxes(o)];
                                case 1:
                                    return null === (s = r.sent()) ? (o.dispose(), [2, null]) : (a = s.boxes.arraySync(), u = a[0].slice(0, 2), d = a[0].slice(2, 4), h = s.palmLandmarks.arraySync(), o.dispose(), s.boxes.dispose(), s.palmLandmarks.dispose(), [2, (l = {
                                        startPoint: u,
                                        endPoint: d,
                                        palmLandmarks: h
                                    }, f = [i / this.width, e / this.height], {
                                        startPoint: [l.startPoint[0] * f[0], l.startPoint[1] * f[1]],
                                        endPoint: [l.endPoint[0] * f[0], l.endPoint[1] * f[1]],
                                        palmLandmarks: l.palmLandmarks.map(function(t) {
                                            return [t[0] * f[0], t[1] * f[1]]
                                        })
                                    })])
                            }
                            var l, f
                        })
                    })
                }, t
            }(),
            h = {
                thumb: [1, 2, 3, 4],
                indexFinger: [5, 6, 7, 8],
                middleFinger: [9, 10, 11, 12],
                ringFinger: [13, 14, 15, 16],
                pinky: [17, 18, 19, 20],
                palmBase: [0]
            };

        function c(t, n) {
            var e;
            return (e = Math.PI / 2 - Math.atan2(-(n[1] - t[1]), n[0] - t[0])) - 2 * Math.PI * Math.floor((e + Math.PI) / (2 * Math.PI))
        }
        var l = function(t, n) {
            return [
                [1, 0, t],
                [0, 1, n],
                [0, 0, 1]
            ]
        };

        function f(t, n) {
            for (var e = 0, r = 0; r < t.length; r++) e += t[r] * n[r];
            return e
        }

        function p(t, n) {
            for (var e = [], r = 0; r < t.length; r++) e.push(t[r][n]);
            return e
        }

        function m(t, n) {
            for (var e = [], r = t.length, i = 0; i < r; i++) {
                e.push([]);
                for (var o = 0; o < r; o++) e[i].push(f(t[i], p(n, o)))
            }
            return e
        }

        function v(t, n) {
            var e = Math.cos(t),
                r = Math.sin(t),
                i = [
                    [e, -r, 0],
                    [r, e, 0],
                    [0, 0, 1]
                ],
                o = m(l(n[0], n[1]), i);
            return m(o, l(-n[0], -n[1]))
        }

        function P(t, n) {
            return [f(t, n[0]), f(t, n[1])]
        }
        var g = [0, -.4],
            b = [0, -.1],
            y = [0, 5, 9, 13, 17, 1, 2],
            x = function() {
                function t(t, n, e, r, i, o) {
                    this.regionsOfInterest = [], this.runsWithoutHandDetector = 0, this.boundingBoxDetector = t, this.meshDetector = n, this.maxContinuousChecks = i, this.detectionConfidence = o, this.meshWidth = e, this.meshHeight = r, this.maxHandsNumber = 1
                }
                return t.prototype.getBoxForPalmLandmarks = function(t, n) {
                    var e = t.map(function(t) {
                        return P(t.concat([1]), n)
                    });
                    return s(a(u(this.calculateLandmarksBoundingBox(e), g)), 3)
                }, t.prototype.getBoxForHandLandmarks = function(t) {
                    for (var n = s(a(u(this.calculateLandmarksBoundingBox(t), b)), 1.65), e = [], r = 0; r < y.length; r++) e.push(t[y[r]].slice(0, 2));
                    return n.palmLandmarks = e, n
                }, t.prototype.transformRawCoords = function(t, n, e, r) {
                    var s, a, u, d, h = this,
                        c = i(n),
                        l = [c[0] / this.meshWidth, c[1] / this.meshHeight],
                        p = t.map(function(t) {
                            return [l[0] * (t[0] - h.meshWidth / 2), l[1] * (t[1] - h.meshHeight / 2), t[2]]
                        }),
                        m = v(e, [0, 0]),
                        g = p.map(function(t) {
                            return P(t, m).concat([t[2]])
                        }),
                        b = (a = [
                            [(s = r)[0][0], s[1][0]],
                            [s[0][1], s[1][1]]
                        ], u = [s[0][2], s[1][2]], d = [-f(a[0], u), -f(a[1], u)], [a[0].concat(d[0]), a[1].concat(d[1]), [0, 0, 1]]),
                        y = o(n).concat([1]),
                        x = [f(y, b[0]), f(y, b[1])];
                    return g.map(function(t) {
                        return [t[0] + x[0], t[1] + x[1], t[2]]
                    })
                }, t.prototype.estimateHand = function(t) {
                    return e(this, void 0, void 0, function() {
                        var e, i, s, a, u, d, h, l, f, p, m, P, g, b, y, x, k, w, B, L;
                        return r(this, function(r) {
                            switch (r.label) {
                                case 0:
                                    return !0 !== (e = this.shouldUpdateRegionsOfInterest()) ? [3, 2] : [4, this.boundingBoxDetector.estimateHandBounds(t)];
                                case 1:
                                    return null === (i = r.sent()) ? (t.dispose(), this.regionsOfInterest = [], [2, null]) : (this.updateRegionsOfInterest(i, !0), this.runsWithoutHandDetector = 0, [3, 3]);
                                case 2:
                                    this.runsWithoutHandDetector++, r.label = 3;
                                case 3:
                                    return s = this.regionsOfInterest[0], a = c(s.palmLandmarks[0], s.palmLandmarks[2]), u = o(s), d = [u[0] / t.shape[2], u[1] / t.shape[1]], h = n.image.rotateWithOffset(t, a, 0, d), l = v(-a, u), f = !0 === e ? this.getBoxForPalmLandmarks(s.palmLandmarks, l) : s, p = function(t, e, r) {
                                        var i = e.shape[1],
                                            o = e.shape[2],
                                            s = [
                                                [t.startPoint[1] / i, t.startPoint[0] / o, t.endPoint[1] / i, t.endPoint[0] / o]
                                            ];
                                        return n.image.cropAndResize(e, s, [0], r)
                                    }(f, h, [this.meshWidth, this.meshHeight]), m = p.div(255), p.dispose(), h.dispose(), "webgl" === (0, n.getBackend)() ? (g = (0, n.env)().get("WEBGL_PACK_DEPTHWISECONV"), (0, n.env)().set("WEBGL_PACK_DEPTHWISECONV", !0), P = this.meshDetector.predict(m), (0, n.env)().set("WEBGL_PACK_DEPTHWISECONV", g)) : P = this.meshDetector.predict(m), b = P[0], y = P[1], m.dispose(), x = b.dataSync()[0], b.dispose(), x < this.detectionConfidence ? (y.dispose(), this.regionsOfInterest = [], [2, null]) : (k = (0, n.reshape)(y, [-1, 3]), w = k.arraySync(), y.dispose(), k.dispose(), B = this.transformRawCoords(w, f, a, l), L = this.getBoxForHandLandmarks(B), this.updateRegionsOfInterest(L, !1), [2, {
                                        landmarks: B,
                                        handInViewConfidence: x,
                                        boundingBox: {
                                            topLeft: L.startPoint,
                                            bottomRight: L.endPoint
                                        }
                                    }])
                            }
                        })
                    })
                }, t.prototype.calculateLandmarksBoundingBox = function(t) {
                    var n = t.map(function(t) {
                            return t[0]
                        }),
                        e = t.map(function(t) {
                            return t[1]
                        });
                    return {
                        startPoint: [Math.min.apply(Math, n), Math.min.apply(Math, e)],
                        endPoint: [Math.max.apply(Math, n), Math.max.apply(Math, e)]
                    }
                }, t.prototype.updateRegionsOfInterest = function(t, n) {
                    if (n) this.regionsOfInterest = [t];
                    else {
                        var e = this.regionsOfInterest[0],
                            r = 0;
                        if (null != e && null != e.startPoint) {
                            var i = t.startPoint,
                                o = i[0],
                                s = i[1],
                                a = t.endPoint,
                                u = a[0],
                                d = a[1],
                                h = e.startPoint,
                                c = h[0],
                                l = h[1],
                                f = e.endPoint,
                                p = f[0],
                                m = f[1],
                                v = Math.max(o, c),
                                P = Math.max(s, l),
                                g = (Math.min(u, p) - v) * (Math.min(d, m) - P);
                            r = g / ((u - o) * (d - s) + (p - c) * (m - s) - g)
                        }
                        this.regionsOfInterest[0] = r > .8 ? e : t
                    }
                }, t.prototype.shouldUpdateRegionsOfInterest = function() {
                    return this.regionsOfInterest.length !== this.maxHandsNumber || this.runsWithoutHandDetector >= this.maxContinuousChecks
                }, t
            }();

        function k() {
            return e(this, void 0, void 0, function() {
                return r(this, function(n) {
                    return [2, (0, t.loadGraphModel)("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1", {
                        fromTFHub: !0
                    })]
                })
            })
        }

        function w() {
            return e(this, void 0, void 0, function() {
                return r(this, function(n) {
                    return [2, (0, t.loadGraphModel)("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1", {
                        fromTFHub: !0
                    })]
                })
            })
        }

        function B() {
            return e(this, void 0, void 0, function() {
                return r(this, function(t) {
                    return [2, n.util.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then(function(t) {
                        return t.json()
                    })]
                })
            })
        }

        function L(t) {
            var n = void 0 === t ? {} : t,
                i = n.maxContinuousChecks,
                o = void 0 === i ? 1 / 0 : i,
                s = n.detectionConfidence,
                a = void 0 === s ? .8 : s,
                u = n.iouThreshold,
                h = void 0 === u ? .3 : u,
                c = n.scoreThreshold,
                l = void 0 === c ? .5 : c;
            return e(this, void 0, void 0, function() {
                var t, n, e, i, s, u;
                return r(this, function(r) {
                    switch (r.label) {
                        case 0:
                            return [4, Promise.all([B(), k(), w()])];
                        case 1:
                            return t = r.sent(), n = t[0], e = t[1], i = t[2], s = new d(e, 256, 256, n, h, l), u = new x(s, i, 256, 256, o, a), [2, new I(u)]
                    }
                })
            })
        }
        var I = function() {
            function t(t) {
                this.pipeline = t
            }
            return t.getAnnotations = function() {
                return h
            }, t.prototype.estimateHands = function(t, i) {
                return void 0 === i && (i = !1), e(this, void 0, void 0, function() {
                    var e, o, s, a, u, d, c, l, f;
                    return r(this, function(r) {
                        switch (r.label) {
                            case 0:
                                return e = function(t) {
                                    return t instanceof n.Tensor ? [t.shape[0], t.shape[1]] : [t.height, t.width]
                                }(t), o = e[1], s = (0, n.tidy)(function() {
                                    return t instanceof n.Tensor || (t = n.browser.fromPixels(t)), t.toFloat().expandDims(0)
                                }), [4, this.pipeline.estimateHand(s)];
                            case 1:
                                if (a = r.sent(), s.dispose(), null === a) return [2, []];
                                for (u = a, !0 === i && (u = function(t, n) {
                                        var e = t.handInViewConfidence,
                                            r = t.landmarks,
                                            i = t.boundingBox;
                                        return {
                                            handInViewConfidence: e,
                                            landmarks: r.map(function(t) {
                                                return [n - 1 - t[0], t[1], t[2]]
                                            }),
                                            boundingBox: {
                                                topLeft: [n - 1 - i.topLeft[0], i.topLeft[1]],
                                                bottomRight: [n - 1 - i.bottomRight[0], i.bottomRight[1]]
                                            }
                                        }
                                    }(a, o)), d = {}, c = 0, l = Object.keys(h); c < l.length; c++) f = l[c], d[f] = h[f].map(function(t) {
                                    return u.landmarks[t]
                                });
                                return [2, [{
                                    handInViewConfidence: u.handInViewConfidence,
                                    boundingBox: u.boundingBox,
                                    landmarks: u.landmarks,
                                    annotations: d
                                }]]
                        }
                    })
                })
            }, t
        }();
        exports.HandPose = I;
    }, {
        "@tensorflow/tfjs-converter": "OiNd",
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "M1oU": [function(require, module, exports) {
        var __filename = "/Users/annyuan/Documents/projects/tfjs-core-wrapper/tfjs-models/handpose/demo/node_modules/@tensorflow/tfjs-backend-wasm/dist/tf-backend-wasm.esm.js";
        var process = require("process");
        var __dirname = "/Users/annyuan/Documents/projects/tfjs-core-wrapper/tfjs-models/handpose/demo/node_modules/@tensorflow/tfjs-backend-wasm/dist";
        var e = "/Users/annyuan/Documents/projects/tfjs-core-wrapper/tfjs-models/handpose/demo/node_modules/@tensorflow/tfjs-backend-wasm/dist/tf-backend-wasm.esm.js",
            n = require("process"),
            t = "/Users/annyuan/Documents/projects/tfjs-core-wrapper/tfjs-models/handpose/demo/node_modules/@tensorflow/tfjs-backend-wasm/dist";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.setWasmPath = ke, exports.version_wasm = exports.BackendWasm = void 0;
        var a, r, u = require("@tensorflow/tfjs-core"),
            i = o(require("path")),
            s = o(require("fs"));

        function o(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        let l;
        ! function(e) {
            e[e.float32 = 0] = "float32", e[e.int32 = 1] = "int32", e[e.bool = 2] = "bool", e[e.string = 3] = "string", e[e.complex64 = 4] = "complex64"
        }(a || (a = {})),
        function(e) {
            e[e.linear = 0] = "linear", e[e.relu = 1] = "relu", e[e.relu6 = 2] = "relu6", e[e.prelu = 3] = "prelu"
        }(r || (r = {}));
        const p = {
            kernelName: u._FusedMatMul,
            backendName: "wasm",
            setupFunc: function(e) {
                l = e.wasm.cwrap(u._FusedMatMul, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    a: u,
                    b: i,
                    bias: s,
                    preluActivationWeights: o
                } = n;
                if ("float32" !== u.dtype || "float32" !== i.dtype) throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
                const {
                    transposeA: p,
                    transposeB: d,
                    activation: c
                } = a, m = t.dataIdMap.get(u.dataId).id, f = t.dataIdMap.get(i.dataId).id;
                let b = 0;
                if (null != s) {
                    const e = t.dataIdMap.get(s.dataId);
                    if (1 !== e.shape.length) throw new Error("_FusedMatMul only supports rank-1 bias but got " + `rank ${e.shape.length}.`);
                    b = e.id
                }
                const h = null == o ? 0 : t.dataIdMap.get(o.dataId).id,
                    y = r[c];
                if (null == y) throw new Error(`${c} activation not yet supported for FusedConv2D ` + "in the wasm backend.");
                const g = p ? u.shape[2] : u.shape[1],
                    w = d ? i.shape[1] : i.shape[2],
                    _ = u.shape[0],
                    I = t.makeOutput([_, g, w], u.dtype),
                    k = t.dataIdMap.get(I.dataId).id,
                    v = new Uint8Array(new Int32Array(u.shape).buffer),
                    M = new Uint8Array(new Int32Array(i.shape).buffer);
                return l(m, v, u.shape.length, f, M, i.shape.length, p, d, y, b, h, k), I
            }
        };

        function d(e) {
            let n;
            return {
                kernelName: e,
                backendName: "wasm",
                setupFunc: function(t) {
                    n = t.wasm.cwrap(e, null, ["number", "number"])
                },
                kernelFunc: function(e) {
                    const {
                        backend: t,
                        inputs: {
                            x: a
                        }
                    } = e, r = t.dataIdMap.get(a.dataId).id, i = t.makeOutput(a.shape, a.dtype), s = t.dataIdMap.get(i.dataId).id;
                    return 0 === u.util.sizeFromShape(i.shape) ? i : (n(r, s), i)
                }
            }
        }
        const c = d(u.Abs);

        function m(e, n, t) {
            let r;
            return {
                kernelName: e,
                backendName: "wasm",
                setupFunc: function(n) {
                    r = n.wasm.cwrap(e, null, ["number", "array", "number", "number", "array", "number", "number", "number"])
                },
                kernelFunc: function(i) {
                    const {
                        backend: s,
                        inputs: o
                    } = i, {
                        a: l,
                        b: p
                    } = o, d = s.dataIdMap.get(l.dataId).id, c = s.dataIdMap.get(p.dataId).id, m = null != t ? t : l.dtype, f = u.backend_util.assertAndGetBroadcastShape(l.shape, p.shape), b = s.makeOutput(f, m);
                    if (0 === u.util.sizeFromShape(f)) return b;
                    const h = new Uint8Array(new Int32Array(l.shape).buffer),
                        y = new Uint8Array(new Int32Array(p.shape).buffer),
                        g = s.dataIdMap.get(b.dataId).id,
                        w = () => r(d, h, l.shape.length, c, y, p.shape.length, a[l.dtype], g);
                    if (n && "float32" === l.dtype) return w(), b;
                    const _ = u.backend_util.getBroadcastDims(l.shape, f),
                        I = u.backend_util.getBroadcastDims(p.shape, f),
                        k = _.every((e, n) => e === n),
                        v = I.every((e, n) => e === n);
                    if (k && v) return w(), b;
                    throw new Error("Broadcasting along outer dims is not yet " + `supported for ${l.dtype} ${e}.`)
                }
            }
        }
        const f = m(u.Add, !0);
        let b;
        const h = {
            kernelName: u.AddN,
            backendName: "wasm",
            setupFunc: function(e) {
                b = e.wasm.cwrap(u.AddN, null, ["array", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t
                } = e, r = t.makeOutput(n[0].shape, n[0].dtype);
                if (0 === u.util.sizeFromShape(r.shape)) return r;
                const i = n.map(e => t.dataIdMap.get(e.dataId).id),
                    s = new Uint8Array(new Int32Array(i).buffer),
                    o = t.dataIdMap.get(r.dataId).id;
                return b(s, i.length, a[r.dtype], o), r
            }
        };

        function y(e) {
            const {
                inputs: {
                    x: n
                },
                backend: t
            } = e, a = t.makeOutput(n.shape, n.dtype), r = t.typedArrayFromHeap(n);
            return t.typedArrayFromHeap(a).set(r), a
        }
        const g = {
            kernelName: u.Identity,
            backendName: "wasm",
            kernelFunc: y
        };
        let w;

        function _(e) {
            const {
                inputs: n,
                backend: t,
                attrs: r
            } = e, [u, i] = function(e, n) {
                const t = [],
                    a = [];
                for (let r = 0; r < e.length; ++r) 1 !== e[r] && t.push(e[r]), 1 !== e[n[r]] && a.push(n[r]);
                for (let r = 0; r < a.length; ++r) {
                    let e = -1;
                    for (let n = 0; n < a.length; ++n) a[n] >= r && (-1 === e || a[e] > a[n]) && (e = n);
                    a[e] = r
                }
                return [t, a]
            }(n.x.shape, r.perm);
            let s = !0;
            for (let a = 0; a < i.length; a++) i[a] !== a && (s = !1);
            const o = function(e, n) {
                    const t = new Array(e.length);
                    for (let a = 0; a < t.length; a++) t[a] = e[n[a]];
                    return t
                }(n.x.shape, r.perm),
                l = {
                    dataId: n.x.dataId,
                    shape: u,
                    dtype: n.x.dtype
                };
            if (s) {
                const e = y({
                    inputs: n,
                    backend: t
                });
                return e.shape = o, e
            }
            const p = t.makeOutput(o, l.dtype),
                d = t.dataIdMap.get(l.dataId).id,
                c = t.dataIdMap.get(p.dataId).id,
                m = new Uint8Array(new Int32Array(i).buffer),
                f = new Uint8Array(new Int32Array(l.shape).buffer);
            return w(d, f, l.shape.length, a[l.dtype], c, m, i.length), p
        }
        const I = {
            kernelName: u.Transpose,
            backendName: "wasm",
            kernelFunc: _,
            setupFunc: function(e) {
                w = e.wasm.cwrap(u.Transpose, null, ["number", "array", "number", "number", "number", "array", "number"])
            }
        };

        function k(e, n, t) {
            const a = e.shape,
                r = e.shape.length,
                i = u.util.parseAxisParam(n, a);
            let s = i;
            const o = u.backend_util.getAxesPermutation(s, r);
            let l = null,
                p = !1;
            if (null != o) {
                const n = new Array(r);
                for (let e = 0; e < n.length; e++) n[e] = a[o[e]];
                s = u.backend_util.getInnerMostAxes(s.length, r), l = _({
                    inputs: {
                        x: e
                    },
                    attrs: {
                        perm: o
                    },
                    backend: t
                });
                const i = t.dataIdMap.get(e.dataId).id;
                t.dataIdMap.get(l.dataId).id !== i && (p = !0)
            }
            return {
                transposed: l,
                originalAxes: i,
                axes: s,
                inputWasTransposed: p
            }
        }
        let v;
        const M = {
            kernelName: u.ArgMax,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: r
                } = e, {
                    axis: i
                } = r, {
                    x: s
                } = t, o = n.dataIdMap.get(s.dataId).id;
                let l = o,
                    p = s;
                const {
                    transposed: d,
                    axes: c,
                    inputWasTransposed: m
                } = k(s, i, n);
                if (m) {
                    const e = n.dataIdMap.get(d.dataId).id;
                    e !== o && (p = d, l = e)
                }
                const f = p.shape.slice(0, -1),
                    b = n.makeOutput(f, "int32"),
                    h = n.dataIdMap.get(b.dataId).id,
                    y = u.util.sizeFromShape(b.shape),
                    g = p.shape[c[0]];
                return v(l, a[p.dtype], y, g, h), m && n.disposeData(d.dataId), b
            },
            setupFunc: function(e) {
                v = e.wasm.cwrap(u.ArgMax, null, ["number", "number", "number", "number", "number"])
            }
        };
        let A;
        const S = {
            kernelName: u.AvgPool,
            backendName: "wasm",
            setupFunc: function(e) {
                A = e.wasm.cwrap(u.AvgPool, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, r = n.x, i = a.dataIdMap.get(r.dataId).id, {
                    filterSize: s,
                    strides: o,
                    pad: l,
                    dimRoundingMode: p
                } = t, d = u.backend_util.computePool2DInfo(r.shape, s, o, 1, l, p), c = d.filterHeight, m = d.filterWidth, f = d.padInfo.top, b = d.padInfo.right, h = d.padInfo.bottom, y = d.padInfo.left, g = d.strideHeight, w = d.strideWidth, _ = d.inChannels;
                if ("channelsLast" !== d.dataFormat) throw new Error("wasm backend does not support dataFormat:'" + `${d.dataFormat}'. Please use 'channelsLast'.`);
                if (1 !== d.dilationWidth || 1 !== d.dilationHeight) throw new Error("was backend only supports average pooling with dilation = [1, 1], " + `got [${d.dilationHeight}, ${d.dilationWidth}].`);
                const I = a.makeOutput(d.outShape, "float32"),
                    k = a.dataIdMap.get(I.dataId).id;
                return A(i, r.shape[0], r.shape[1], r.shape[2], c, m, f, b, h, y, g, w, _, k), I
            }
        };
        let F;
        const x = {
            kernelName: u.BatchMatMul,
            backendName: "wasm",
            setupFunc: function(e) {
                F = e.wasm.cwrap(u.BatchMatMul, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    a: r,
                    b: u
                } = n;
                if ("float32" !== r.dtype || "float32" !== u.dtype) throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
                const {
                    transposeA: i,
                    transposeB: s
                } = a, o = t.dataIdMap.get(r.dataId).id, l = t.dataIdMap.get(u.dataId).id, p = i ? r.shape[2] : r.shape[1], d = s ? u.shape[1] : u.shape[2], c = r.shape[0], m = t.makeOutput([c, p, d], r.dtype), f = t.dataIdMap.get(m.dataId).id, b = new Uint8Array(new Int32Array(r.shape).buffer), h = new Uint8Array(new Int32Array(u.shape).buffer);
                return F(o, b, r.shape.length, l, h, u.shape.length, i, s, f), m
            }
        };

        function N(e) {
            const {
                inputs: {
                    x: n
                },
                attrs: {
                    dtype: t
                },
                backend: a
            } = e, r = a.makeOutput(n.shape, t), u = a.typedArrayFromHeap(n);
            return a.typedArrayFromHeap(r).set(u), r
        }
        const C = {
            kernelName: u.Cast,
            backendName: "wasm",
            kernelFunc: N
        };
        let R;
        const D = {
                kernelName: u.ClipByValue,
                backendName: "wasm",
                setupFunc: function(e) {
                    R = e.wasm.cwrap(u.ClipByValue, null, ["number", "number", "number", "number"])
                },
                kernelFunc: function(e) {
                    const {
                        inputs: n,
                        backend: t,
                        attrs: a
                    } = e, {
                        x: r
                    } = n, {
                        clipValueMin: u,
                        clipValueMax: i
                    } = a, s = t.dataIdMap.get(r.dataId).id, o = t.makeOutput(r.shape, "float32"), l = t.dataIdMap.get(o.dataId).id;
                    return R(s, u, i, l), o
                }
            },
            E = {
                kernelName: u.Concat,
                backendName: "wasm",
                kernelFunc: function(e) {
                    const {
                        inputs: n,
                        backend: t
                    } = e, a = u.util.parseAxisParam(e.attrs.axis, n[0].shape)[0], r = u.backend_util.computeOutShape(n.map(e => e.shape), a), i = t.makeOutput(r, n[0].dtype), s = u.util.sizeFromShape(n[0].shape.slice(0, a));
                    let o = 0;
                    const l = n.map(e => {
                            const n = u.util.sizeFromShape(e.shape.slice(a));
                            return o += n, n
                        }),
                        p = n.map(e => t.typedArrayFromHeap(e)),
                        d = t.typedArrayFromHeap(i);
                    for (let u = 0; u < s; u++) {
                        let e = u * o;
                        for (let n = 0; n < p.length; n++) {
                            const t = l[n],
                                a = u * t,
                                r = p[n].subarray(a, a + t);
                            d.set(r, e), e += t
                        }
                    }
                    return i
                }
            };
        let O;
        const P = {
            kernelName: u.Conv2D,
            backendName: "wasm",
            setupFunc: function(e) {
                O = e.wasm.cwrap(u.Conv2D, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, {
                    x: r,
                    filter: i
                } = n, s = a.dataIdMap.get(r.dataId).id, o = a.dataIdMap.get(i.dataId).id, {
                    strides: l,
                    dilations: p,
                    pad: d,
                    dimRoundingMode: c,
                    dataFormat: m
                } = t, f = u.backend_util.convertConv2DDataFormat(m), b = u.backend_util.computeConv2DInfo(r.shape, i.shape, l, p, d, c, !1, f), h = b.filterHeight, y = b.filterWidth, g = b.padInfo.top, w = b.padInfo.right, _ = b.padInfo.bottom, I = b.padInfo.left, k = b.dilationHeight, v = b.dilationWidth, M = b.strideHeight, A = b.strideWidth, S = b.inChannels, F = b.outChannels, x = "SAME" === b.padInfo.type ? 1 : 0;
                if ("channelsLast" !== b.dataFormat) throw new Error("wasm backend Conv2D does not support dataFormat:'" + `${b.dataFormat}'. Please use 'channelsLast'.`);
                const N = a.makeOutput(b.outShape, "float32"),
                    C = a.dataIdMap.get(N.dataId).id;
                return O(s, r.shape[0], r.shape[1], r.shape[2], o, h, y, g, w, _, I, x, k, v, M, A, S, F, C), N
            }
        };
        let W;
        const z = {
                kernelName: u.Conv2DBackpropInput,
                backendName: "wasm",
                setupFunc: function(e) {
                    W = e.wasm.cwrap(u.Conv2DBackpropInput, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
                },
                kernelFunc: function(e) {
                    const {
                        backend: n,
                        inputs: t,
                        attrs: a
                    } = e, {
                        dy: r,
                        filter: i
                    } = t, {
                        strides: s,
                        pad: o,
                        dataFormat: l,
                        dimRoundingMode: p,
                        inputShape: d
                    } = a, c = u.backend_util.convertConv2DDataFormat(l), m = u.backend_util.computeConv2DInfo(d, i.shape, s, 1, o, p, !1, c), {
                        batchSize: f,
                        filterHeight: b,
                        filterWidth: h,
                        inChannels: y,
                        inHeight: g,
                        inWidth: w,
                        outChannels: _,
                        outHeight: I,
                        outWidth: k,
                        strideHeight: v,
                        strideWidth: M
                    } = m, A = b - 1 - m.padInfo.top, S = h - 1 - m.padInfo.left, F = "channelsLast" === m.dataFormat, x = u.util.computeStrides(m.inShape), N = u.util.computeStrides(r.shape), [C, R, D] = u.util.computeStrides(i.shape), E = x[0], O = F ? x[1] : x[2], P = F ? x[2] : 1, z = F ? 1 : x[1], H = N[0], T = F ? N[1] : N[2], U = F ? N[2] : 1, B = F ? 1 : N[1], V = n.makeOutput(m.inShape, "float32"), q = n.dataIdMap.get(V.dataId).id, L = n.dataIdMap.get(r.dataId).id, j = n.dataIdMap.get(i.dataId).id;
                    return W(L, j, f, b, h, g, w, y, I, k, _, v, M, A, S, C, R, D, E, O, P, z, H, T, U, B, q), V
                }
            },
            H = d(u.Cos);
        var T;
        let U, B, V, q, L, j, G, $, K, X, Y, Z, J, Q, ee, ne, te, ae, re, ue, ie, se, oe, le, pe;

        function de(e, n) {
            const t = new Int32Array(e.wasm.HEAPU8.buffer, n, 4),
                a = t[0],
                r = t[1],
                u = t[2],
                i = t[3];
            return e.wasm._free(n), {
                pSelectedIndices: a,
                selectedSize: r,
                pSelectedScores: u,
                pValidOutputs: i
            }
        }

        function ce(e) {
            const {
                inputs: n,
                attrs: t
            } = e, {
                x: a
            } = n, {
                shape: r
            } = t;
            return {
                dataId: a.dataId,
                shape: r,
                dtype: a.dtype
            }
        }

        function me(e) {
            const {
                inputs: {
                    x: n
                },
                attrs: {
                    begin: t,
                    size: a
                },
                backend: r
            } = e, [i, s] = u.slice_util.parseSliceParams(n, t, a), o = u.slice_util.isSliceContinous(n.shape, i, s), l = r.typedArrayFromHeap(n), p = r.makeOutput(s, n.dtype), d = r.typedArrayFromHeap(p), c = u.util.computeStrides(n.shape);
            if (o) {
                const e = u.slice_util.computeFlatOffset(i, c);
                return d.set(l.subarray(e, e + u.util.sizeFromShape(s))), p
            }
            const m = n.shape.length;
            return 2 === m ? function(e, n, t, a, r) {
                let u = 0;
                const i = a[0],
                    s = a[1],
                    o = i + r[0];
                for (let l = i; l < o; l++) {
                    const a = l * n + s;
                    t.set(e.subarray(a, a + r[1]), u), u += r[1]
                }
            }(l, c[0], d, i, s) : 3 === m ? function(e, n, t, a, r, u) {
                let i = 0;
                const s = r[0],
                    o = r[1],
                    l = r[2],
                    p = s + u[0],
                    d = o + u[1];
                for (let c = s; c < p; c++)
                    for (let r = o; r < d; r++) {
                        const s = c * n + r * t + l;
                        a.set(e.subarray(s, s + u[2]), i), i += u[2]
                    }
            }(l, c[0], c[1], d, i, s) : 4 === m ? function(e, n, t, a, r, u, i) {
                let s = 0;
                const o = u[0],
                    l = u[1],
                    p = u[2],
                    d = o + i[0],
                    c = l + i[1],
                    m = p + i[2],
                    f = u[3];
                for (let b = o; b < d; b++)
                    for (let u = l; u < c; u++)
                        for (let o = p; o < m; o++) {
                            const l = b * n + u * t + o * a + f;
                            r.set(e.subarray(l, l + i[3]), s), s += i[3]
                        }
            }(l, c[0], c[1], c[2], d, i, s) : function(e, n, t, a, r) {
                const i = (0, u.buffer)(r, n.dtype, t),
                    s = (0, u.buffer)(n.shape, n.dtype, e);
                for (let u = 0; u < i.size; ++u) {
                    const e = i.indexToLoc(u).map((e, n) => e + a[n]);
                    t[u] = s.get(...e)
                }
            }(l, n, d, i, s), p
        }! function(e) {
            e[e.bilinear = 0] = "bilinear", e[e.nearest = 1] = "nearest"
        }(T || (T = {}));
        const fe = [c, f, h, M, S, x, C, D, E, P, z, H, {
            kernelName: u.CropAndResize,
            backendName: "wasm",
            setupFunc: function(e) {
                U = e.wasm.cwrap(u.CropAndResize, null, ["number", "number", "number", "number", "array", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    method: r,
                    extrapolationValue: u,
                    cropSize: i
                } = a, {
                    image: s,
                    boxes: o,
                    boxInd: l
                } = t, p = o.shape[0], [d, c] = i, m = [p, d, c, s.shape[3]];
                let f, b = n.dataIdMap.get(s.dataId);
                "float32" !== s.dtype && (f = N({
                    backend: n,
                    inputs: {
                        x: s
                    },
                    attrs: {
                        dtype: "float32"
                    }
                }), b = n.dataIdMap.get(f.dataId));
                const h = b.id,
                    y = n.dataIdMap.get(o.dataId).id,
                    g = n.dataIdMap.get(l.dataId).id,
                    w = n.makeOutput(m, "float32"),
                    _ = n.dataIdMap.get(w.dataId).id,
                    I = new Uint8Array(new Int32Array(s.shape).buffer);
                return U(h, y, g, p, I, d, c, T[r], u, _), null != f && n.disposeData(f.dataId), w
            }
        }, {
            kernelName: u.DepthwiseConv2dNative,
            backendName: "wasm",
            setupFunc: function(e) {
                B = e.wasm.cwrap(u.DepthwiseConv2dNative, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, {
                    x: r,
                    filter: i
                } = n, s = a.dataIdMap.get(r.dataId).id, o = a.dataIdMap.get(i.dataId).id, {
                    strides: l,
                    dilations: p,
                    pad: d,
                    dimRoundingMode: c
                } = t, m = null == p ? [1, 1] : p, f = u.backend_util.computeConv2DInfo(r.shape, i.shape, l, m, d, c, !0), b = f.filterHeight, h = f.filterWidth, y = f.padInfo.top, g = f.padInfo.right, w = f.padInfo.bottom, _ = f.padInfo.left, I = f.dilationHeight, k = f.dilationWidth, v = f.strideHeight, M = f.strideWidth, A = f.inChannels, S = f.outChannels, F = "SAME" === f.padInfo.type ? 1 : 0;
                if ("channelsLast" !== f.dataFormat) throw new Error("wasm backend DepthwiseConv2dNative does not support dataFormat:'" + `${f.dataFormat}'. Please use 'channelsLast'.`);
                const x = a.makeOutput(f.outShape, "float32"),
                    N = a.dataIdMap.get(x.dataId).id;
                return B(s, r.shape[0], r.shape[1], r.shape[2], o, b, h, y, g, w, _, F, I, k, v, M, A, S, N), x
            }
        }, m(u.Div, !0), m(u.Equal, !1, "bool"), d(u.Exp), {
            kernelName: u.Fill,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    attrs: {
                        shape: n,
                        value: t,
                        dtype: a
                    },
                    backend: r
                } = e, u = r.makeOutput(n, a);
                return r.typedArrayFromHeap(u).fill(t), u
            }
        }, m(u.FloorDiv, !1), p, {
            kernelName: u.FusedBatchNorm,
            backendName: "wasm",
            setupFunc: function(e) {
                V = e.wasm.cwrap(u.FusedBatchNorm, null, ["number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    varianceEpsilon: r
                } = a, {
                    x: i,
                    mean: s,
                    variance: o,
                    offset: l,
                    scale: p
                } = t, d = n.dataIdMap.get(i.dataId).id, c = n.dataIdMap.get(s.dataId).id, m = n.dataIdMap.get(o.dataId).id, f = null != l ? n.dataIdMap.get(l.dataId).id : 0, b = null != p ? n.dataIdMap.get(p.dataId).id : 0, h = n.makeOutput(i.shape, i.dtype);
                if (0 === u.util.sizeFromShape(i.shape)) return h;
                const y = n.dataIdMap.get(h.dataId).id;
                return V(d, c, m, f, b, r, y), h
            }
        }, {
            kernelName: u.FusedConv2D,
            backendName: "wasm",
            setupFunc: function(e) {
                q = e.wasm.cwrap(u.FusedConv2D, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, {
                    x: i,
                    filter: s,
                    bias: o,
                    preluActivationWeights: l
                } = n, {
                    strides: p,
                    pad: d,
                    dilations: c,
                    dataFormat: m,
                    dimRoundingMode: f,
                    activation: b
                } = t, h = u.backend_util.computeConv2DInfo(i.shape, s.shape, p, c, d, f), y = r[b];
                if (null == y) throw new Error(`${b} activation not yet supported for FusedConv2D ` + "in the wasm backend.");
                const g = a.dataIdMap.get(i.dataId).id,
                    w = a.dataIdMap.get(s.dataId).id,
                    _ = h.outChannels;
                let I = 0;
                if (null != o) {
                    const e = a.dataIdMap.get(o.dataId);
                    if (1 !== e.shape.length) throw new Error("FusedConv2D only supports rank-1 bias but got " + `rank ${e.shape.length}.`);
                    if (e.shape[0] !== _) throw new Error(`FusedConv2D bias shape (${e.shape}) does not ` + `match the number of output channels (${_})`);
                    I = e.id
                }
                const k = h.filterHeight,
                    v = h.filterWidth,
                    M = h.padInfo.top,
                    A = h.padInfo.right,
                    S = h.padInfo.bottom,
                    F = h.padInfo.left,
                    x = h.dilationHeight,
                    N = h.dilationWidth,
                    C = h.strideHeight,
                    R = h.strideWidth,
                    D = h.inChannels,
                    E = "SAME" === h.padInfo.type ? 1 : 0,
                    O = h.batchSize,
                    P = h.inHeight,
                    W = h.inWidth;
                if ("NHWC" !== m) throw new Error("wasm backend FusedConv2D does not support dataFormat:'" + `${m}'. Please use 'NHWC'.`);
                const z = a.makeOutput(h.outShape, "float32"),
                    H = a.dataIdMap.get(z.dataId).id,
                    T = null == l ? 0 : a.dataIdMap.get(l.dataId).id;
                return q(g, O, P, W, w, k, v, I, M, A, S, F, E, x, N, C, R, D, _, y, T, H), z
            }
        }, {
            kernelName: u.FusedDepthwiseConv2D,
            backendName: "wasm",
            setupFunc: function(e) {
                L = e.wasm.cwrap(u.FusedDepthwiseConv2D, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, {
                    x: i,
                    filter: s,
                    bias: o,
                    preluActivationWeights: l
                } = n, {
                    strides: p,
                    pad: d,
                    dilations: c,
                    dataFormat: m,
                    dimRoundingMode: f,
                    activation: b
                } = t, h = u.backend_util.computeConv2DInfo(i.shape, s.shape, p, c, d, f, !0), y = r[b];
                if (null == y) throw new Error(`${b} activation not yet supported for FusedDepthwiseConv2D ` + "in the wasm backend.");
                const g = a.dataIdMap.get(i.dataId).id,
                    w = a.dataIdMap.get(s.dataId).id,
                    _ = h.outChannels;
                let I = 0;
                if (null != o) {
                    const e = a.dataIdMap.get(o.dataId);
                    if (1 !== e.shape.length) throw new Error("FusedDepthwiseConv2D only supports rank-1 bias but got " + `rank ${e.shape.length}.`);
                    if (e.shape[0] !== _) throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not ` + `match the number of output channels (${_})`);
                    I = e.id
                }
                const k = h.filterHeight,
                    v = h.filterWidth,
                    M = h.padInfo.top,
                    A = h.padInfo.right,
                    S = h.padInfo.bottom,
                    F = h.padInfo.left,
                    x = h.dilationHeight,
                    N = h.dilationWidth,
                    C = h.strideHeight,
                    R = h.strideWidth,
                    D = h.inChannels,
                    E = "SAME" === h.padInfo.type ? 1 : 0,
                    O = h.batchSize,
                    P = h.inHeight,
                    W = h.inWidth;
                if ("NHWC" !== m) throw new Error("wasm backend FusedDepthwiseConv2D does not support dataFormat:'" + `${m}'. Please use 'NHWC'.`);
                const z = a.makeOutput(h.outShape, "float32"),
                    H = a.dataIdMap.get(z.dataId).id,
                    T = null == l ? 0 : a.dataIdMap.get(l.dataId).id;
                return L(g, O, P, W, w, k, v, I, M, A, S, F, E, x, N, C, R, D, _, y, T, H), z
            }
        }, {
            kernelName: u.GatherNd,
            backendName: "wasm",
            setupFunc: function(e) {
                j = e.wasm.cwrap(u.GatherNd, null, ["number", "number", "number", "number", "number", "number", "array", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t
                } = e, {
                    params: r,
                    indices: i
                } = t, [s, o, l, p] = u.gather_util.prepareAndValidate(r, i), d = n.makeOutput(s, r.dtype);
                if (0 === o) return d;
                const c = i.shape,
                    m = c[c.length - 1],
                    f = n.dataIdMap.get(r.dataId).id,
                    b = n.dataIdMap.get(i.dataId).id,
                    h = new Uint8Array(new Int32Array(p).buffer),
                    y = n.dataIdMap.get(d.dataId).id;
                return j(f, a[r.dtype], b, o, m, l, h, y), d
            }
        }, {
            kernelName: u.GatherV2,
            backendName: "wasm",
            setupFunc: function(e) {
                G = e.wasm.cwrap("Gather", null, ["number", "number", "array", "number", "number", "number", "array", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: r
                } = e, {
                    x: i,
                    indices: s
                } = t, {
                    axis: o
                } = r, l = i.shape.slice();
                l[o] = u.util.sizeFromShape(s.shape);
                const p = i.shape.length - 1,
                    d = n.makeOutput(l, i.dtype);
                if (0 === u.util.sizeFromShape(i.shape)) return d;
                const c = n.dataIdMap.get(i.dataId).id,
                    m = n.dataIdMap.get(s.dataId).id,
                    f = n.dataIdMap.get(d.dataId).id,
                    b = new Uint8Array(new Int32Array(u.util.computeStrides(i.shape)).buffer),
                    h = new Uint8Array(new Int32Array(u.util.computeStrides(l)).buffer);
                G(c, a[i.dtype], b, p, m, o, h, f);
                const y = u.util.parseAxisParam(o, i.shape)[0],
                    g = u.backend_util.segment_util.collectGatherOpShapeInfo(i, s, y);
                return d.shape = g.outputShape, d
            }
        }, m(u.Greater, !1, "bool"), m(u.GreaterEqual, !1, "bool"), g, m(u.Less, !1, "bool"), m(u.LessEqual, !1, "bool"), d(u.Log), m(u.LogicalAnd, !1, "bool"), {
            kernelName: u.Max,
            backendName: "wasm",
            setupFunc: function(e) {
                $ = e.wasm.cwrap(u.Max, null, ["number, number, number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    reductionIndices: r,
                    keepDims: i
                } = a, {
                    x: s
                } = t;
                let o = n.dataIdMap.get(s.dataId).id,
                    l = s;
                const {
                    transposed: p,
                    axes: d,
                    originalAxes: c,
                    inputWasTransposed: m
                } = k(s, r, n);
                m && (l = p, o = n.dataIdMap.get(p.dataId).id);
                const f = l.shape.length;
                u.backend_util.assertAxesAreInnerMostDims("max", d, f);
                const [b, h] = u.backend_util.computeOutAndReduceShapes(l.shape, d), y = u.util.sizeFromShape(h), g = n.makeOutput(b, s.dtype);
                if (0 !== u.util.sizeFromShape(l.shape)) {
                    const e = n.dataIdMap.get(g.dataId).id;
                    $(o, y, e)
                }
                if (m && n.disposeData(p.dataId), i) {
                    const e = u.backend_util.expandShapeToKeepDim(g.shape, c);
                    g.shape = e
                }
                return g
            }
        }, m(u.Maximum, !1), {
            kernelName: u.MaxPool,
            backendName: "wasm",
            setupFunc: function(e) {
                K = e.wasm.cwrap(u.MaxPool, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, r = n.x, i = a.dataIdMap.get(r.dataId).id, {
                    filterSize: s,
                    strides: o,
                    pad: l,
                    dimRoundingMode: p
                } = t, d = u.backend_util.computePool2DInfo(r.shape, s, o, 1, l, p), c = d.filterHeight, m = d.filterWidth, f = d.padInfo.top, b = d.padInfo.right, h = d.padInfo.bottom, y = d.padInfo.left, g = d.dilationHeight, w = d.dilationWidth, _ = d.strideHeight, I = d.strideWidth, k = d.inChannels, v = d.outChannels;
                if ("channelsLast" !== d.dataFormat) throw new Error("wasm backend does not support dataFormat:'" + `${d.dataFormat}'. Please use 'channelsLast'.`);
                const M = a.makeOutput(d.outShape, "float32"),
                    A = a.dataIdMap.get(M.dataId).id;
                return K(i, r.shape[0], r.shape[1], r.shape[2], c, m, f, b, h, y, g, w, _, I, k, v, A), M
            }
        }, {
            kernelName: u.Min,
            backendName: "wasm",
            setupFunc: function(e) {
                X = e.wasm.cwrap(u.Min, null, ["number, number, number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    axis: r,
                    keepDims: i
                } = a, {
                    x: s
                } = t, o = n.dataIdMap.get(s.dataId).id;
                let l = o,
                    p = s;
                const {
                    transposed: d,
                    axes: c,
                    originalAxes: m,
                    inputWasTransposed: f
                } = k(s, r, n);
                if (f) {
                    const e = n.dataIdMap.get(d.dataId).id;
                    e !== o && (p = d, l = e)
                }
                const b = p.shape.length;
                u.backend_util.assertAxesAreInnerMostDims("min", c, b);
                const [h, y] = u.backend_util.computeOutAndReduceShapes(p.shape, c), g = u.util.sizeFromShape(y), w = n.makeOutput(h, p.dtype);
                if (0 !== u.util.sizeFromShape(p.shape)) {
                    const e = n.dataIdMap.get(w.dataId).id;
                    X(l, g, e)
                }
                if (f && n.disposeData(d.dataId), i) {
                    const e = u.backend_util.expandShapeToKeepDim(w.shape, m);
                    w.shape = e
                }
                return w
            }
        }, m(u.Minimum, !1), m(u.Multiply, !0), d(u.Negate), {
            kernelName: u.NonMaxSuppressionV3,
            backendName: "wasm",
            setupFunc: function(e) {
                Y = e.wasm.cwrap(u.NonMaxSuppressionV3, "number", ["number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    iouThreshold: r,
                    maxOutputSize: u,
                    scoreThreshold: i
                } = a, {
                    boxes: s,
                    scores: o
                } = t, l = n.dataIdMap.get(s.dataId).id, p = n.dataIdMap.get(o.dataId).id, d = Y(l, p, u, r, i), {
                    pSelectedIndices: c,
                    selectedSize: m,
                    pSelectedScores: f,
                    pValidOutputs: b
                } = de(n, d);
                return n.wasm._free(f), n.wasm._free(b), n.makeOutput([m], "int32", c)
            }
        }, {
            kernelName: u.NonMaxSuppressionV4,
            backendName: "wasm",
            setupFunc: function(e) {
                Z = e.wasm.cwrap(u.NonMaxSuppressionV4, "number", ["number", "number", "number", "number", "number", "bool"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    iouThreshold: r,
                    maxOutputSize: u,
                    scoreThreshold: i,
                    padToMaxOutputSize: s
                } = a, {
                    boxes: o,
                    scores: l
                } = t, p = n.dataIdMap.get(o.dataId).id, d = n.dataIdMap.get(l.dataId).id, c = Z(p, d, u, r, i, s), {
                    pSelectedIndices: m,
                    selectedSize: f,
                    pSelectedScores: b,
                    pValidOutputs: h
                } = de(n, c);
                return n.wasm._free(b), [n.makeOutput([f], "int32", m), n.makeOutput([], "int32", h)]
            }
        }, {
            kernelName: u.NonMaxSuppressionV5,
            backendName: "wasm",
            setupFunc: function(e) {
                J = e.wasm.cwrap(u.NonMaxSuppressionV5, "number", ["number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    iouThreshold: r,
                    maxOutputSize: u,
                    scoreThreshold: i,
                    softNmsSigma: s
                } = a, {
                    boxes: o,
                    scores: l
                } = t, p = n.dataIdMap.get(o.dataId).id, d = n.dataIdMap.get(l.dataId).id, c = J(p, d, u, r, i, s), {
                    pSelectedIndices: m,
                    selectedSize: f,
                    pSelectedScores: b,
                    pValidOutputs: h
                } = de(n, c);
                return n.wasm._free(h), [n.makeOutput([f], "int32", m), n.makeOutput([f], "float32", b)]
            }
        }, m(u.NotEqual, !1, "bool"), {
            kernelName: u.OneHot,
            backendName: "wasm",
            setupFunc: function(e) {
                Q = e.wasm.cwrap(u.OneHot, null, ["number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    indices: r
                } = n, {
                    depth: u,
                    onValue: i,
                    offValue: s
                } = a, o = t.makeOutput([...r.shape, u], "int32"), l = t.dataIdMap.get(o.dataId).id, p = t.dataIdMap.get(r.dataId).id;
                return Q(p, u, i, s, l), o
            }
        }, {
            kernelName: u.OnesLike,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: {
                        x: n
                    },
                    backend: t
                } = e, a = t.makeOutput(n.shape, n.dtype);
                return t.typedArrayFromHeap(a).fill(1), a
            }
        }, {
            kernelName: u.PadV2,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: {
                        x: n
                    },
                    backend: t,
                    attrs: {
                        paddings: r,
                        constantValue: u
                    }
                } = e, i = r.map((e, t) => e[0] + n.shape[t] + e[1]), s = t.dataIdMap.get(n.dataId).id, o = t.makeOutput(i, n.dtype), l = t.dataIdMap.get(o.dataId).id, p = new Uint8Array(new Int32Array(n.shape).buffer), d = r.map(e => e[0]), c = r.map(e => e[1]), m = new Uint8Array(new Int32Array(d).buffer), f = new Uint8Array(new Int32Array(c).buffer);
                return ee(s, p, n.shape.length, a[n.dtype], m, f, u, l), o
            },
            setupFunc: function(e) {
                ee = e.wasm.cwrap(u.PadV2, null, ["number", "array", "number", "number", "array", "array", "number", "number"])
            }
        }, m(u.Pow, !1), {
            kernelName: u.Prelu,
            backendName: "wasm",
            setupFunc: function(e) {
                ne = e.wasm.cwrap(u.Prelu, null, ["number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t
                } = e, {
                    x: a,
                    alpha: r
                } = n, u = t.dataIdMap.get(a.dataId).id, i = t.dataIdMap.get(r.dataId).id, s = t.makeOutput(a.shape, "float32"), o = t.dataIdMap.get(s.dataId).id;
                return ne(u, i, o), s
            }
        }, d(u.Relu), d(u.Relu6), {
            kernelName: u.Reshape,
            backendName: "wasm",
            kernelFunc: ce
        }, {
            kernelName: u.ResizeBilinear,
            backendName: "wasm",
            setupFunc: function(e) {
                te = e.wasm.cwrap(u.ResizeBilinear, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    images: r
                } = t, {
                    alignCorners: i,
                    size: s
                } = a, [o, l] = s, [p, d, c, m] = r.shape, f = [p, o, l, m];
                let b, h = n.dataIdMap.get(r.dataId);
                "float32" !== h.dtype && (b = N({
                    backend: n,
                    inputs: {
                        x: r
                    },
                    attrs: {
                        dtype: "float32"
                    }
                }), h = n.dataIdMap.get(b.dataId));
                const y = h.id,
                    g = n.makeOutput(f, "float32");
                if (0 === u.util.sizeFromShape(r.shape)) return g;
                const w = n.dataIdMap.get(g.dataId).id;
                return te(y, p, d, c, m, o, l, i ? 1 : 0, w), null != b && n.disposeData(b.dataId), g
            }
        }, {
            kernelName: u.Reverse,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    x: r
                } = n, {
                    dims: i
                } = a, s = u.util.parseAxisParam(i, r.shape);
                if (0 === r.shape.length) return y({
                    inputs: {
                        x: r
                    },
                    backend: t
                });
                const o = t.makeOutput(r.shape, r.dtype),
                    l = t.dataIdMap.get(r.dataId).id,
                    p = t.dataIdMap.get(o.dataId).id,
                    d = new Uint8Array(new Int32Array(s).buffer),
                    c = new Uint8Array(new Int32Array(r.shape).buffer);
                return ae(l, d, s.length, c, r.shape.length, p), ce({
                    inputs: {
                        x: o
                    },
                    attrs: {
                        shape: r.shape
                    },
                    backend: t
                })
            },
            setupFunc: function(e) {
                ae = e.wasm.cwrap(u.Reverse, null, ["number", "array", "number", "array", "number", "number"])
            }
        }, {
            kernelName: u.RotateWithOffset,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    image: r
                } = n, {
                    radians: i,
                    fillValue: s,
                    center: o
                } = a, l = t.makeOutput(r.shape, r.dtype), p = t.dataIdMap.get(r.dataId).id, d = t.dataIdMap.get(l.dataId).id, [c, m, f, b] = r.shape, [h, y] = u.backend_util.getImageCenter(o, m, f), g = "number" == typeof s ? [s, s, s, 0 === s ? 0 : 255] : [...s, 255], w = new Uint8Array(new Int32Array(g).buffer);
                return re(p, c, m, f, b, i, h, y, w, g.length, d), l
            },
            setupFunc: function(e) {
                re = e.wasm.cwrap(u.RotateWithOffset, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"])
            }
        }, d(u.Rsqrt), {
            kernelName: u.ScatterNd,
            backendName: "wasm",
            setupFunc: function(e) {
                ue = e.wasm.cwrap(u.ScatterNd, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: r
                } = e, {
                    indices: i,
                    updates: s
                } = t, {
                    shape: o
                } = r, l = n.makeOutput(o, s.dtype);
                if (0 === u.util.sizeFromShape(o)) return l;
                const {
                    sliceRank: p,
                    numUpdates: d,
                    sliceSize: c,
                    strides: m,
                    outputSize: f
                } = u.scatter_util.calculateShapes(s, i, o), b = n.dataIdMap.get(i.dataId).id, h = n.dataIdMap.get(s.dataId).id, y = new Uint8Array(new Int32Array(m).buffer), g = n.dataIdMap.get(l.dataId).id;
                return ue(b, h, a[s.dtype], p, d, c, y, f, g), l
            }
        }, {
            kernelName: u.SelectV2,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t
                } = e, {
                    condition: a,
                    t: r,
                    e: i
                } = n, s = t.dataIdMap.get(a.dataId).id, o = t.dataIdMap.get(r.dataId).id, l = t.dataIdMap.get(i.dataId).id, p = t.makeOutput(r.shape, r.dtype), d = t.dataIdMap.get(p.dataId).id, c = a.shape.length, m = r.shape.length, f = 0 === c || c > 1 || 1 === m ? 1 : u.util.sizeFromShape(r.shape.slice(1));
                return ie(s, o, l, f, d), p
            },
            setupFunc: function(e) {
                ie = e.wasm.cwrap(u.SelectV2, null, ["number", "number", "number", "number", "number"])
            }
        }, {
            kernelName: "Sigmoid",
            backendName: "wasm",
            setupFunc: function(e) {
                se = e.wasm.cwrap(u.Sigmoid, null, ["number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: {
                        x: t
                    }
                } = e, a = n.dataIdMap.get(t.dataId).id, r = n.makeOutput(t.shape, t.dtype), i = n.dataIdMap.get(r.dataId).id;
                return 0 === u.util.sizeFromShape(r.shape) ? r : (se(a, i), r)
            }
        }, d(u.Sin), {
            kernelName: u.Slice,
            backendName: "wasm",
            kernelFunc: me
        }, {
            kernelName: u.Softmax,
            backendName: "wasm",
            setupFunc: function(e) {
                oe = e.wasm.cwrap(u.Softmax, null, ["number", "number", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: {
                        logits: t
                    },
                    attrs: {
                        dim: a
                    }
                } = e, r = n.dataIdMap.get(t.dataId).id, i = n.makeOutput(t.shape, t.dtype), s = n.dataIdMap.get(i.dataId).id, o = t.shape[a], l = u.util.sizeFromShape(t.shape) / o;
                return 0 === u.util.sizeFromShape(i.shape) ? i : (oe(r, s, o, l), i)
            }
        }, {
            kernelName: u.SplitV,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    attrs: t,
                    backend: a
                } = e, {
                    x: r
                } = n, {
                    numOrSizeSplits: i,
                    axis: s
                } = t, o = u.util.parseAxisParam(s, r.shape)[0], l = u.backend_util.prepareSplitSize(r, i, s), p = new Array(r.shape.length).fill(0), d = r.shape.slice();
                return l.map(e => {
                    const n = [...d];
                    n[o] = e;
                    const t = me({
                        inputs: {
                            x: r
                        },
                        attrs: {
                            begin: p,
                            size: n
                        },
                        backend: a
                    });
                    return p[o] += e, t
                })
            }
        }, d(u.Sqrt), d(u.Square), m(u.Sub, !0), {
            kernelName: u.Sum,
            backendName: "wasm",
            setupFunc: function(e) {
                le = e.wasm.cwrap(u.Sum, null, ["number, number, number"])
            },
            kernelFunc: function(e) {
                const {
                    backend: n,
                    inputs: t,
                    attrs: a
                } = e, {
                    axis: r,
                    keepDims: i
                } = a, {
                    x: s
                } = t, o = n.dataIdMap.get(s.dataId).id;
                let l = o,
                    p = s;
                const {
                    transposed: d,
                    axes: c,
                    originalAxes: m,
                    inputWasTransposed: f
                } = k(s, r, n);
                let b = c;
                if (f) {
                    const e = n.dataIdMap.get(d.dataId).id;
                    e !== o && (p = d, l = e, b = u.backend_util.getInnerMostAxes(b.length, p.shape.length))
                }
                u.backend_util.assertAxesAreInnerMostDims("sum", b, p.shape.length);
                const [h, y] = u.backend_util.computeOutAndReduceShapes(p.shape, b), g = u.util.sizeFromShape(y), w = n.makeOutput(h, p.dtype);
                if (0 !== u.util.sizeFromShape(p.shape)) {
                    const e = n.dataIdMap.get(w.dataId).id;
                    le(l, g, e)
                }
                if (f && n.disposeData(d.dataId), i) {
                    const e = u.backend_util.expandShapeToKeepDim(w.shape, m);
                    w.shape = e
                }
                return w
            }
        }, d(u.Tanh), {
            kernelName: u.Tile,
            backendName: "wasm",
            setupFunc: function(e) {
                pe = e.wasm.cwrap(u.Tile, null, ["number", "array", "number", "array", "number", "number"])
            },
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: r
                } = e, {
                    x: u
                } = n, i = t.dataIdMap.get(u.dataId).id, {
                    reps: s
                } = r, o = new Array(u.shape.length);
                for (let a = 0; a < o.length; a++) o[a] = u.shape[a] * s[a];
                const l = new Uint8Array(new Int32Array(u.shape).buffer),
                    p = new Uint8Array(new Int32Array(o).buffer),
                    d = t.makeOutput(o, u.dtype),
                    c = t.dataIdMap.get(d.dataId).id;
                return pe(i, l, u.shape.length, p, o.length, a[d.dtype], c), d
            }
        }, I, {
            kernelName: u.Unpack,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: n,
                    backend: t,
                    attrs: a
                } = e, {
                    value: r
                } = n, {
                    axis: u
                } = a, i = r.shape[u], s = r.shape.length, o = new Array(s - 1);
                let l = 0;
                for (let m = 0; m < s; m++) m !== u && (o[l++] = r.shape[m]);
                const p = new Array(i),
                    d = new Array(s).fill(0),
                    c = r.shape.slice();
                c[u] = 1;
                for (let m = 0; m < p.length; m++) d[u] = m, p[m] = me({
                    inputs: {
                        x: r
                    },
                    attrs: {
                        begin: d,
                        size: c
                    },
                    backend: t
                });
                return p.map(({
                    dataId: e,
                    dtype: n
                }) => ({
                    dataId: e,
                    dtype: n,
                    shape: o
                }))
            }
        }, {
            kernelName: u.ZerosLike,
            backendName: "wasm",
            kernelFunc: function(e) {
                const {
                    inputs: {
                        x: n
                    },
                    backend: t
                } = e, a = t.makeOutput(n.shape, n.dtype);
                return t.typedArrayFromHeap(a).fill(0), a
            }
        }];
        for (const Me of fe)(0, u.registerKernel)(Me);

        function be(e, n) {
            return e(n = {
                exports: {}
            }, n.exports), n.exports
        }(0, u.env)().registerFlag("WASM_HAS_SIMD_SUPPORT", async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11])));
        var he = be(function(a, r) {
                var u, o = (u = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, void 0 !== e && (u = u || e), function(e) {
                    var a, r = void 0 !== (e = e || {}) ? e : {},
                        o = {};
                    for (a in r) r.hasOwnProperty(a) && (o[a] = r[a]);
                    var l, p, d = !1,
                        c = !1;
                    d = "object" == typeof window, c = "function" == typeof importScripts, l = "object" == typeof n && "object" == typeof n.versions && "string" == typeof n.versions.node, p = !d && !l && !c;
                    var m, f, b, h, y = "";
                    l ? (y = c ? i.default.dirname(y) + "/" : t + "/", m = function(e, n) {
                        return b || (b = s.default), h || (h = i.default), e = h.normalize(e), b.readFileSync(e, n ? null : "utf8")
                    }, f = function(e) {
                        var n = m(e, !0);
                        return n.buffer || (n = new Uint8Array(n)), M(n.buffer), n
                    }, n.argv.length > 1 && n.argv[1].replace(/\\/g, "/"), n.argv.slice(2), n.on("uncaughtException", function(e) {
                        if (!(e instanceof
                                function(e) {
                                    this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                                })) throw e
                    }), n.on("unhandledRejection", $), r.inspect = function() {
                        return "[Emscripten Module object]"
                    }) : p ? ("undefined" != typeof read && (m = function(e) {
                        return read(e)
                    }), f = function(e) {
                        var n;
                        return "function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (M("object" == typeof(n = read(e, "binary"))), n)
                    }, "undefined" != typeof scriptArgs && scriptArgs, "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (d || c) && (c ? y = self.location.href : document.currentScript && (y = document.currentScript.src), u && (y = u), y = 0 !== y.indexOf("blob:") ? y.substr(0, y.lastIndexOf("/") + 1) : "", m = function(e) {
                        var n = new XMLHttpRequest;
                        return n.open("GET", e, !1), n.send(null), n.responseText
                    }, c && (f = function(e) {
                        var n = new XMLHttpRequest;
                        return n.open("GET", e, !1), n.responseType = "arraybuffer", n.send(null), new Uint8Array(n.response)
                    }));
                    var g, w, _ = r.print || console.log.bind(console),
                        I = r.printErr || console.warn.bind(console);
                    for (a in o) o.hasOwnProperty(a) && (r[a] = o[a]);
                    o = null, r.arguments && r.arguments, r.thisProgram && r.thisProgram, r.quit && r.quit, r.wasmBinary && (g = r.wasmBinary), r.noExitRuntime && r.noExitRuntime, "object" != typeof WebAssembly && I("no native wasm support detected");
                    var k = new WebAssembly.Table({
                            initial: 151,
                            maximum: 151,
                            element: "anyfunc"
                        }),
                        v = !1;

                    function M(e, n) {
                        e || $("Assertion failed: " + n)
                    }

                    function A(e) {
                        var n = r["_" + e];
                        return M(n, "Cannot call unknown function " + e + ", make sure it is exported"), n
                    }

                    function S(e, n, t, a, r) {
                        var u = {
                                string: function(e) {
                                    var n = 0;
                                    if (null != e && 0 !== e) {
                                        var t = 1 + (e.length << 2);
                                        ! function(e, n, t) {
                                            (function(e, n, t, a) {
                                                if (!(a > 0)) return 0;
                                                for (var r = t, u = t + a - 1, i = 0; i < e.length; ++i) {
                                                    var s = e.charCodeAt(i);
                                                    if (s >= 55296 && s <= 57343 && (s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++i)), s <= 127) {
                                                        if (t >= u) break;
                                                        n[t++] = s
                                                    } else if (s <= 2047) {
                                                        if (t + 1 >= u) break;
                                                        n[t++] = 192 | s >> 6, n[t++] = 128 | 63 & s
                                                    } else if (s <= 65535) {
                                                        if (t + 2 >= u) break;
                                                        n[t++] = 224 | s >> 12, n[t++] = 128 | s >> 6 & 63, n[t++] = 128 | 63 & s
                                                    } else {
                                                        if (t + 3 >= u) break;
                                                        n[t++] = 240 | s >> 18, n[t++] = 128 | s >> 12 & 63, n[t++] = 128 | s >> 6 & 63, n[t++] = 128 | 63 & s
                                                    }
                                                }
                                                n[t] = 0
                                            })(e, D, n, t)
                                        }(e, n = oe(t), t)
                                    }
                                    return n
                                },
                                array: function(e) {
                                    var n = oe(e.length);
                                    return function(e, n) {
                                        R.set(e, n)
                                    }(e, n), n
                                }
                            },
                            i = A(e),
                            s = [],
                            o = 0;
                        if (a)
                            for (var l = 0; l < a.length; l++) {
                                var p = u[t[l]];
                                p ? (0 === o && (o = se()), s[l] = p(a[l])) : s[l] = a[l]
                            }
                        var d = i.apply(null, s);
                        return d = function(e) {
                            return "string" === n ? N(e) : "boolean" === n ? Boolean(e) : e
                        }(d), 0 !== o && le(o), d
                    }
                    var F = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

                    function x(e, n, t) {
                        for (var a = n + t, r = n; e[r] && !(r >= a);) ++r;
                        if (r - n > 16 && e.subarray && F) return F.decode(e.subarray(n, r));
                        for (var u = ""; n < r;) {
                            var i = e[n++];
                            if (128 & i) {
                                var s = 63 & e[n++];
                                if (192 != (224 & i)) {
                                    var o = 63 & e[n++];
                                    if ((i = 224 == (240 & i) ? (15 & i) << 12 | s << 6 | o : (7 & i) << 18 | s << 12 | o << 6 | 63 & e[n++]) < 65536) u += String.fromCharCode(i);
                                    else {
                                        var l = i - 65536;
                                        u += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l)
                                    }
                                } else u += String.fromCharCode((31 & i) << 6 | s)
                            } else u += String.fromCharCode(i)
                        }
                        return u
                    }

                    function N(e, n) {
                        return e ? x(D, e, n) : ""
                    }
                    var C, R, D, E;

                    function O(e, n) {
                        return e % n > 0 && (e += n - e % n), e
                    }

                    function P(e) {
                        C = e, r.HEAP8 = R = new Int8Array(e), r.HEAP16 = new Int16Array(e), r.HEAP32 = E = new Int32Array(e), r.HEAPU8 = D = new Uint8Array(e), r.HEAPU16 = new Uint16Array(e), r.HEAPU32 = new Uint32Array(e), r.HEAPF32 = new Float32Array(e), r.HEAPF64 = new Float64Array(e)
                    }
                    var W = r.INITIAL_MEMORY || 16777216;

                    function z(e) {
                        for (; e.length > 0;) {
                            var n = e.shift();
                            if ("function" != typeof n) {
                                var t = n.func;
                                "number" == typeof t ? void 0 === n.arg ? r.dynCall_v(t) : r.dynCall_vi(t, n.arg) : t(void 0 === n.arg ? null : n.arg)
                            } else n(r)
                        }
                    }(w = r.wasmMemory ? r.wasmMemory : new WebAssembly.Memory({
                        initial: W / 65536,
                        maximum: 32768
                    })) && (C = w.buffer), W = C.byteLength, P(C), E[2872] = 5254528;
                    var H = [],
                        T = [],
                        U = [],
                        B = [];
                    var V = Math.ceil,
                        q = Math.floor,
                        L = 0,
                        j = null,
                        G = null;

                    function $(e) {
                        throw r.onAbort && r.onAbort(e), _(e += ""), I(e), v = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e)
                    }

                    function K(e, n) {
                        return String.prototype.startsWith ? e.startsWith(n) : 0 === e.indexOf(n)
                    }
                    r.preloadedImages = {}, r.preloadedAudios = {};
                    var X = "data:application/octet-stream;base64,";

                    function Y(e) {
                        return K(e, X)
                    }
                    var Z = "file://";

                    function J(e) {
                        return K(e, Z)
                    }
                    var Q = "tfjs-backend-wasm-simd.wasm";

                    function ee() {
                        try {
                            if (g) return new Uint8Array(g);
                            if (f) return f(Q);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (e) {
                            $(e)
                        }
                    }

                    function ne(e) {
                        try {
                            return w.grow(e - C.byteLength + 65535 >>> 16), P(w.buffer), 1
                        } catch (e) {}
                    }
                    Y(Q) || (Q = function(e) {
                        return r.locateFile ? r.locateFile(e, y) : y + e
                    }(Q)), T.push({
                        func: function() {
                            ie()
                        }
                    });
                    var te = {
                        mappings: {},
                        buffers: [null, [],
                            []
                        ],
                        printChar: function(e, n) {
                            var t = te.buffers[e];
                            0 === n || 10 === n ? ((1 === e ? _ : I)(x(t, 0)), t.length = 0) : t.push(n)
                        },
                        varargs: void 0,
                        get: function() {
                            return te.varargs += 4, E[te.varargs - 4 >> 2]
                        },
                        getStr: function(e) {
                            return N(e)
                        },
                        get64: function(e, n) {
                            return e
                        }
                    };
                    var ae = {
                            a: function() {
                                $()
                            },
                            e: function(e, n, t) {
                                D.copyWithin(e, n, n + t)
                            },
                            f: function(e) {
                                e >>>= 0;
                                var n = D.length;
                                if (e > 2147483648) return !1;
                                for (var t = 1; t <= 4; t *= 2) {
                                    var a = n * (1 + .2 / t);
                                    if (a = Math.min(a, e + 100663296), ne(Math.min(2147483648, O(Math.max(16777216, e, a), 65536)))) return !0
                                }
                                return !1
                            },
                            g: function(e) {
                                return 0
                            },
                            d: function(e, n, t, a, r) {},
                            c: function(e, n, t, a) {
                                for (var r = 0, u = 0; u < t; u++) {
                                    for (var i = E[n + 8 * u >> 2], s = E[n + (8 * u + 4) >> 2], o = 0; o < s; o++) te.printChar(e, D[i + o]);
                                    r += s
                                }
                                return E[a >> 2] = r, 0
                            },
                            memory: w,
                            b: function(e) {
                                return (e = +e) >= 0 ? +q(e + .5) : +V(e - .5)
                            },
                            table: k
                        },
                        re = function() {
                            var e = {
                                a: ae
                            };

                            function n(e, n) {
                                var t = e.exports;
                                r.asm = t,
                                    function(e) {
                                        if (L--, r.monitorRunDependencies && r.monitorRunDependencies(L), 0 == L && (null !== j && (clearInterval(j), j = null), G)) {
                                            var n = G;
                                            G = null, n()
                                        }
                                    }()
                            }

                            function t(e) {
                                n(e.instance)
                            }

                            function a(n) {
                                return (g || !d && !c || "function" != typeof fetch || J(Q) ? new Promise(function(e, n) {
                                    e(ee())
                                }) : fetch(Q, {
                                    credentials: "same-origin"
                                }).then(function(e) {
                                    if (!e.ok) throw "failed to load wasm binary file at '" + Q + "'";
                                    return e.arrayBuffer()
                                }).catch(function() {
                                    return ee()
                                })).then(function(n) {
                                    return WebAssembly.instantiate(n, e)
                                }).then(n, function(e) {
                                    I("failed to asynchronously prepare wasm: " + e), $(e)
                                })
                            }
                            if (L++, r.monitorRunDependencies && r.monitorRunDependencies(L), r.instantiateWasm) try {
                                return r.instantiateWasm(e, n)
                            } catch (e) {
                                return I("Module.instantiateWasm callback failed with error: " + e), !1
                            }
                            return function() {
                                if (g || "function" != typeof WebAssembly.instantiateStreaming || Y(Q) || J(Q) || "function" != typeof fetch) return a(t);
                                fetch(Q, {
                                    credentials: "same-origin"
                                }).then(function(n) {
                                    return WebAssembly.instantiateStreaming(n, e).then(t, function(e) {
                                        I("wasm streaming compile failed: " + e), I("falling back to ArrayBuffer instantiation"), a(t)
                                    })
                                })
                            }(), {}
                        }();
                    r.asm = re;
                    var ue, ie = r.___wasm_call_ctors = function() {
                            return (ie = r.___wasm_call_ctors = r.asm.h).apply(null, arguments)
                        },
                        se = (r._init = function() {
                            return (r._init = r.asm.i).apply(null, arguments)
                        }, r._register_tensor = function() {
                            return (r._register_tensor = r.asm.j).apply(null, arguments)
                        }, r._dispose_data = function() {
                            return (r._dispose_data = r.asm.k).apply(null, arguments)
                        }, r._dispose = function() {
                            return (r._dispose = r.asm.l).apply(null, arguments)
                        }, r._Abs = function() {
                            return (r._Abs = r.asm.m).apply(null, arguments)
                        }, r._Add = function() {
                            return (r._Add = r.asm.n).apply(null, arguments)
                        }, r._AddN = function() {
                            return (r._AddN = r.asm.o).apply(null, arguments)
                        }, r._ArgMax = function() {
                            return (r._ArgMax = r.asm.p).apply(null, arguments)
                        }, r._AvgPool = function() {
                            return (r._AvgPool = r.asm.q).apply(null, arguments)
                        }, r._BatchMatMul = function() {
                            return (r._BatchMatMul = r.asm.r).apply(null, arguments)
                        }, r._ClipByValue = function() {
                            return (r._ClipByValue = r.asm.s).apply(null, arguments)
                        }, r._Conv2D = function() {
                            return (r._Conv2D = r.asm.t).apply(null, arguments)
                        }, r._Conv2DBackpropInput = function() {
                            return (r._Conv2DBackpropInput = r.asm.u).apply(null, arguments)
                        }, r._Cos = function() {
                            return (r._Cos = r.asm.v).apply(null, arguments)
                        }, r._CropAndResize = function() {
                            return (r._CropAndResize = r.asm.w).apply(null, arguments)
                        }, r._DepthwiseConv2dNative = function() {
                            return (r._DepthwiseConv2dNative = r.asm.x).apply(null, arguments)
                        }, r._Div = function() {
                            return (r._Div = r.asm.y).apply(null, arguments)
                        }, r._Equal = function() {
                            return (r._Equal = r.asm.z).apply(null, arguments)
                        }, r._Exp = function() {
                            return (r._Exp = r.asm.A).apply(null, arguments)
                        }, r._FloorDiv = function() {
                            return (r._FloorDiv = r.asm.B).apply(null, arguments)
                        }, r._FusedBatchNorm = function() {
                            return (r._FusedBatchNorm = r.asm.C).apply(null, arguments)
                        }, r._FusedConv2D = function() {
                            return (r._FusedConv2D = r.asm.D).apply(null, arguments)
                        }, r._FusedDepthwiseConv2D = function() {
                            return (r._FusedDepthwiseConv2D = r.asm.E).apply(null, arguments)
                        }, r._Gather = function() {
                            return (r._Gather = r.asm.F).apply(null, arguments)
                        }, r._GatherNd = function() {
                            return (r._GatherNd = r.asm.G).apply(null, arguments)
                        }, r._Greater = function() {
                            return (r._Greater = r.asm.H).apply(null, arguments)
                        }, r._GreaterEqual = function() {
                            return (r._GreaterEqual = r.asm.I).apply(null, arguments)
                        }, r._Less = function() {
                            return (r._Less = r.asm.J).apply(null, arguments)
                        }, r._LessEqual = function() {
                            return (r._LessEqual = r.asm.K).apply(null, arguments)
                        }, r._Log = function() {
                            return (r._Log = r.asm.L).apply(null, arguments)
                        }, r._LogicalAnd = function() {
                            return (r._LogicalAnd = r.asm.M).apply(null, arguments)
                        }, r._Max = function() {
                            return (r._Max = r.asm.N).apply(null, arguments)
                        }, r._MaxPool = function() {
                            return (r._MaxPool = r.asm.O).apply(null, arguments)
                        }, r._Maximum = function() {
                            return (r._Maximum = r.asm.P).apply(null, arguments)
                        }, r._Min = function() {
                            return (r._Min = r.asm.Q).apply(null, arguments)
                        }, r._Minimum = function() {
                            return (r._Minimum = r.asm.R).apply(null, arguments)
                        }, r._Multiply = function() {
                            return (r._Multiply = r.asm.S).apply(null, arguments)
                        }, r._Negate = function() {
                            return (r._Negate = r.asm.T).apply(null, arguments)
                        }, r._NonMaxSuppressionV3 = function() {
                            return (r._NonMaxSuppressionV3 = r.asm.U).apply(null, arguments)
                        }, r._NonMaxSuppressionV4 = function() {
                            return (r._NonMaxSuppressionV4 = r.asm.V).apply(null, arguments)
                        }, r._NonMaxSuppressionV5 = function() {
                            return (r._NonMaxSuppressionV5 = r.asm.W).apply(null, arguments)
                        }, r._NotEqual = function() {
                            return (r._NotEqual = r.asm.X).apply(null, arguments)
                        }, r._OneHot = function() {
                            return (r._OneHot = r.asm.Y).apply(null, arguments)
                        }, r._PadV2 = function() {
                            return (r._PadV2 = r.asm.Z).apply(null, arguments)
                        }, r._Pow = function() {
                            return (r._Pow = r.asm._).apply(null, arguments)
                        }, r._Prelu = function() {
                            return (r._Prelu = r.asm.$).apply(null, arguments)
                        }, r._Relu = function() {
                            return (r._Relu = r.asm.aa).apply(null, arguments)
                        }, r._Relu6 = function() {
                            return (r._Relu6 = r.asm.ba).apply(null, arguments)
                        }, r._ResizeBilinear = function() {
                            return (r._ResizeBilinear = r.asm.ca).apply(null, arguments)
                        }, r._Reverse = function() {
                            return (r._Reverse = r.asm.da).apply(null, arguments)
                        }, r._RotateWithOffset = function() {
                            return (r._RotateWithOffset = r.asm.ea).apply(null, arguments)
                        }, r._Rsqrt = function() {
                            return (r._Rsqrt = r.asm.fa).apply(null, arguments)
                        }, r._ScatterNd = function() {
                            return (r._ScatterNd = r.asm.ga).apply(null, arguments)
                        }, r._SelectV2 = function() {
                            return (r._SelectV2 = r.asm.ha).apply(null, arguments)
                        }, r._Sigmoid = function() {
                            return (r._Sigmoid = r.asm.ia).apply(null, arguments)
                        }, r._Sin = function() {
                            return (r._Sin = r.asm.ja).apply(null, arguments)
                        }, r._Softmax = function() {
                            return (r._Softmax = r.asm.ka).apply(null, arguments)
                        }, r._Sqrt = function() {
                            return (r._Sqrt = r.asm.la).apply(null, arguments)
                        }, r._Square = function() {
                            return (r._Square = r.asm.ma).apply(null, arguments)
                        }, r._Sub = function() {
                            return (r._Sub = r.asm.na).apply(null, arguments)
                        }, r._Sum = function() {
                            return (r._Sum = r.asm.oa).apply(null, arguments)
                        }, r._Tanh = function() {
                            return (r._Tanh = r.asm.pa).apply(null, arguments)
                        }, r._Tile = function() {
                            return (r._Tile = r.asm.qa).apply(null, arguments)
                        }, r._Transpose = function() {
                            return (r._Transpose = r.asm.ra).apply(null, arguments)
                        }, r.__FusedMatMul = function() {
                            return (r.__FusedMatMul = r.asm.sa).apply(null, arguments)
                        }, r._malloc = function() {
                            return (r._malloc = r.asm.ta).apply(null, arguments)
                        }, r._free = function() {
                            return (r._free = r.asm.ua).apply(null, arguments)
                        }, r.stackSave = function() {
                            return (se = r.stackSave = r.asm.va).apply(null, arguments)
                        }),
                        oe = r.stackAlloc = function() {
                            return (oe = r.stackAlloc = r.asm.wa).apply(null, arguments)
                        },
                        le = r.stackRestore = function() {
                            return (le = r.stackRestore = r.asm.xa).apply(null, arguments)
                        };

                    function pe(e) {
                        function n() {
                            ue || (ue = !0, r.calledRun = !0, v || (z(T), z(U), r.onRuntimeInitialized && r.onRuntimeInitialized(), function() {
                                if (r.postRun)
                                    for ("function" == typeof r.postRun && (r.postRun = [r.postRun]); r.postRun.length;) e = r.postRun.shift(), B.unshift(e);
                                var e;
                                z(B)
                            }()))
                        }
                        L > 0 || (function() {
                            if (r.preRun)
                                for ("function" == typeof r.preRun && (r.preRun = [r.preRun]); r.preRun.length;) e = r.preRun.shift(), H.unshift(e);
                            var e;
                            z(H)
                        }(), L > 0 || (r.setStatus ? (r.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                r.setStatus("")
                            }, 1), n()
                        }, 1)) : n()))
                    }
                    if (r.dynCall_vi = function() {
                            return (r.dynCall_vi = r.asm.ya).apply(null, arguments)
                        }, r.dynCall_v = function() {
                            return (r.dynCall_v = r.asm.za).apply(null, arguments)
                        }, r.asm = re, r.cwrap = function(e, n, t, a) {
                            var r = (t = t || []).every(function(e) {
                                return "number" === e
                            });
                            return "string" !== n && r && !a ? A(e) : function() {
                                return S(e, n, t, arguments)
                            }
                        }, r.then = function(e) {
                            if (ue) e(r);
                            else {
                                var n = r.onRuntimeInitialized;
                                r.onRuntimeInitialized = function() {
                                    n && n(), e(r)
                                }
                            }
                            return r
                        }, G = function e() {
                            ue || pe(), ue || (G = e)
                        }, r.run = pe, r.preInit)
                        for ("function" == typeof r.preInit && (r.preInit = [r.preInit]); r.preInit.length > 0;) r.preInit.pop()();
                    return pe(), e
                });
                a.exports = o
            }),
            ye = be(function(a, r) {
                var u, o = (u = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, void 0 !== e && (u = u || e), function(e) {
                    var a, r = void 0 !== (e = e || {}) ? e : {},
                        o = {};
                    for (a in r) r.hasOwnProperty(a) && (o[a] = r[a]);
                    var l, p, d = !1,
                        c = !1;
                    d = "object" == typeof window, c = "function" == typeof importScripts, l = "object" == typeof n && "object" == typeof n.versions && "string" == typeof n.versions.node, p = !d && !l && !c;
                    var m, f, b, h, y = "";
                    l ? (y = c ? i.default.dirname(y) + "/" : t + "/", m = function(e, n) {
                        return b || (b = s.default), h || (h = i.default), e = h.normalize(e), b.readFileSync(e, n ? null : "utf8")
                    }, f = function(e) {
                        var n = m(e, !0);
                        return n.buffer || (n = new Uint8Array(n)), M(n.buffer), n
                    }, n.argv.length > 1 && n.argv[1].replace(/\\/g, "/"), n.argv.slice(2), n.on("uncaughtException", function(e) {
                        if (!(e instanceof
                                function(e) {
                                    this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                                })) throw e
                    }), n.on("unhandledRejection", $), r.inspect = function() {
                        return "[Emscripten Module object]"
                    }) : p ? ("undefined" != typeof read && (m = function(e) {
                        return read(e)
                    }), f = function(e) {
                        var n;
                        return "function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (M("object" == typeof(n = read(e, "binary"))), n)
                    }, "undefined" != typeof scriptArgs && scriptArgs, "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (d || c) && (c ? y = self.location.href : document.currentScript && (y = document.currentScript.src), u && (y = u), y = 0 !== y.indexOf("blob:") ? y.substr(0, y.lastIndexOf("/") + 1) : "", m = function(e) {
                        var n = new XMLHttpRequest;
                        return n.open("GET", e, !1), n.send(null), n.responseText
                    }, c && (f = function(e) {
                        var n = new XMLHttpRequest;
                        return n.open("GET", e, !1), n.responseType = "arraybuffer", n.send(null), new Uint8Array(n.response)
                    }));
                    var g, w, _ = r.print || console.log.bind(console),
                        I = r.printErr || console.warn.bind(console);
                    for (a in o) o.hasOwnProperty(a) && (r[a] = o[a]);
                    o = null, r.arguments && r.arguments, r.thisProgram && r.thisProgram, r.quit && r.quit, r.wasmBinary && (g = r.wasmBinary), r.noExitRuntime && r.noExitRuntime, "object" != typeof WebAssembly && I("no native wasm support detected");
                    var k = new WebAssembly.Table({
                            initial: 146,
                            maximum: 146,
                            element: "anyfunc"
                        }),
                        v = !1;

                    function M(e, n) {
                        e || $("Assertion failed: " + n)
                    }

                    function A(e) {
                        var n = r["_" + e];
                        return M(n, "Cannot call unknown function " + e + ", make sure it is exported"), n
                    }

                    function S(e, n, t, a, r) {
                        var u = {
                                string: function(e) {
                                    var n = 0;
                                    if (null != e && 0 !== e) {
                                        var t = 1 + (e.length << 2);
                                        ! function(e, n, t) {
                                            (function(e, n, t, a) {
                                                if (!(a > 0)) return 0;
                                                for (var r = t, u = t + a - 1, i = 0; i < e.length; ++i) {
                                                    var s = e.charCodeAt(i);
                                                    if (s >= 55296 && s <= 57343 && (s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++i)), s <= 127) {
                                                        if (t >= u) break;
                                                        n[t++] = s
                                                    } else if (s <= 2047) {
                                                        if (t + 1 >= u) break;
                                                        n[t++] = 192 | s >> 6, n[t++] = 128 | 63 & s
                                                    } else if (s <= 65535) {
                                                        if (t + 2 >= u) break;
                                                        n[t++] = 224 | s >> 12, n[t++] = 128 | s >> 6 & 63, n[t++] = 128 | 63 & s
                                                    } else {
                                                        if (t + 3 >= u) break;
                                                        n[t++] = 240 | s >> 18, n[t++] = 128 | s >> 12 & 63, n[t++] = 128 | s >> 6 & 63, n[t++] = 128 | 63 & s
                                                    }
                                                }
                                                n[t] = 0
                                            })(e, D, n, t)
                                        }(e, n = oe(t), t)
                                    }
                                    return n
                                },
                                array: function(e) {
                                    var n = oe(e.length);
                                    return function(e, n) {
                                        R.set(e, n)
                                    }(e, n), n
                                }
                            },
                            i = A(e),
                            s = [],
                            o = 0;
                        if (a)
                            for (var l = 0; l < a.length; l++) {
                                var p = u[t[l]];
                                p ? (0 === o && (o = se()), s[l] = p(a[l])) : s[l] = a[l]
                            }
                        var d = i.apply(null, s);
                        return d = function(e) {
                            return "string" === n ? N(e) : "boolean" === n ? Boolean(e) : e
                        }(d), 0 !== o && le(o), d
                    }
                    var F = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

                    function x(e, n, t) {
                        for (var a = n + t, r = n; e[r] && !(r >= a);) ++r;
                        if (r - n > 16 && e.subarray && F) return F.decode(e.subarray(n, r));
                        for (var u = ""; n < r;) {
                            var i = e[n++];
                            if (128 & i) {
                                var s = 63 & e[n++];
                                if (192 != (224 & i)) {
                                    var o = 63 & e[n++];
                                    if ((i = 224 == (240 & i) ? (15 & i) << 12 | s << 6 | o : (7 & i) << 18 | s << 12 | o << 6 | 63 & e[n++]) < 65536) u += String.fromCharCode(i);
                                    else {
                                        var l = i - 65536;
                                        u += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l)
                                    }
                                } else u += String.fromCharCode((31 & i) << 6 | s)
                            } else u += String.fromCharCode(i)
                        }
                        return u
                    }

                    function N(e, n) {
                        return e ? x(D, e, n) : ""
                    }
                    var C, R, D, E;

                    function O(e, n) {
                        return e % n > 0 && (e += n - e % n), e
                    }

                    function P(e) {
                        C = e, r.HEAP8 = R = new Int8Array(e), r.HEAP16 = new Int16Array(e), r.HEAP32 = E = new Int32Array(e), r.HEAPU8 = D = new Uint8Array(e), r.HEAPU16 = new Uint16Array(e), r.HEAPU32 = new Uint32Array(e), r.HEAPF32 = new Float32Array(e), r.HEAPF64 = new Float64Array(e)
                    }
                    var W = r.INITIAL_MEMORY || 16777216;

                    function z(e) {
                        for (; e.length > 0;) {
                            var n = e.shift();
                            if ("function" != typeof n) {
                                var t = n.func;
                                "number" == typeof t ? void 0 === n.arg ? r.dynCall_v(t) : r.dynCall_vi(t, n.arg) : t(void 0 === n.arg ? null : n.arg)
                            } else n(r)
                        }
                    }(w = r.wasmMemory ? r.wasmMemory : new WebAssembly.Memory({
                        initial: W / 65536,
                        maximum: 32768
                    })) && (C = w.buffer), W = C.byteLength, P(C), E[2940] = 5254800;
                    var H = [],
                        T = [],
                        U = [],
                        B = [];
                    var V = Math.ceil,
                        q = Math.floor,
                        L = 0,
                        j = null,
                        G = null;

                    function $(e) {
                        throw r.onAbort && r.onAbort(e), _(e += ""), I(e), v = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e)
                    }

                    function K(e, n) {
                        return String.prototype.startsWith ? e.startsWith(n) : 0 === e.indexOf(n)
                    }
                    r.preloadedImages = {}, r.preloadedAudios = {};
                    var X = "data:application/octet-stream;base64,";

                    function Y(e) {
                        return K(e, X)
                    }
                    var Z = "file://";

                    function J(e) {
                        return K(e, Z)
                    }
                    var Q = "tfjs-backend-wasm.wasm";

                    function ee() {
                        try {
                            if (g) return new Uint8Array(g);
                            if (f) return f(Q);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (e) {
                            $(e)
                        }
                    }

                    function ne(e) {
                        try {
                            return w.grow(e - C.byteLength + 65535 >>> 16), P(w.buffer), 1
                        } catch (e) {}
                    }
                    Y(Q) || (Q = function(e) {
                        return r.locateFile ? r.locateFile(e, y) : y + e
                    }(Q)), T.push({
                        func: function() {
                            ie()
                        }
                    });
                    var te = {
                        mappings: {},
                        buffers: [null, [],
                            []
                        ],
                        printChar: function(e, n) {
                            var t = te.buffers[e];
                            0 === n || 10 === n ? ((1 === e ? _ : I)(x(t, 0)), t.length = 0) : t.push(n)
                        },
                        varargs: void 0,
                        get: function() {
                            return te.varargs += 4, E[te.varargs - 4 >> 2]
                        },
                        getStr: function(e) {
                            return N(e)
                        },
                        get64: function(e, n) {
                            return e
                        }
                    };
                    var ae = {
                            a: function() {
                                $()
                            },
                            e: function(e, n, t) {
                                D.copyWithin(e, n, n + t)
                            },
                            f: function(e) {
                                e >>>= 0;
                                var n = D.length;
                                if (e > 2147483648) return !1;
                                for (var t = 1; t <= 4; t *= 2) {
                                    var a = n * (1 + .2 / t);
                                    if (a = Math.min(a, e + 100663296), ne(Math.min(2147483648, O(Math.max(16777216, e, a), 65536)))) return !0
                                }
                                return !1
                            },
                            g: function(e) {
                                return 0
                            },
                            d: function(e, n, t, a, r) {},
                            c: function(e, n, t, a) {
                                for (var r = 0, u = 0; u < t; u++) {
                                    for (var i = E[n + 8 * u >> 2], s = E[n + (8 * u + 4) >> 2], o = 0; o < s; o++) te.printChar(e, D[i + o]);
                                    r += s
                                }
                                return E[a >> 2] = r, 0
                            },
                            memory: w,
                            b: function(e) {
                                return (e = +e) >= 0 ? +q(e + .5) : +V(e - .5)
                            },
                            table: k
                        },
                        re = function() {
                            var e = {
                                a: ae
                            };

                            function n(e, n) {
                                var t = e.exports;
                                r.asm = t,
                                    function(e) {
                                        if (L--, r.monitorRunDependencies && r.monitorRunDependencies(L), 0 == L && (null !== j && (clearInterval(j), j = null), G)) {
                                            var n = G;
                                            G = null, n()
                                        }
                                    }()
                            }

                            function t(e) {
                                n(e.instance)
                            }

                            function a(n) {
                                return (g || !d && !c || "function" != typeof fetch || J(Q) ? new Promise(function(e, n) {
                                    e(ee())
                                }) : fetch(Q, {
                                    credentials: "same-origin"
                                }).then(function(e) {
                                    if (!e.ok) throw "failed to load wasm binary file at '" + Q + "'";
                                    return e.arrayBuffer()
                                }).catch(function() {
                                    return ee()
                                })).then(function(n) {
                                    return WebAssembly.instantiate(n, e)
                                }).then(n, function(e) {
                                    I("failed to asynchronously prepare wasm: " + e), $(e)
                                })
                            }
                            if (L++, r.monitorRunDependencies && r.monitorRunDependencies(L), r.instantiateWasm) try {
                                return r.instantiateWasm(e, n)
                            } catch (e) {
                                return I("Module.instantiateWasm callback failed with error: " + e), !1
                            }
                            return function() {
                                if (g || "function" != typeof WebAssembly.instantiateStreaming || Y(Q) || J(Q) || "function" != typeof fetch) return a(t);
                                fetch(Q, {
                                    credentials: "same-origin"
                                }).then(function(n) {
                                    return WebAssembly.instantiateStreaming(n, e).then(t, function(e) {
                                        I("wasm streaming compile failed: " + e), I("falling back to ArrayBuffer instantiation"), a(t)
                                    })
                                })
                            }(), {}
                        }();
                    r.asm = re;
                    var ue, ie = r.___wasm_call_ctors = function() {
                            return (ie = r.___wasm_call_ctors = r.asm.h).apply(null, arguments)
                        },
                        se = (r._init = function() {
                            return (r._init = r.asm.i).apply(null, arguments)
                        }, r._register_tensor = function() {
                            return (r._register_tensor = r.asm.j).apply(null, arguments)
                        }, r._dispose_data = function() {
                            return (r._dispose_data = r.asm.k).apply(null, arguments)
                        }, r._dispose = function() {
                            return (r._dispose = r.asm.l).apply(null, arguments)
                        }, r._Abs = function() {
                            return (r._Abs = r.asm.m).apply(null, arguments)
                        }, r._Add = function() {
                            return (r._Add = r.asm.n).apply(null, arguments)
                        }, r._AddN = function() {
                            return (r._AddN = r.asm.o).apply(null, arguments)
                        }, r._ArgMax = function() {
                            return (r._ArgMax = r.asm.p).apply(null, arguments)
                        }, r._AvgPool = function() {
                            return (r._AvgPool = r.asm.q).apply(null, arguments)
                        }, r._BatchMatMul = function() {
                            return (r._BatchMatMul = r.asm.r).apply(null, arguments)
                        }, r._ClipByValue = function() {
                            return (r._ClipByValue = r.asm.s).apply(null, arguments)
                        }, r._Conv2D = function() {
                            return (r._Conv2D = r.asm.t).apply(null, arguments)
                        }, r._Conv2DBackpropInput = function() {
                            return (r._Conv2DBackpropInput = r.asm.u).apply(null, arguments)
                        }, r._Cos = function() {
                            return (r._Cos = r.asm.v).apply(null, arguments)
                        }, r._CropAndResize = function() {
                            return (r._CropAndResize = r.asm.w).apply(null, arguments)
                        }, r._DepthwiseConv2dNative = function() {
                            return (r._DepthwiseConv2dNative = r.asm.x).apply(null, arguments)
                        }, r._Div = function() {
                            return (r._Div = r.asm.y).apply(null, arguments)
                        }, r._Equal = function() {
                            return (r._Equal = r.asm.z).apply(null, arguments)
                        }, r._Exp = function() {
                            return (r._Exp = r.asm.A).apply(null, arguments)
                        }, r._FloorDiv = function() {
                            return (r._FloorDiv = r.asm.B).apply(null, arguments)
                        }, r._FusedBatchNorm = function() {
                            return (r._FusedBatchNorm = r.asm.C).apply(null, arguments)
                        }, r._FusedConv2D = function() {
                            return (r._FusedConv2D = r.asm.D).apply(null, arguments)
                        }, r._FusedDepthwiseConv2D = function() {
                            return (r._FusedDepthwiseConv2D = r.asm.E).apply(null, arguments)
                        }, r._Gather = function() {
                            return (r._Gather = r.asm.F).apply(null, arguments)
                        }, r._GatherNd = function() {
                            return (r._GatherNd = r.asm.G).apply(null, arguments)
                        }, r._Greater = function() {
                            return (r._Greater = r.asm.H).apply(null, arguments)
                        }, r._GreaterEqual = function() {
                            return (r._GreaterEqual = r.asm.I).apply(null, arguments)
                        }, r._Less = function() {
                            return (r._Less = r.asm.J).apply(null, arguments)
                        }, r._LessEqual = function() {
                            return (r._LessEqual = r.asm.K).apply(null, arguments)
                        }, r._Log = function() {
                            return (r._Log = r.asm.L).apply(null, arguments)
                        }, r._LogicalAnd = function() {
                            return (r._LogicalAnd = r.asm.M).apply(null, arguments)
                        }, r._Max = function() {
                            return (r._Max = r.asm.N).apply(null, arguments)
                        }, r._MaxPool = function() {
                            return (r._MaxPool = r.asm.O).apply(null, arguments)
                        }, r._Maximum = function() {
                            return (r._Maximum = r.asm.P).apply(null, arguments)
                        }, r._Min = function() {
                            return (r._Min = r.asm.Q).apply(null, arguments)
                        }, r._Minimum = function() {
                            return (r._Minimum = r.asm.R).apply(null, arguments)
                        }, r._Multiply = function() {
                            return (r._Multiply = r.asm.S).apply(null, arguments)
                        }, r._Negate = function() {
                            return (r._Negate = r.asm.T).apply(null, arguments)
                        }, r._NonMaxSuppressionV3 = function() {
                            return (r._NonMaxSuppressionV3 = r.asm.U).apply(null, arguments)
                        }, r._NonMaxSuppressionV4 = function() {
                            return (r._NonMaxSuppressionV4 = r.asm.V).apply(null, arguments)
                        }, r._NonMaxSuppressionV5 = function() {
                            return (r._NonMaxSuppressionV5 = r.asm.W).apply(null, arguments)
                        }, r._NotEqual = function() {
                            return (r._NotEqual = r.asm.X).apply(null, arguments)
                        }, r._OneHot = function() {
                            return (r._OneHot = r.asm.Y).apply(null, arguments)
                        }, r._PadV2 = function() {
                            return (r._PadV2 = r.asm.Z).apply(null, arguments)
                        }, r._Pow = function() {
                            return (r._Pow = r.asm._).apply(null, arguments)
                        }, r._Prelu = function() {
                            return (r._Prelu = r.asm.$).apply(null, arguments)
                        }, r._Relu = function() {
                            return (r._Relu = r.asm.aa).apply(null, arguments)
                        }, r._Relu6 = function() {
                            return (r._Relu6 = r.asm.ba).apply(null, arguments)
                        }, r._ResizeBilinear = function() {
                            return (r._ResizeBilinear = r.asm.ca).apply(null, arguments)
                        }, r._Reverse = function() {
                            return (r._Reverse = r.asm.da).apply(null, arguments)
                        }, r._RotateWithOffset = function() {
                            return (r._RotateWithOffset = r.asm.ea).apply(null, arguments)
                        }, r._Rsqrt = function() {
                            return (r._Rsqrt = r.asm.fa).apply(null, arguments)
                        }, r._ScatterNd = function() {
                            return (r._ScatterNd = r.asm.ga).apply(null, arguments)
                        }, r._SelectV2 = function() {
                            return (r._SelectV2 = r.asm.ha).apply(null, arguments)
                        }, r._Sigmoid = function() {
                            return (r._Sigmoid = r.asm.ia).apply(null, arguments)
                        }, r._Sin = function() {
                            return (r._Sin = r.asm.ja).apply(null, arguments)
                        }, r._Softmax = function() {
                            return (r._Softmax = r.asm.ka).apply(null, arguments)
                        }, r._Sqrt = function() {
                            return (r._Sqrt = r.asm.la).apply(null, arguments)
                        }, r._Square = function() {
                            return (r._Square = r.asm.ma).apply(null, arguments)
                        }, r._Sub = function() {
                            return (r._Sub = r.asm.na).apply(null, arguments)
                        }, r._Sum = function() {
                            return (r._Sum = r.asm.oa).apply(null, arguments)
                        }, r._Tanh = function() {
                            return (r._Tanh = r.asm.pa).apply(null, arguments)
                        }, r._Tile = function() {
                            return (r._Tile = r.asm.qa).apply(null, arguments)
                        }, r._Transpose = function() {
                            return (r._Transpose = r.asm.ra).apply(null, arguments)
                        }, r.__FusedMatMul = function() {
                            return (r.__FusedMatMul = r.asm.sa).apply(null, arguments)
                        }, r._malloc = function() {
                            return (r._malloc = r.asm.ta).apply(null, arguments)
                        }, r._free = function() {
                            return (r._free = r.asm.ua).apply(null, arguments)
                        }, r.stackSave = function() {
                            return (se = r.stackSave = r.asm.va).apply(null, arguments)
                        }),
                        oe = r.stackAlloc = function() {
                            return (oe = r.stackAlloc = r.asm.wa).apply(null, arguments)
                        },
                        le = r.stackRestore = function() {
                            return (le = r.stackRestore = r.asm.xa).apply(null, arguments)
                        };

                    function pe(e) {
                        function n() {
                            ue || (ue = !0, r.calledRun = !0, v || (z(T), z(U), r.onRuntimeInitialized && r.onRuntimeInitialized(), function() {
                                if (r.postRun)
                                    for ("function" == typeof r.postRun && (r.postRun = [r.postRun]); r.postRun.length;) e = r.postRun.shift(), B.unshift(e);
                                var e;
                                z(B)
                            }()))
                        }
                        L > 0 || (function() {
                            if (r.preRun)
                                for ("function" == typeof r.preRun && (r.preRun = [r.preRun]); r.preRun.length;) e = r.preRun.shift(), H.unshift(e);
                            var e;
                            z(H)
                        }(), L > 0 || (r.setStatus ? (r.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                r.setStatus("")
                            }, 1), n()
                        }, 1)) : n()))
                    }
                    if (r.dynCall_vi = function() {
                            return (r.dynCall_vi = r.asm.ya).apply(null, arguments)
                        }, r.dynCall_v = function() {
                            return (r.dynCall_v = r.asm.za).apply(null, arguments)
                        }, r.asm = re, r.cwrap = function(e, n, t, a) {
                            var r = (t = t || []).every(function(e) {
                                return "number" === e
                            });
                            return "string" !== n && r && !a ? A(e) : function() {
                                return S(e, n, t, arguments)
                            }
                        }, r.then = function(e) {
                            if (ue) e(r);
                            else {
                                var n = r.onRuntimeInitialized;
                                r.onRuntimeInitialized = function() {
                                    n && n(), e(r)
                                }
                            }
                            return r
                        }, G = function e() {
                            ue || pe(), ue || (G = e)
                        }, r.run = pe, r.preInit)
                        for ("function" == typeof r.preInit && (r.preInit = [r.preInit]); r.preInit.length > 0;) r.preInit.pop()();
                    return pe(), e
                });
                a.exports = o
            });
        class ge extends u.KernelBackend {
            constructor(e) {
                super(), this.wasm = e, this.dataIdNextNumber = 1, this.wasm.tfjs.init(), this.dataIdMap = new u.DataStorage(this, (0, u.engine)())
            }
            write(e, n, t) {
                const a = {};
                return this.move(a, e, n, t), a
            }
            numDataIds() {
                return this.dataIdMap.numDataIds()
            }
            async time(e) {
                const n = u.util.now();
                return e(), {
                    kernelMs: u.util.now() - n
                }
            }
            move(e, n, t, a) {
                const r = this.dataIdNextNumber++;
                if ("string" === a) {
                    const u = n;
                    return void this.dataIdMap.set(e, {
                        id: r,
                        stringBytes: u,
                        shape: t,
                        dtype: a,
                        memoryOffset: null
                    })
                }
                const i = u.util.sizeFromShape(t),
                    s = i * u.util.bytesPerElement(a),
                    o = this.wasm._malloc(s);
                this.dataIdMap.set(e, {
                    id: r,
                    memoryOffset: o,
                    shape: t,
                    dtype: a
                }), this.wasm.tfjs.registerTensor(r, i, o), null != n && this.wasm.HEAPU8.set(new Uint8Array(n.buffer, n.byteOffset, s), o)
            }
            async read(e) {
                return this.readSync(e)
            }
            readSync(e) {
                const {
                    memoryOffset: n,
                    dtype: t,
                    shape: a,
                    stringBytes: r
                } = this.dataIdMap.get(e);
                return "string" === t ? r : function(e, n) {
                    switch (n) {
                        case "float32":
                            return new Float32Array(e);
                        case "int32":
                            return new Int32Array(e);
                        case "bool":
                            return new Uint8Array(e);
                        default:
                            throw new Error(`Unknown dtype ${n}`)
                    }
                }(this.wasm.HEAPU8.slice(n, n + u.util.sizeFromShape(a) * u.util.bytesPerElement(t)).buffer, t)
            }
            disposeData(e) {
                const n = this.dataIdMap.get(e);
                this.wasm._free(n.memoryOffset), this.wasm.tfjs.disposeData(n.id), this.dataIdMap.delete(e)
            }
            floatPrecision() {
                return 32
            }
            getMemoryOffset(e) {
                return this.dataIdMap.get(e).memoryOffset
            }
            dispose() {
                this.wasm.tfjs.dispose(), this.wasm = null
            }
            memory() {
                return {
                    unreliable: !1
                }
            }
            makeOutput(e, n, t) {
                let a;
                if (null == t) a = this.write(null, e, n);
                else {
                    a = {};
                    const r = this.dataIdNextNumber++;
                    this.dataIdMap.set(a, {
                        id: r,
                        memoryOffset: t,
                        shape: e,
                        dtype: n
                    });
                    const i = u.util.sizeFromShape(e);
                    this.wasm.tfjs.registerTensor(r, i, t)
                }
                return {
                    dataId: a,
                    shape: e,
                    dtype: n
                }
            }
            typedArrayFromHeap({
                shape: e,
                dtype: n,
                dataId: t
            }) {
                const a = this.wasm.HEAPU8.buffer,
                    {
                        memoryOffset: r
                    } = this.dataIdMap.get(t),
                    i = u.util.sizeFromShape(e);
                switch (n) {
                    case "float32":
                        return new Float32Array(a, r, i);
                    case "int32":
                        return new Int32Array(a, r, i);
                    case "bool":
                        return new Uint8Array(a, r, i);
                    default:
                        throw new Error(`Uknown dtype ${n}`)
                }
            }
        }
        exports.BackendWasm = ge, (0, u.registerBackend)("wasm", async () => {
            const {
                wasm: e
            } = await async function() {
                const e = await (0, u.env)().getAsync("WASM_HAS_SIMD_SUPPORT");
                return new Promise((n, t) => {
                    const a = {};
                    null != we && (a.locateFile = ((e, n) => e.endsWith(".wasm") ? we : n + e), Ie && (a.instantiateWasm = function(e) {
                        return (n, t) => (u.util.fetch(e, {
                            credentials: "same-origin"
                        }).then(a => {
                            a.ok || n.env.a(`failed to load wasm binary file at '${e}'`), a.arrayBuffer().then(e => {
                                WebAssembly.instantiate(e, n).then(e => {
                                    t(e.instance)
                                })
                            })
                        }), {})
                    }(we)));
                    const r = e ? he(a) : ye(a);
                    r.tfjs = {
                        init: r.cwrap("init", null, []),
                        registerTensor: r.cwrap("register_tensor", null, ["number", "number", "number"]),
                        disposeData: r.cwrap("dispose_data", null, ["number"]),
                        dispose: r.cwrap("dispose", null, [])
                    };
                    let i = !1;
                    r.onRuntimeInitialized = (() => {
                        i = !0, _e = !1, n({
                            wasm: r
                        })
                    }), r.onAbort = (() => {
                        i || _e || (_e = !0, t({
                            message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"
                        }))
                    })
                })
            }();
            return new ge(e)
        }, 2);
        let we = null,
            _e = !1,
            Ie = !1;

        function ke(e, n = !1) {
            if (_e) throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
            we = e, Ie = n
        }
        const ve = "2.1.0";
        exports.version_wasm = ve;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "path": "sC8V",
        "fs": "sC8V",
        "process": "g5IB"
    }],
    "S11S": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.setWebGLContext = n, exports.getWebGLContext = a;
        const e = {},
            t = {
                alpha: !1,
                antialias: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                depth: !1,
                stencil: !1,
                failIfMajorPerformanceCaveat: !0
            };

        function n(t, n) {
            e[t] = n
        }

        function a(t) {
            t in e || (e[t] = o(t));
            const n = e[t];
            return n.isContextLost() ? (delete e[t], a(t)) : (n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), e[t])
        }

        function r(e) {
            if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
            if ("undefined" != typeof document) return document.createElement("canvas");
            throw new Error("Cannot create a canvas in this context")
        }

        function o(n) {
            if (1 !== n && 2 !== n) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
            const a = r(n);
            return a.addEventListener("webglcontextlost", t => {
                t.preventDefault(), delete e[n]
            }, !1), 1 === n ? a.getContext("webgl", t) || a.getContext("experimental-webgl", t) : a.getContext("webgl2", t)
        }
    }, {}],
    "hBHG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getUnpackedMatrixTextureShapeWidthHeight = a, exports.getUnpackedArraySizeFromMatrixSize = n, exports.getColorMatrixTextureShapeWidthHeight = i, exports.getDenseTexShape = u, exports.getMatrixSizeFromUnpackedArraySize = l, exports.decodeMatrixFromUnpackedColorRGBAArray = A, exports.getPackedMatrixTextureShapeWidthHeight = x, exports.getPackedRGBAArraySizeFromMatrixShape = c, exports.getTextureConfig = s, exports.PhysicalTextureType = exports.TextureUsage = exports.PackingScheme = void 0;
        var e, t, r, o = require("@tensorflow/tfjs-core");

        function a(e, t) {
            return [t, e]
        }

        function n(e, t) {
            return e * t
        }

        function i(e, t) {
            return [4 * t, e]
        }

        function u(e) {
            const t = o.util.sizeFromShape(e),
                r = Math.ceil(t / 4);
            return o.util.sizeToSquarishShape(r)
        }

        function l(e, t) {
            if (e % t != 0) throw new Error(`unpackedSize (${e}) must be a multiple of ` + `${t}`);
            return e / t
        }

        function A(e, t, r) {
            const o = e.length * r / 4;
            if (t.length < o) throw new Error(`matrix length (${t.length}) must be >= ${o}`);
            let a = 0;
            for (let n = 0; n < e.length; n += 4)
                for (let o = 0; o < r; o++) t[a++] = e[n + o]
        }

        function x(e, t) {
            return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))]
        }

        function c(e, t) {
            const [r, o] = x(e, t);
            return r * o * 4
        }

        function s(e, t) {
            const r = e;
            let a, n, i, u, l, A, x, c, s, p;
            return 2 === (0, o.env)().getNumber("WEBGL_VERSION") ? (a = r.R32F, n = r.R16F, i = r.RGBA16F, u = r.RGBA32F, l = r.RED, x = 4, c = 1, s = r.HALF_FLOAT, p = r.FLOAT) : (a = e.RGBA, n = e.RGBA, i = e.RGBA, u = r.RGBA, l = e.RGBA, x = 4, c = 4, s = null != t ? t.HALF_FLOAT_OES : null, p = e.FLOAT), {
                internalFormatFloat: a,
                internalFormatHalfFloat: n,
                internalFormatPackedHalfFloat: i,
                internalFormatPackedFloat: u,
                textureFormatFloat: l,
                downloadTextureFormat: A = e.RGBA,
                downloadUnpackNumChannels: x,
                defaultNumChannels: c,
                textureTypeHalfFloat: s,
                textureTypeFloat: p
            }
        }
        exports.PackingScheme = e,
            function(e) {
                e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH"
            }(e || (exports.PackingScheme = e = {})), exports.TextureUsage = t,
            function(e) {
                e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD"
            }(t || (exports.TextureUsage = t = {})), exports.PhysicalTextureType = r,
            function(e) {
                e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
            }(r || (exports.PhysicalTextureType = r = {}));
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "p3g2": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.callAndCheck = n, exports.canBeRepresented = i, exports.getWebGLErrorMessage = E, exports.getExtensionOrThrow = f, exports.createVertexShader = l, exports.createFragmentShader = s, exports.createProgram = F, exports.linkProgram = R, exports.validateProgram = g, exports.createStaticVertexBuffer = x, exports.createStaticIndexBuffer = _, exports.getNumChannels = b, exports.createTexture = h, exports.validateTextureSize = A, exports.createFramebuffer = m, exports.bindVertexBufferToProgramAttribute = d, exports.bindTextureUnit = U, exports.unbindTextureUnit = M, exports.getProgramUniformLocationOrThrow = p, exports.getProgramUniformLocation = L, exports.bindTextureToProgramUniformSampler = S, exports.bindCanvasToFramebuffer = I, exports.bindColorTextureToFramebuffer = O, exports.unbindColorTextureFromFramebuffer = B, exports.validateFramebuffer = N, exports.getFramebufferErrorMessage = C, exports.getBatchDim = w, exports.getRowsCols = X, exports.getShapeAs3D = G, exports.getTextureShapeFromLogicalShape = W, exports.isReshapeFree = V, exports.getWebGLMaxTextureSize = $, exports.resetMaxTextureSize = q, exports.resetMaxTexturesInShader = k, exports.getMaxTexturesInShader = z, exports.getWebGLDisjointQueryTimerVersion = j, exports.hasExtension = Y, exports.isWebGLVersionEnabled = Z, exports.isCapableOfRenderingToFloatTexture = K, exports.isDownloadFloatTextureEnabled = Q, exports.isWebGLFenceEnabled = re;
        var e = require("@tensorflow/tfjs-core"),
            r = require("./canvas_util"),
            t = require("./tex_util");

        function n(r, t) {
            const n = t();
            return (0, e.env)().getBool("DEBUG") && o(r), n
        }

        function o(e) {
            const r = e.getError();
            if (r !== e.NO_ERROR) throw new Error("WebGL Error: " + E(e, r))
        }
        const u = 5.96e-8,
            a = 65504;

        function i(r) {
            return !!((0, e.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === r || u < Math.abs(r) && Math.abs(r) < a)
        }

        function E(e, r) {
            switch (r) {
                case e.NO_ERROR:
                    return "NO_ERROR";
                case e.INVALID_ENUM:
                    return "INVALID_ENUM";
                case e.INVALID_VALUE:
                    return "INVALID_VALUE";
                case e.INVALID_OPERATION:
                    return "INVALID_OPERATION";
                case e.INVALID_FRAMEBUFFER_OPERATION:
                    return "INVALID_FRAMEBUFFER_OPERATION";
                case e.OUT_OF_MEMORY:
                    return "OUT_OF_MEMORY";
                case e.CONTEXT_LOST_WEBGL:
                    return "CONTEXT_LOST_WEBGL";
                default:
                    return `Unknown error code ${r}`
            }
        }

        function f(e, r) {
            return D(e, () => e.getExtension(r), 'Extension "' + r + '" not supported on this browser.')
        }

        function l(e, r) {
            const t = D(e, () => e.createShader(e.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
            if (n(e, () => e.shaderSource(t, r)), n(e, () => e.compileShader(t)), !1 === e.getShaderParameter(t, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(t)), new Error("Failed to compile vertex shader.");
            return t
        }

        function s(e, r) {
            const t = D(e, () => e.createShader(e.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
            if (n(e, () => e.shaderSource(t, r)), n(e, () => e.compileShader(t)), !1 === e.getShaderParameter(t, e.COMPILE_STATUS)) throw T(r, e.getShaderInfoLog(t)), new Error("Failed to compile fragment shader.");
            return t
        }
        const c = /ERROR: [0-9]+:([0-9]+):/g;

        function T(r, t) {
            const n = c.exec(t);
            if (null == n) return console.log(`Couldn't parse line number in error: ${t}`), void console.log(r);
            const o = +n[1],
                u = r.split("\n"),
                a = u.length.toString().length + 2,
                i = u.map((r, t) => e.util.rightPad((t + 1).toString(), a) + r);
            let E = 0;
            for (let e = 0; e < i.length; e++) E = Math.max(i[e].length, E);
            const f = i.slice(0, o - 1),
                l = i.slice(o - 1, o),
                s = i.slice(o);
            console.log(f.join("\n")), console.log(t.split("\n")[0]), console.log(`%c ${e.util.rightPad(l[0],E)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(s.join("\n"))
        }

        function F(e) {
            return D(e, () => e.createProgram(), "Unable to create WebGLProgram.")
        }

        function R(e, r) {
            if (n(e, () => e.linkProgram(r)), !1 === e.getProgramParameter(r, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(r)), new Error("Failed to link vertex and fragment shaders.")
        }

        function g(e, r) {
            if (n(e, () => e.validateProgram(r)), !1 === e.getProgramParameter(r, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(r)), new Error("Shader program validation failed.")
        }

        function x(e, r) {
            const t = D(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
            return n(e, () => e.bindBuffer(e.ARRAY_BUFFER, t)), n(e, () => e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW)), t
        }

        function _(e, r) {
            const t = D(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
            return n(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t)), n(e, () => e.bufferData(e.ELEMENT_ARRAY_BUFFER, r, e.STATIC_DRAW)), t
        }

        function b() {
            return 2 === (0, e.env)().getNumber("WEBGL_VERSION") ? 1 : 4
        }

        function h(e) {
            return D(e, () => e.createTexture(), "Unable to create WebGLTexture.")
        }

        function A(r, t) {
            const n = (0, e.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");
            if (r <= 0 || t <= 0) {
                throw new Error("Requested texture size " + `[${r}x${t}]` + " is invalid.")
            }
            if (r > n || t > n) {
                throw new Error("Requested texture size " + `[${r}x${t}]` + " greater than WebGL maximum on this browser / GPU " + `[${n}x${n}]` + ".")
            }
        }

        function m(e) {
            return D(e, () => e.createFramebuffer(), "Unable to create WebGLFramebuffer.")
        }

        function d(e, r, t, o, u, a, i) {
            const E = e.getAttribLocation(r, t);
            return -1 !== E && (n(e, () => e.bindBuffer(e.ARRAY_BUFFER, o)), n(e, () => e.vertexAttribPointer(E, u, e.FLOAT, !1, a, i)), n(e, () => e.enableVertexAttribArray(E)), !0)
        }

        function U(e, r, t) {
            P(e, t), n(e, () => e.activeTexture(e.TEXTURE0 + t)), n(e, () => e.bindTexture(e.TEXTURE_2D, r))
        }

        function M(e, r) {
            P(e, r), n(e, () => e.activeTexture(e.TEXTURE0 + r)), n(e, () => e.bindTexture(e.TEXTURE_2D, null))
        }

        function p(e, r, t) {
            return D(e, () => e.getUniformLocation(r, t), 'uniform "' + t + '" not present in program.')
        }

        function L(e, r, t) {
            return e.getUniformLocation(r, t)
        }

        function S(e, r, t, o) {
            n(e, () => U(e, r, o)), n(e, () => e.uniform1i(t, o))
        }

        function I(e) {
            n(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), n(e, () => e.viewport(0, 0, e.canvas.width, e.canvas.height)), n(e, () => e.scissor(0, 0, e.canvas.width, e.canvas.height))
        }

        function O(e, r, t) {
            n(e, () => e.bindFramebuffer(e.FRAMEBUFFER, t)), n(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0))
        }

        function B(e, r) {
            n(e, () => e.bindFramebuffer(e.FRAMEBUFFER, r)), n(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0))
        }

        function N(e) {
            const r = e.checkFramebufferStatus(e.FRAMEBUFFER);
            if (r !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + C(e, r))
        }

        function C(e, r) {
            switch (r) {
                case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
                case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
                case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
                case e.FRAMEBUFFER_UNSUPPORTED:
                    return "FRAMEBUFFER_UNSUPPORTED";
                default:
                    return `unknown error ${r}`
            }
        }

        function D(e, r, t) {
            const o = n(e, () => r());
            if (null == o) throw new Error(t);
            return o
        }

        function P(e, r) {
            const t = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
                n = r + e.TEXTURE0;
            if (n < e.TEXTURE0 || n > t) {
                throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${t}]`}.`)
            }
        }

        function w(r, t = 2) {
            return e.util.sizeFromShape(r.slice(0, r.length - t))
        }

        function X(e) {
            if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
            return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]]
        }

        function G(e) {
            let r = [1, 1, 1];
            return 0 === e.length || 1 === e.length && 1 === e[0] || (r = [w(e), ...X(e)]), r
        }

        function W(r, t = !1) {
            let n = (0, e.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");
            if (t && (n *= 2, 1 === (r = r.map((t, n) => n >= r.length - 2 ? e.util.nearestLargerEven(r[n]) : r[n])).length && (r = [2, r[0]])), 2 !== r.length) {
                const t = e.util.squeezeShape(r);
                r = t.newShape
            }
            let o = e.util.sizeFromShape(r);
            if (r.length <= 1 && o <= n) return [1, o];
            if (2 === r.length && r[0] <= n && r[1] <= n) return r;
            if (3 === r.length && r[0] * r[1] <= n && r[2] <= n) return [r[0] * r[1], r[2]];
            if (3 === r.length && r[0] <= n && r[1] * r[2] <= n) return [r[0], r[1] * r[2]];
            if (4 === r.length && r[0] * r[1] * r[2] <= n && r[3] <= n) return [r[0] * r[1] * r[2], r[3]];
            if (4 === r.length && r[0] <= n && r[1] * r[2] * r[3] <= n) return [r[0], r[1] * r[2] * r[3]];
            if (t) {
                const t = w(r);
                let n = 2,
                    u = 2;
                return r.length && ([n, u] = X(r)), o = t * (n / 2) * (u / 2), e.util.sizeToSquarishShape(o).map(e => 2 * e)
            }
            return e.util.sizeToSquarishShape(o)
        }

        function v(e) {
            return e % 2 == 0
        }

        function V(r, t) {
            if (r = r.slice(-2), t = t.slice(-2), e.util.arraysEqual(r, t)) return !0;
            if (!r.length || !t.length) return !0;
            if (0 === r[0] || 0 === r[1] || 0 === t[0] || 0 === t[1]) return !0;
            if (r.length !== t.length) {
                const e = r.slice(-1)[0],
                    n = t.slice(-1)[0];
                if (e === n) return !0;
                if (v(e) && v(n) && (1 === r[0] || 1 === t[0])) return !0
            }
            return r[1] === t[1] && v(r[0]) && v(t[0])
        }
        let y, H;

        function $(e) {
            if (null == y) {
                const t = (0, r.getWebGLContext)(e);
                y = t.getParameter(t.MAX_TEXTURE_SIZE)
            }
            return y
        }

        function q() {
            y = null
        }

        function k() {
            H = null
        }

        function z(e) {
            if (null == H) {
                const t = (0, r.getWebGLContext)(e);
                H = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
            }
            return Math.min(16, H)
        }

        function j(e) {
            if (0 === e) return 0;
            let t;
            const n = (0, r.getWebGLContext)(e);
            return t = Y(n, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : Y(n, "EXT_disjoint_timer_query") ? 1 : 0
        }

        function Y(e, r) {
            return null != e.getExtension(r)
        }

        function Z(e) {
            try {
                if (null != (0, r.getWebGLContext)(e)) return !0
            } catch (t) {
                return !1
            }
            return !1
        }

        function K(e) {
            if (0 === e) return !1;
            const t = (0, r.getWebGLContext)(e);
            if (1 === e) {
                if (!Y(t, "OES_texture_float")) return !1
            } else if (!Y(t, "EXT_color_buffer_float")) return !1;
            return J(t)
        }

        function Q(e) {
            if (0 === e) return !1;
            const t = (0, r.getWebGLContext)(e);
            if (1 !== e) {
                if (Y(t, "EXT_color_buffer_float")) return J(t);
                const e = "EXT_color_buffer_half_float";
                if (Y(t, e)) {
                    const r = t.getExtension(e);
                    return ee(t, r)
                }
                return !1
            }
            return !!Y(t, "OES_texture_float") && (!!Y(t, "WEBGL_color_buffer_float") && J(t))
        }

        function J(e) {
            const r = (0, t.getTextureConfig)(e),
                n = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, n);
            e.texImage2D(e.TEXTURE_2D, 0, r.internalFormatFloat, 1, 1, 0, r.textureFormatFloat, r.textureTypeFloat, null);
            const o = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, o), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
            const u = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
            return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(o), u
        }

        function ee(e, r) {
            const n = (0, t.getTextureConfig)(e, r),
                o = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, o);
            e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
            const u = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, u), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, o, 0);
            const a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
            return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(o), e.deleteFramebuffer(u), a
        }

        function re(e) {
            if (2 !== e) return !1;
            return null != (0, r.getWebGLContext)(e).fenceSync
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./canvas_util": "S11S",
        "./tex_util": "hBHG"
    }],
    "YNu6": [function(require, module, exports) {
        "use strict";
        var E = require("@tensorflow/tfjs-core"),
            e = require("./webgl_util");
        const _ = (0, E.env)();
        _.registerFlag("HAS_WEBGL", () => _.getNumber("WEBGL_VERSION") > 0), _.registerFlag("WEBGL_VERSION", () => (0, e.isWebGLVersionEnabled)(2) ? 2 : (0, e.isWebGLVersionEnabled)(1) ? 1 : 0), _.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => !1), _.registerFlag("WEBGL_BUFFER_SUPPORTED", () => 2 === _.get("WEBGL_VERSION")), _.registerFlag("WEBGL_CPU_FORWARD", () => !0), _.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => !1), _.registerFlag("WEBGL_PACK", () => _.getBool("HAS_WEBGL")), _.registerFlag("WEBGL_PACK_NORMALIZATION", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_CLIP", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => !1), _.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_PACK_REDUCE", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_LAZILY_UNPACK", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_CONV_IM2COL", () => _.getBool("WEBGL_PACK")), _.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => (0, e.getWebGLMaxTextureSize)(_.getNumber("WEBGL_VERSION"))), _.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => (0, e.getMaxTexturesInShader)(_.getNumber("WEBGL_VERSION"))), _.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
            const E = _.getNumber("WEBGL_VERSION");
            return 0 === E ? 0 : (0, e.getWebGLDisjointQueryTimerVersion)(E)
        }), _.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => _.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !E.device_util.isMobile()), _.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => (0, e.isCapableOfRenderingToFloatTexture)(_.getNumber("WEBGL_VERSION"))), _.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => !_.getBool("WEBGL_FORCE_F16_TEXTURES") && _.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")), _.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => (0, e.isDownloadFloatTextureEnabled)(_.getNumber("WEBGL_VERSION"))), _.registerFlag("WEBGL_FENCE_API_ENABLED", () => (0, e.isWebGLFenceEnabled)(_.getNumber("WEBGL_VERSION"))), _.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
            return _.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
        }), _.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, E => {
            if (E < 0 && -1 !== E) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never " + `delete) or at least 0, but got ${E}.`)
        });
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./webgl_util": "p3g2"
    }],
    "DioZ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AddNProgram = void 0;
        class t {
            constructor(t, s) {
                this.outputShape = [], this.outputShape = t, this.variableNames = s.map((t, s) => `T${s}`);
                const e = [];
                this.variableNames.forEach(t => {
                    e.push(`float v${t} = get${t}AtOutCoords();`)
                });
                const o = this.variableNames.map(t => `v${t}`).join(" + ");
                this.userCode = `\n      void main() {\n        ${e.join("\n        ")}\n\n        float result = ${o};\n        setOutput(result);\n      }\n    `
            }
        }
        exports.AddNProgram = t;
    }, {}],
    "BmoR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AddNPackedProgram = void 0;
        class t {
            constructor(t, e) {
                this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map((t, e) => `T${e}`);
                const s = [];
                this.variableNames.forEach(t => {
                    s.push(`vec4 v${t} = get${t}AtOutCoords();`)
                });
                const a = this.variableNames.map(t => `v${t}`).join(" + ");
                this.userCode = `\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `
            }
        }
        exports.AddNPackedProgram = t;
    }, {}],
    "Pm0r": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ArgMinMaxProgram = void 0;
        class t {
            constructor(t, e, n) {
                this.variableNames = ["A"];
                const i = t.windowSize,
                    s = t.batchSize,
                    a = t.inSize,
                    o = Math.ceil(a / i);
                n || this.variableNames.push("bestIndicesA"), this.outputShape = [s, o];
                const d = "max" === e ? ">" : "<",
                    r = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
                this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${r};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${d} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `
            }
        }
        exports.ArgMinMaxProgram = t;
    }, {}],
    "Axn8": [function(require, module, exports) {
        "use strict";

        function e(e, t) {
            return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(t => `${e}.${t}`)
        }

        function t(t, r) {
            return 1 === r ? [t] : e(t, r)
        }

        function r(e, t) {
            if (1 === e) return "rc";
            let r = "";
            for (let n = 0; n < e; n++) r += t[n], n < e - 1 && (r += ",");
            return r
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getVecChannels = e, exports.getChannels = t, exports.getSourceCoords = r;
    }, {}],
    "QbWp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getGlslDifferences = e;
        var n = require("@tensorflow/tfjs-core");

        function e() {
            let e, a, t, u, l, v, o, r, i, s;
            return 2 === (0, n.env)().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", a = "in", t = "out", u = "in", l = "texture", v = "outputColor", o = "out vec4 outputColor;", r = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", i = "", s = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", a = "attribute", t = "varying", u = "varying", l = "texture2D", v = "gl_FragColor", o = "", r = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", i = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", s = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
                version: e,
                attribute: a,
                varyingVs: t,
                varyingFs: u,
                texture2D: l,
                output: v,
                defineOutput: o,
                defineSpecialNaN: r,
                defineSpecialInf: i,
                defineRound: s
            }
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "vOsJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getLogicalCoordinatesFromFlatIndex = e, exports.dotify = o, exports.getFlatIndexFrom3D = r, exports.ENCODE_FLOAT_SNIPPET = void 0;
        var n = require("@tensorflow/tfjs-core");

        function e(e, t, o = "index") {
            const r = n.util.computeStrides(t);
            return r.map((n, t) => {
                return `${`int ${e[t]} = ${o} / ${n}`}; ${t===r.length-1?`int ${e[t+1]} = ${o} - ${e[t]} * ${n}`:`index -= ${e[t]} * ${n}`};`
            }).join("")
        }

        function t(n) {
            return 1 === n.length ? `${n[0]}` : `vec${n.length}(${n.join(",")})`
        }

        function o(n, e) {
            if (n.length !== e.length) throw new Error("Vectors to be dotted must be of the same length -" + `got ${n.length} and ${e.length}`);
            const o = [],
                r = Math.floor(n.length / 4),
                c = n.length % 4;
            for (let l = 0; l < r; l++) {
                const r = n.slice(4 * l, 4 * l + 4),
                    c = e.slice(4 * l, 4 * l + 4);
                o.push(`${t(r)}, ${t(c)}`)
            }
            if (0 !== c) {
                let c = n.slice(4 * r),
                    l = e.slice(4 * r);
                1 === c.length && (c = c.map(n => `float(${n})`), l = l.map(n => `float(${n})`)), o.push(`${t(c)}, ${t(l)}`)
            }
            return o.map((n, e) => `dot(${n})`).join("+")
        }

        function r(e) {
            const t = n.util.computeStrides(e).map(n => n.toString());
            return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`
        }
        const c = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
        exports.ENCODE_FLOAT_SNIPPET = c;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "DIKY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.makeShader = c, exports.getCoordsDataType = W;
        var n = require("@tensorflow/tfjs-core"),
            e = require("./glsl_version"),
            t = o(require("./shader_compiler_util"));

        function r() {
            if ("function" != typeof WeakMap) return null;
            var n = new WeakMap;
            return r = function() {
                return n
            }, n
        }

        function o(n) {
            if (n && n.__esModule) return n;
            if (null === n || "object" != typeof n && "function" != typeof n) return {
                default: n
            };
            var e = r();
            if (e && e.has(n)) return e.get(n);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in n)
                if (Object.prototype.hasOwnProperty.call(n, i)) {
                    var c = o ? Object.getOwnPropertyDescriptor(n, i) : null;
                    c && (c.get || c.set) ? Object.defineProperty(t, i, c) : t[i] = n[i]
                } return t.default = n, e && e.set(n, t), t
        }
        const {
            getBroadcastDims: i
        } = n.backend_util;

        function c(t, r, o, i) {
            const c = [];
            t.forEach(e => {
                const t = n.util.sizeFromShape(e.shapeInfo.logicalShape);
                e.shapeInfo.isUniform ? c.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`) : (c.push(`uniform sampler2D ${e.name};`), c.push(`uniform int offset${e.name};`))
            });
            const u = c.join("\n"),
                l = t.map(n => a(n, r, i)).join("\n"),
                f = r.texShape,
                v = (0, e.getGlslDifferences)(),
                g = $(v);
            let m, w, R = x(v);
            return r.isPacked ? (m = s(r.logicalShape, f), w = h(v)) : (m = p(r.logicalShape, f), w = d(v)), i && (R += C), [R, g, w, u, m, l, o].join("\n")
        }

        function u(n) {
            const e = n.shapeInfo.logicalShape;
            switch (e.length) {
                case 0:
                    return N(n);
                case 1:
                    return k(n);
                case 2:
                    return j(n);
                case 3:
                    return E(n);
                case 4:
                    return L(n);
                case 5:
                    return P(n);
                case 6:
                    return _(n);
                default:
                    throw new Error(`${e.length}-D input sampling` + " is not yet supported")
            }
        }

        function l(n) {
            switch (n.shapeInfo.logicalShape.length) {
                case 0:
                    return M(n);
                case 1:
                    return F(n);
                case 2:
                    return A(n);
                case 3:
                    return z(n);
                default:
                    return q(n)
            }
        }

        function a(n, e, t = !1) {
            let r = "";
            r += t ? l(n) : u(n);
            const o = n.shapeInfo.logicalShape,
                i = e.logicalShape;
            return o.length <= i.length && (r += t ? H(n, e) : B(n, e)), r
        }

        function s(n, e) {
            switch (n.length) {
                case 0:
                    return m();
                case 1:
                    return w(n, e);
                case 2:
                    return V(n, e);
                case 3:
                    return y(n, e);
                default:
                    return I(n, e)
            }
        }

        function p(n, e) {
            switch (n.length) {
                case 0:
                    return m();
                case 1:
                    return R(n, e);
                case 2:
                    return D(n, e);
                case 3:
                    return S(n, e);
                case 4:
                    return T(n, e);
                case 5:
                    return U(n, e);
                case 6:
                    return O(n, e);
                default:
                    throw new Error(`${n.length}-D output sampling is not yet supported`)
            }
        }

        function $(n) {
            return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `
        }

        function d(n) {
            return `\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `
        }

        function h(n) {
            return `\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `
        }

        function x(n) {
            return `${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${f}\n    ${v}\n    ${g}\n  `
        }
        const f = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            v = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            g = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            C = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

        function m() {
            return "\n    int getOutputCoords() {\n      return 0;\n    }\n  "
        }

        function w(n, e) {
            const t = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
            return 1 === t[0] ? `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${t[1]}.0);\n      }\n    ` : 1 === t[1] ? `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${t[0]}.0);\n      }\n    ` : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return 2 * (resTexRC.x * ${t[1]} + resTexRC.y);\n    }\n  `
        }

        function R(n, e) {
            return 1 === e[0] ? `\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    ` : 1 === e[1] ? `\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    ` : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `
        }

        function y(n, e) {
            const t = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)],
                r = Math.ceil(n[2] / 2),
                o = r * Math.ceil(n[1] / 2);
            return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `
        }

        function S(n, e) {
            const r = t.getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], n);
            return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `
        }

        function I(n, e) {
            const t = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)],
                r = Math.ceil(n[n.length - 1] / 2),
                o = r * Math.ceil(n[n.length - 2] / 2);
            let i = o,
                c = "",
                u = "b, r, c";
            for (let l = 2; l < n.length - 1; l++) c = `\n      int b${l} = index / ${i*=n[n.length-l-1]};\n      index -= b${l} * ${i};\n    ` + c, u = `b${l}, ` + u;
            return `\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${c}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${n.length}(${u});\n    }\n  `
        }

        function T(n, e) {
            const r = t.getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], n);
            return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `
        }

        function U(n, e) {
            const r = t.getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], n);
            return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${r}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `
        }

        function O(n, e) {
            const r = t.getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], n);
            return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${r}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `
        }

        function V(e, t) {
            const r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
            if (n.util.arraysEqual(e, t)) return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;
            const o = Math.ceil(e[1] / 2);
            return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `
        }

        function D(e, t) {
            return n.util.arraysEqual(e, t) ? `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    ` : 1 === e[1] ? `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ` : 1 === e[0] ? `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ` : `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `
        }

        function b(n) {
            return `offset${n}`
        }

        function M(n) {
            const t = n.name;
            return `\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${(0,e.getGlslDifferences)().texture2D}(${t}, halfCR);\n    }\n  `
        }

        function N(n) {
            const e = n.name,
                t = "get" + e.charAt(0).toUpperCase() + e.slice(1);
            if (n.shapeInfo.isUniform) return `float ${t}() {return ${e};}`;
            const [r, o] = n.shapeInfo.texShape;
            if (1 === r && 1 === o) return `\n      float ${t}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;
            const [i, c] = n.shapeInfo.texShape;
            return `\n    float ${t}() {\n      vec2 uv = uvFromFlat(${i}, ${c}, ${b(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `
        }

        function F(n) {
            const t = n.name,
                r = "get" + t.charAt(0).toUpperCase() + t.slice(1),
                o = n.shapeInfo.texShape,
                i = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
                c = (0, e.getGlslDifferences)();
            return `\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${c.texture2D}(${t}, uv);\n    }\n  `
        }

        function k(n) {
            const e = n.name,
                t = "get" + e.charAt(0).toUpperCase() + e.slice(1);
            if (n.shapeInfo.isUniform) return `\n      float ${t}(int index) {\n        ${G(n)}\n      }\n    `;
            const r = n.shapeInfo.texShape,
                o = r[0],
                i = r[1];
            if (1 === i && 1 === o) return `\n      float ${t}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;
            const c = b(e);
            return 1 === i ? `\n      float ${t}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    ` : 1 === o ? `\n      float ${t}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    ` : `\n    float ${t}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${c});\n      return sampleTexture(${e}, uv);\n    }\n  `
        }

        function A(t) {
            const r = t.shapeInfo.logicalShape,
                o = t.name,
                i = "get" + o.charAt(0).toUpperCase() + o.slice(1),
                c = t.shapeInfo.texShape,
                u = c[0],
                l = c[1],
                a = (0, e.getGlslDifferences)();
            if (null != c && n.util.arraysEqual(r, c)) return `\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n\n        return ${a.texture2D}(${o}, uv);\n      }\n    `;
            const s = [Math.ceil(c[0] / 2), Math.ceil(c[1] / 2)];
            return `\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(r[1]/2)}, ${s[0]}, ${s[1]}, row, col);\n      return ${a.texture2D}(${o}, uv);\n    }\n  `
        }

        function j(e) {
            const t = e.shapeInfo.logicalShape,
                r = e.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                i = e.shapeInfo.texShape;
            if (null != i && n.util.arraysEqual(t, i)) {
                const n = i[0];
                return `\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${n}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `
            }
            const {
                newShape: c,
                keptDims: l
            } = n.util.squeezeShape(t), a = c;
            if (a.length < t.length) {
                const n = ["row", "col"];
                return `\n      ${u(J(e,a))}\n      float ${o}(int row, int col) {\n        return ${o}(${K(n,l)});\n      }\n    `
            }
            if (e.shapeInfo.isUniform) return `\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${G(e)}\n      }\n    `;
            const s = i[0],
                p = i[1],
                $ = b(r);
            return 1 === p ? `\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${$}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${s}.0);\n      return sampleTexture(${r}, uv);\n    }\n  ` : 1 === s ? `\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${$}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  ` : `\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${$};\n    vec2 uv = uvFromFlat(${s}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`
        }

        function z(n) {
            const t = n.shapeInfo.logicalShape,
                r = n.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                i = n.shapeInfo.texShape,
                c = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
            if (1 === t[0]) {
                const e = [1, 2],
                    r = ["b", "row", "col"];
                return `\n        ${l(J(n,t.slice(1)))}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${K(r,e)});\n        }\n      `
            }
            const u = c[0],
                a = c[1],
                s = Math.ceil(t[2] / 2);
            return `\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${a}, ${s*Math.ceil(t[1]/2)}, ${s}, b, row, col);\n      return ${(0,e.getGlslDifferences)().texture2D}(${r}, uv);\n    }\n  `
        }

        function E(e) {
            const t = e.shapeInfo.logicalShape,
                r = e.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                i = t[1] * t[2],
                c = t[2],
                {
                    newShape: l,
                    keptDims: a
                } = n.util.squeezeShape(t),
                s = l;
            if (s.length < t.length) {
                const n = ["row", "col", "depth"];
                return `\n        ${u(J(e,s))}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${K(n,a)});\n        }\n      `
            }
            if (e.shapeInfo.isUniform) return `\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${c}, 1)));\n        ${G(e)}\n      }\n    `;
            const p = e.shapeInfo.texShape,
                $ = p[0],
                d = p[1],
                h = e.shapeInfo.flatOffset;
            return d === i && null == h ? `\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${c}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${$}.0);\n          return sampleTexture(${r}, uv);\n        }\n      ` : d === c && null == h ? `\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${$}.0);\n      return sampleTexture(${r}, uv);\n    }\n  ` : `\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${c} + depth + ${b(r)};\n        vec2 uv = uvFromFlat(${$}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `
        }

        function q(n) {
            const t = n.shapeInfo.logicalShape,
                r = t.length,
                o = n.name,
                i = "get" + o.charAt(0).toUpperCase() + o.slice(1),
                c = n.shapeInfo.texShape,
                u = [Math.ceil(c[0] / 2), Math.ceil(c[1] / 2)],
                l = u[0],
                a = u[1],
                s = Math.ceil(t[r - 1] / 2);
            let p = s * Math.ceil(t[r - 2] / 2),
                $ = "int b, int row, int col",
                d = `b * ${p} + (row / 2) * ${s} + (col / 2)`;
            for (let e = 2; e < r - 1; e++) $ = `int b${e}, ` + $, d = `b${e} * ${p*=t[r-e-1]} + ` + d;
            return `\n    vec4 ${i}(${$}) {\n      int index = ${d};\n      int texR = index / ${a};\n      int texC = index - texR * ${a};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}, ${l});\n      return ${(0,e.getGlslDifferences)().texture2D}(${o}, uv);\n    }\n  `
        }

        function L(e) {
            const t = e.shapeInfo.logicalShape,
                r = e.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                i = t[3],
                c = t[2] * i,
                l = t[1] * c,
                {
                    newShape: a,
                    keptDims: s
                } = n.util.squeezeShape(t);
            if (a.length < t.length) {
                const n = ["row", "col", "depth", "depth2"];
                return `\n      ${u(J(e,a))}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${K(n,s)});\n      }\n    `
            }
            if (e.shapeInfo.isUniform) return `\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${c}, ${i}, 1)));\n        ${G(e)}\n      }\n    `;
            const p = e.shapeInfo.flatOffset,
                $ = e.shapeInfo.texShape,
                d = $[0],
                h = $[1];
            return h === l && null == p ? `\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${c}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : h === i && null == p ? `\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${c} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${b(r)});\n      return sampleTexture(${r}, uv);\n    }\n  `
        }

        function P(e) {
            const t = e.shapeInfo.logicalShape,
                r = e.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                i = t[4],
                c = t[3] * i,
                l = t[2] * c,
                a = t[1] * l,
                {
                    newShape: s,
                    keptDims: p
                } = n.util.squeezeShape(t);
            if (s.length < t.length) {
                const n = ["row", "col", "depth", "depth2", "depth3"];
                return `\n      ${u(J(e,s))}\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        return ${o}(${K(n,p)});\n      }\n    `
            }
            if (e.shapeInfo.isUniform) return `\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${l}, ${c}, ${i})) +\n          depth3;\n        ${G(e)}\n      }\n    `;
            const $ = e.shapeInfo.flatOffset,
                d = e.shapeInfo.texShape,
                h = d[0],
                x = d[1];
            return x === a && null == $ ? `\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${l}, ${c}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : x === i && null == $ ? `\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${l} + depth * ${c} +\n          depth2 * ${i} + depth3 + ${b(r)};\n      vec2 uv = uvFromFlat(${h}, ${x}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `
        }

        function _(e) {
            const t = e.shapeInfo.logicalShape,
                r = e.name,
                o = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                {
                    newShape: i,
                    keptDims: c
                } = n.util.squeezeShape(t);
            if (i.length < t.length) {
                const n = ["row", "col", "depth", "depth2", "depth3", "depth4"];
                return `\n      ${u(J(e,i))}\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${o}(${K(n,c)});\n      }\n    `
            }
            const l = t[5],
                a = t[4] * l,
                s = t[3] * a,
                p = t[2] * s,
                $ = t[1] * p;
            if (e.shapeInfo.isUniform) return `\n      float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${$}, ${p}, ${s}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${l}, 1)));\n        ${G(e)}\n      }\n    `;
            const d = e.shapeInfo.flatOffset,
                h = e.shapeInfo.texShape,
                x = h[0],
                f = h[1];
            return f === $ && null == d ? `\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${p}, ${s}, ${a}, ${l})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${x}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : f === l && null == d ? `\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${x}.0);\n        return sampleTexture(${r}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${$} + col * ${p} + depth * ${s} +\n          depth2 * ${a} + depth3 * ${l} + depth4 + ${b(r)};\n      vec2 uv = uvFromFlat(${x}, ${f}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `
        }

        function G(e) {
            const t = e.name,
                r = n.util.sizeFromShape(e.shapeInfo.logicalShape);
            return r < 2 ? `return ${t};` : `\n    for (int i = 0; i < ${r}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `
        }

        function H(e, t) {
            const r = e.name,
                o = r.charAt(0).toUpperCase() + r.slice(1),
                c = "get" + o + "AtOutCoords",
                u = e.shapeInfo.logicalShape.length,
                l = t.logicalShape.length,
                a = i(e.shapeInfo.logicalShape, t.logicalShape),
                s = W(l),
                p = l - u;
            let $;
            const d = ["x", "y", "z", "w", "u", "v"];
            $ = 0 === u ? "" : l < 2 && a.length >= 1 ? "coords = 0;" : a.map(n => `coords.${d[n+p]} = 0;`).join("\n");
            let h = "";
            h = l < 2 && u > 0 ? "coords" : e.shapeInfo.logicalShape.map((n, e) => `coords.${d[e+p]}`).join(", ");
            let x = "return outputValue;";
            const f = 1 === n.util.sizeFromShape(e.shapeInfo.logicalShape),
                v = 1 === n.util.sizeFromShape(t.logicalShape);
            if (1 !== u || f || v) {
                if (f && !v) x = 1 === l ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                else if (a.length) {
                    const n = u - 2,
                        e = u - 1;
                    a.indexOf(n) > -1 && a.indexOf(e) > -1 ? x = "return vec4(outputValue.x);" : a.indexOf(n) > -1 ? x = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : a.indexOf(e) > -1 && (x = "return vec4(outputValue.xx, outputValue.zz);")
                }
            } else x = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
            return `\n    vec4 ${c}() {\n      ${s} coords = getOutputCoords();\n      ${$}\n      vec4 outputValue = get${o}(${h});\n      ${x}\n    }\n  `
        }

        function B(e, t) {
            const r = e.name,
                o = r.charAt(0).toUpperCase() + r.slice(1),
                c = "get" + o + "AtOutCoords",
                u = t.texShape,
                l = e.shapeInfo.texShape,
                a = e.shapeInfo.logicalShape.length,
                s = t.logicalShape.length;
            if (!e.shapeInfo.isUniform && a === s && null == e.shapeInfo.flatOffset && n.util.arraysEqual(l, u)) return `\n      float ${c}() {\n        return sampleTexture(${r}, resultUV);\n      }\n    `;
            const p = W(s),
                $ = i(e.shapeInfo.logicalShape, t.logicalShape),
                d = s - a;
            let h;
            const x = ["x", "y", "z", "w", "u", "v"];
            let f = "";
            return `\n    float ${c}() {\n      ${p} coords = getOutputCoords();\n      ${h=0===a?"":s<2&&$.length>=1?"coords = 0;":$.map(n=>`coords.${x[n+d]} = 0;`).join("\n")}\n      return get${o}(${f=s<2&&a>0?"coords":e.shapeInfo.logicalShape.map((n,e)=>`coords.${x[e+d]}`).join(", ")});\n    }\n  `
        }

        function W(n) {
            if (n <= 1) return "int";
            if (2 === n) return "ivec2";
            if (3 === n) return "ivec3";
            if (4 === n) return "ivec4";
            if (5 === n) return "ivec5";
            if (6 === n) return "ivec6";
            throw Error(`GPU for rank ${n} is not yet supported`)
        }

        function J(n, e) {
            const t = JSON.parse(JSON.stringify(n));
            return t.shapeInfo.logicalShape = e, t
        }

        function K(n, e) {
            return e.map(e => n[e]).join(", ")
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ"
    }],
    "TNMy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ArgMinMaxPackedProgram = void 0;
        var e = require("@tensorflow/tfjs-core"),
            n = require("./packing_util"),
            t = require("./shader_compiler");
        class c {
            constructor(c, o, s, a) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, e.util.assert(c.length > 2, () => `Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);
                const i = c[c.length - 1],
                    r = Math.ceil(i / o);
                this.outputShape = c.slice(0, -1), r > 1 && this.outputShape.push(r), a || this.variableNames.push("bestIndicesA");
                const d = this.outputShape,
                    l = d.length,
                    $ = (0, t.getCoordsDataType)(l),
                    u = (0, n.getChannels)("coords", l);
                let h, p;
                if (1 === r) {
                    p = l + 1;
                    const e = (0, t.getCoordsDataType)(p);
                    h = `\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[l-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[l-2]};`
                } else p = l, h = `\n        ${$} sourceLocR = coords;\n        ++${u[l-1]};\n        ${$} sourceLocG = coords;\n        ++${u[l-2]};\n        ${$} sourceLocA = coords;\n        --${u[l-1]};\n        ${$} sourceLocB = coords;\n        --${u[l-2]};`;
                const x = ["x", "y", "z", "w", "u", "v"].slice(0, p),
                    g = "." + x[p - 1],
                    v = x.map(e => "int " + e),
                    C = (0, n.getChannels)("sourceLocR", p - 1).concat("inIdx.r"),
                    I = (0, n.getChannels)("sourceLocG", p - 1).concat("inIdx.g"),
                    b = (0, n.getChannels)("sourceLocB", p - 1).concat("inIdx.b"),
                    A = (0, n.getChannels)("sourceLocA", p - 1).concat("inIdx.a"),
                    j = "max" === s ? "greaterThan" : "lessThan",
                    L = a ? "" : `\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${A.join()})));`,
                    B = `vec4(\n            getAChannel(${C.join()}),\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${A.join()}) : 0.)`,
                    m = a ? "" : `\n      float getBestIndicesAChannel(${v.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;
                this.userCode = `\n      float getAChannel(${v.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${m}\n      void main() {\n        ${$} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${d[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${d[l-2]-1};\n        ${h}\n        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},\n          sourceLocB${g}, sourceLocA${g}) * ${o};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${B};\n\n        for (int i = 0; i < ${o}; i++) {\n          inIdx = srcIdx;\n          ${L}\n          vec4 candidate = ${B};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${j}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `
            }
        }
        exports.ArgMinMaxPackedProgram = c;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "vgTo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AvgPool3DBackpropProgram = exports.AvgPool2DBackpropProgram = void 0;
        class t {
            constructor(t) {
                this.variableNames = ["dy"], this.outputShape = t.inShape;
                const n = t.filterHeight,
                    o = t.filterWidth,
                    i = t.strideHeight,
                    d = t.strideWidth,
                    e = t.dilationHeight,
                    r = t.dilationWidth,
                    a = t.effectiveFilterHeight,
                    y = t.effectiveFilterWidth,
                    l = a - 1 - t.padInfo.top,
                    s = y - 1 - t.padInfo.left,
                    c = 1 / (n * o);
                this.userCode = `\n      const ivec2 pads = ivec2(${l}, ${s});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n            wR += ${e}) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${y};\n            wC+= ${r}) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.AvgPool2DBackpropProgram = t;
        class n {
            constructor(t) {
                this.variableNames = ["dy"], this.outputShape = t.inShape;
                const n = t.filterDepth,
                    o = t.filterHeight,
                    i = t.filterWidth,
                    d = t.strideDepth,
                    e = t.strideHeight,
                    r = t.strideWidth,
                    a = t.dilationDepth,
                    y = t.dilationHeight,
                    l = t.dilationWidth,
                    s = t.effectiveFilterDepth,
                    c = t.effectiveFilterHeight,
                    f = t.effectiveFilterWidth,
                    C = s - 1 - t.padInfo.front,
                    p = c - 1 - t.padInfo.top,
                    h = f - 1 - t.padInfo.left,
                    u = 1 / (n * o * i);
                this.userCode = `\n      const ivec3 pads = ivec3(${C}, ${p}, ${h});\n      const float avgMultiplier = float(${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n            wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${d}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${y}) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.AvgPool3DBackpropProgram = n;
    }, {}],
    "IgN9": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.BatchNormProgram = void 0;
        var t = require("@tensorflow/tfjs-core");
        class e {
            constructor(e, a, s, o, r, n) {
                this.outputShape = [], this.variableNames = ["x", "mean", "variance"], t.backend_util.assertAndGetBroadcastShape(e, a), t.backend_util.assertAndGetBroadcastShape(e, s);
                let l = "0.0";
                null != o && (t.backend_util.assertAndGetBroadcastShape(e, o), this.variableNames.push("offset"), l = "getOffsetAtOutCoords()");
                let i = "1.0";
                null != r && (t.backend_util.assertAndGetBroadcastShape(e, r), this.variableNames.push("scale"), i = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${l};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${n}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `
            }
        }
        exports.BatchNormProgram = e;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "DUWz": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.BatchNormPackedProgram = void 0;
        var e = require("@tensorflow/tfjs-core");
        class t {
            constructor(t, a, s, r, n, c) {
                this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], e.backend_util.assertAndGetBroadcastShape(t, a), e.backend_util.assertAndGetBroadcastShape(t, s);
                let o = "vec4(0.0)";
                null != r && (e.backend_util.assertAndGetBroadcastShape(t, r), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
                let i = "vec4(1.0)";
                null != n && (e.backend_util.assertAndGetBroadcastShape(t, n), this.variableNames.push("scale"), i = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${c}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `
            }
        }
        exports.BatchNormPackedProgram = t;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "eCLc": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.BinaryOpComplexProgram = exports.COMPLEX_MULTIPLY = void 0;
        var a = require("@tensorflow/tfjs-core");
        const e = {
            REAL: "return areal * breal - aimag * bimag;",
            IMAG: "return areal * bimag + aimag * breal;"
        };
        exports.COMPLEX_MULTIPLY = e;
        class t {
            constructor(e, t, r) {
                this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = a.backend_util.assertAndGetBroadcastShape(t, r), this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `
            }
        }
        exports.BinaryOpComplexProgram = t;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "r3Zb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.BinaryOpProgram = exports.PRELU = exports.ELU_DER = exports.ATAN2 = exports.MOD = exports.MIN = exports.MAX = exports.LOGICAL_OR = exports.LOGICAL_AND = exports.GREATER_EQUAL = exports.GREATER = exports.LESS_EQUAL = exports.LESS = exports.NOT_EQUAL = exports.EQUAL = exports.SQUARED_DIFFERENCE = exports.POW = exports.INT_DIV = exports.DIV = exports.MUL = exports.SUB = exports.ADD = void 0;
        var t = require("@tensorflow/tfjs-core");
        const r = "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",
            n = "return a + b;";
        exports.ADD = n;
        const o = "return a - b;";
        exports.SUB = o;
        const e = "return a * b;";
        exports.MUL = e;
        const s = "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;";
        exports.DIV = s;
        const a = "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n";
        exports.INT_DIV = a;
        const p = "\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
        exports.POW = p;
        const b = "return (a - b) * (a - b);";
        exports.SQUARED_DIFFERENCE = b;
        const i = "return float(a == b);";
        exports.EQUAL = i;
        const x = "return float(a != b);";
        exports.NOT_EQUAL = x;
        const u = "return float(a < b);";
        exports.LESS = u;
        const A = "return float(a <= b);";
        exports.LESS_EQUAL = A;
        const E = "return float(a > b);";
        exports.GREATER = E;
        const c = "return float(a >= b);";
        exports.GREATER_EQUAL = c;
        const f = "return float(a >= 1.0 && b >= 1.0);";
        exports.LOGICAL_AND = f;
        const L = "return float(a >= 1.0 || b >= 1.0);";
        exports.LOGICAL_OR = L;
        const l = r + "\n  return max(a, b);\n";
        exports.MAX = l;
        const D = r + "\n  return min(a, b);\n";
        exports.MIN = D;
        const O = "if (b == 0.0) return NAN;\n  return mod(a, b);";
        exports.MOD = O;
        const d = r + "\n  return atan(a, b);\n";
        exports.ATAN2 = d;
        const N = "return (b >= 1.0) ? a : a * (b + 1.0);";
        exports.ELU_DER = N;
        const _ = "return (a < 0.) ? b * a : a;";
        exports.PRELU = _;
        class R {
            constructor(r, n, o) {
                this.variableNames = ["A", "B"], this.outputShape = t.backend_util.assertAndGetBroadcastShape(n, o), this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${r}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `
            }
        }
        exports.BinaryOpProgram = R;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "MEci": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.BinaryOpPackedProgram = exports.MOD = exports.MIN = exports.MAX = exports.LOGICAL_OR = exports.LOGICAL_AND = exports.GREATER_EQUAL = exports.GREATER = exports.LESS_EQUAL = exports.LESS = exports.NOT_EQUAL = exports.EQUAL = exports.ATAN2 = exports.ELU_DER = exports.PRELU = exports.POW = exports.INT_DIV = exports.DIV = void 0;
        var e = require("@tensorflow/tfjs-core"),
            n = require("./packing_util"),
            t = require("./shader_compiler");
        const s = "\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n",
            r = "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n";
        exports.DIV = r;
        const o = "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n";
        exports.INT_DIV = o;
        const a = "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  " + s + "\n  return result;\n";
        exports.POW = a;
        const u = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
        exports.PRELU = u;
        const c = "\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n";
        exports.ELU_DER = c;
        const i = "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  " + s + "\n  return result;\n";
        exports.ATAN2 = i;
        const l = "\n  return vec4(equal(a, b));\n";
        exports.EQUAL = l;
        const v = "\n  return vec4(notEqual(a, b));\n";
        exports.NOT_EQUAL = v;
        const p = "\n  return vec4(lessThan(a, b));\n";
        exports.LESS = p;
        const b = "\n  return vec4(lessThanEqual(a, b));\n";
        exports.LESS_EQUAL = b;
        const d = "\n  return vec4(greaterThan(a, b));\n";
        exports.GREATER = d;
        const x = "\n  return vec4(greaterThanEqual(a, b));\n";
        exports.GREATER_EQUAL = x;
        const E = "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n";
        exports.LOGICAL_AND = E;
        const h = "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n";
        exports.LOGICAL_OR = h;
        const N = "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  " + s + "\n  return result;\n";
        exports.MAX = N;
        const O = "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  " + s + "\n  return result;\n";
        exports.MIN = O;
        const A = "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  " + s + "\n  return result;\n";
        exports.MOD = A;
        class T {
            constructor(s, r, o, a = !1) {
                this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.backend_util.assertAndGetBroadcastShape(r, o);
                const u = this.outputShape.length;
                let c = "";
                if (a)
                    if (0 === u || 1 === e.util.sizeFromShape(this.outputShape)) c = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
                    else {
                        if (c = `\n          ${(0,t.getCoordsDataType)(u)} coords = getOutputCoords();\n        `, 1 === u) c += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;
                        else {
                            const e = (0, n.getChannels)("coords", u);
                            c += `\n            bool nextRowOutOfBounds =\n              (${e[u-2]} + 1) >= ${this.outputShape[u-2]};\n            bool nextColOutOfBounds =\n              (${e[u-1]} + 1) >= ${this.outputShape[u-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `
                        }
                    } this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${s}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${c}\n\n        setOutput(result);\n      }\n    `
            }
        }
        exports.BinaryOpPackedProgram = T;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "rjZd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ClipProgram = void 0;
        class t {
            constructor(t) {
                this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
            }
            getCustomSetupFunc(t, o) {
                return (n, i) => {
                    null == this.minLoc && (this.minLoc = n.getUniformLocationNoThrow(i, "minVal"), this.maxLoc = n.getUniformLocationNoThrow(i, "maxVal")), n.gl.uniform1f(this.minLoc, t), n.gl.uniform1f(this.maxLoc, o)
                }
            }
        }
        exports.ClipProgram = t;
    }, {}],
    "QdXF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ClipPackedProgram = void 0;
        class t {
            constructor(t) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
            }
            getCustomSetupFunc(t, n) {
                return (o, e) => {
                    null == this.minLoc && (this.minLoc = o.getUniformLocationNoThrow(e, "minVal"), this.maxLoc = o.getUniformLocationNoThrow(e, "maxVal")), o.gl.uniform1f(this.minLoc, t), o.gl.uniform1f(this.maxLoc, n)
                }
            }
        }
        exports.ClipPackedProgram = t;
    }, {}],
    "w3Ul": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ComplexAbsProgram = void 0;
        class e {
            constructor(e) {
                this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
            }
        }
        exports.ComplexAbsProgram = e;
    }, {}],
    "loEe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ConcatProgram = void 0;
        var t = require("@tensorflow/tfjs-core");
        class e {
            constructor(e) {
                this.outputShape = [], this.outputShape = t.backend_util.computeOutShape(e, 1), this.variableNames = e.map((t, e) => `T${e}`);
                const o = new Array(e.length - 1);
                o[0] = e[0][1];
                for (let t = 1; t < o.length; t++) o[t] = o[t - 1] + e[t][1];
                const s = [`if (yC < ${o[0]}) setOutput(getT0(yR, yC));`];
                for (let t = 1; t < o.length; t++) {
                    const e = o[t - 1];
                    s.push(`else if (yC < ${o[t]}) ` + `setOutput(getT${t}(yR, yC-${e}));`)
                }
                const n = o.length,
                    r = o[o.length - 1];
                s.push(`else setOutput(getT${n}(yR, yC-${r}));`), this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `
            }
        }
        exports.ConcatProgram = e;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "nB6G": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ConcatPackedProgram = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./packing_util"),
            n = require("./shader_compiler");
        class r {
            constructor(r, s) {
                this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = e.backend_util.computeOutShape(r, s);
                const u = this.outputShape,
                    a = u.length,
                    $ = (0, n.getCoordsDataType)(a),
                    l = (0, t.getChannels)("coords", a),
                    i = ["x", "y", "z", "w", "u", "v"].slice(0, a);
                this.variableNames = r.map((e, t) => `T${t}`);
                const c = new Array(r.length - 1);
                c[0] = r[0][s];
                for (let e = 1; e < c.length; e++) c[e] = c[e - 1] + r[e][s];
                const g = i[s],
                    p = i.slice(-2),
                    h = i.join();
                let d = `if (${g} < ${c[0]}) {\n        return getChannel(\n            getT0(${h}), vec2(${p.join()}));\n        }`;
                for (let e = 1; e < c.length; e++) {
                    const t = c[e - 1];
                    d += `\n        if (${g} < ${c[e]}  && ${g} >= ${c[e-1]}) {\n          return getChannel(\n            getT${e}(${o(i,g,t)}),\n            vec2(${o(p,g,t)}));\n        }`
                }
                const f = c.length,
                    v = c[c.length - 1];
                d += `\n        return getChannel(\n          getT${f}(${o(i,g,v)}),\n          vec2(${o(p,g,v)}));`, this.userCode = `\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${d}\n      }\n\n      void main() {\n        ${$} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[a-1]} = ${l[a-1]} + 1;\n        if (${l[a-1]} < ${u[a-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[a-2]} = ${l[a-2]} + 1;\n        if (${l[a-2]} < ${u[a-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[a-1]} = ${l[a-1]} - 1;\n        if (${l[a-2]} < ${u[a-2]} &&\n            ${l[a-1]} < ${u[a-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `
            }
        }

        function o(e, t, n) {
            const r = e.indexOf(t);
            return e.map((e, t) => t === r ? `${e} - ${n}` : e).join()
        }
        exports.ConcatPackedProgram = r;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "y8Ea": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Conv3DDerInputProgram = exports.Conv3DDerFilterProgram = exports.Conv2DDerInputProgram = exports.Conv2DDerFilterProgram = void 0;
        class n {
            constructor(n) {
                this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
                const t = n.strideHeight,
                    o = n.strideWidth,
                    e = n.padInfo.top,
                    d = n.padInfo.left,
                    i = "channelsLast" === n.dataFormat;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${e};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${o} - ${d};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              if (${i}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.Conv2DDerFilterProgram = n;
        class t {
            constructor(n) {
                this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
                const t = n.filterHeight,
                    o = n.filterWidth,
                    e = n.strideHeight,
                    d = n.strideWidth,
                    i = "channelsLast" === n.dataFormat,
                    r = t - 1 - n.padInfo.top,
                    a = o - 1 - n.padInfo.left,
                    s = i ? 1 : 2,
                    y = i ? 2 : 3,
                    C = i ? 3 : 1;
                this.userCode = `\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${C}];\n\n        ivec2 dyCorner = ivec2(coords[${s}], coords[${y}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${o} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.Conv2DDerInputProgram = t;
        class o {
            constructor(n) {
                this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
                const t = n.strideDepth,
                    o = n.strideHeight,
                    e = n.strideWidth,
                    d = n.padInfo.front,
                    i = n.padInfo.top,
                    r = n.padInfo.left;
                this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${d};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${o} - ${i};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${e} - ${r};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.Conv3DDerFilterProgram = o;
        class e {
            constructor(n) {
                this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
                const t = n.filterDepth,
                    o = n.filterHeight,
                    e = n.filterWidth,
                    d = n.strideDepth,
                    i = n.strideHeight,
                    r = n.strideWidth,
                    a = t - 1 - n.padInfo.front,
                    s = o - 1 - n.padInfo.top,
                    y = e - 1 - n.padInfo.left;
                this.userCode = `\n      const ivec3 pads = ivec3(${a}, ${s}, ${y});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${d}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${o}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${o} - 1 - wR;\n\n            for (int wC = 0; wC < ${e}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${e} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.Conv3DDerInputProgram = e;
    }, {}],
    "QU4a": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DepthwiseConv2DDerInputProgram = exports.DepthwiseConv2DDerFilterProgram = void 0;
        class n {
            constructor(n) {
                this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
                const t = n.strideHeight,
                    o = n.strideWidth,
                    e = n.padInfo.top,
                    d = n.padInfo.left,
                    i = n.outChannels / n.inChannels;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${e};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${o} - ${d};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.DepthwiseConv2DDerFilterProgram = n;
        class t {
            constructor(n) {
                this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
                const t = n.filterHeight,
                    o = n.filterWidth,
                    e = n.strideHeight,
                    d = n.strideWidth,
                    i = t - 1 - n.padInfo.top,
                    r = o - 1 - n.padInfo.left,
                    s = n.outChannels / n.inChannels;
                this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${o} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.DepthwiseConv2DDerInputProgram = t;
    }, {}],
    "LHRJ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Conv3DProgram = exports.Conv2DProgram = void 0;
        class n {
            constructor(n, t = !1, e = null, o = !1) {
                this.variableNames = ["x", "W"], this.outputShape = n.outShape;
                const d = n.padInfo.top,
                    i = n.padInfo.left,
                    a = n.strideHeight,
                    s = n.strideWidth,
                    x = n.dilationHeight,
                    r = n.dilationWidth,
                    c = n.filterHeight,
                    C = n.filterWidth,
                    l = 4 * Math.floor(n.inChannels / 4),
                    w = n.inChannels % 4,
                    h = "channelsLast" === n.dataFormat,
                    R = h ? 1 : 2,
                    $ = h ? 2 : 3,
                    u = h ? 3 : 1;
                let g = "",
                    v = "";
                e && (g = o ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }` : `\n          float activation(float x) {\n            ${e}\n          }\n        `, v = "result = activation(result);");
                const f = t ? "result += getBiasAtOutCoords();" : "";
                t && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), this.userCode = `\n      ${g}\n\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${d}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${u}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${R}], coords[${$}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${x};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC++) {\n            int xC = xCCorner + wC * ${r};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${l}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${h}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===w}) {\n\n              if (${h}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${l}) *\n                    getW(wR, wC, ${l}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${l}, xR, xC) *\n                    getW(wR, wC, ${l}, d2);\n              }\n\n            } else if (${2===w}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${l}, d2),\n                getW(wR, wC, ${l} + 1, d2)\n              );\n\n              if (${h}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${l}),\n                  getX(batch, xR, xC, ${l} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${l}, xR, xC),\n                  getX(batch, ${l} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===w}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${l}, d2),\n                getW(wR, wC, ${l} + 1, d2),\n                getW(wR, wC, ${l} + 2, d2)\n              );\n\n              if (${h}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${l}),\n                  getX(batch, xR, xC, ${l} + 1),\n                  getX(batch, xR, xC, ${l} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${l}, xR, xC),\n                  getX(batch, ${l} + 1, xR, xC),\n                  getX(batch, ${l} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${f}\n        ${v}\n        setOutput(result);\n      }\n    `
            }
        }
        exports.Conv2DProgram = n;
        class t {
            constructor(n) {
                this.variableNames = ["x", "W"], this.outputShape = n.outShape;
                const t = n.padInfo.front,
                    e = n.padInfo.top,
                    o = n.padInfo.left,
                    d = n.strideDepth,
                    i = n.strideHeight,
                    a = n.strideWidth,
                    s = n.dilationDepth,
                    x = n.dilationHeight,
                    r = n.dilationWidth,
                    c = n.filterDepth,
                    C = n.filterHeight,
                    l = n.filterWidth,
                    w = 4 * Math.floor(n.inChannels / 4),
                    h = n.inChannels % 4;
                this.userCode = `\n      const ivec3 strides = ivec3(${d}, ${i}, ${a});\n      const ivec3 pads = ivec3(${t}, ${e}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${C}; wR++) {\n            int xR = xRCorner + wR * ${x};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${l}; wC++) {\n              int xC = xCCorner + wC * ${r};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${w}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===h}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${w}) *\n                  getW(wF, wR, wC, ${w}, d2);\n              } else if (${2===h}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===h}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1),\n                  getX(batch, xF, xR, xC, ${w} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2),\n                  getW(wF, wR, wC, ${w} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.Conv3DProgram = t;
    }, {}],
    "tZKH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DepthwiseConv2DProgram = void 0;
        class t {
            constructor(t, n = !1, o = null, e = !1) {
                this.variableNames = ["x", "W"], this.outputShape = t.outShape;
                const i = t.inHeight,
                    s = t.inWidth,
                    r = t.padInfo.top,
                    a = t.padInfo.left,
                    d = t.strideHeight,
                    l = t.strideWidth,
                    C = t.dilationHeight,
                    c = t.dilationWidth,
                    h = t.filterHeight,
                    u = t.filterWidth,
                    x = t.outChannels / t.inChannels;
                let v = "",
                    p = "";
                o && (v = e ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }` : `\n          float activation(float x) {\n            ${o}\n          }\n        `, p = "result = activation(result);");
                const f = n ? "result += getBiasAtOutCoords();" : "";
                n && this.variableNames.push("bias"), e && this.variableNames.push("preluActivationWeights"), this.userCode = `\n      ${v}\n\n      const ivec2 strides = ivec2(${d}, ${l});\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${x};\n        int q = d2 - d1 * ${x};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${C};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${u}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${s}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${f}\n        ${p}\n        setOutput(result);\n      }\n    `
            }
        }
        exports.DepthwiseConv2DProgram = t;
    }, {}],
    "najp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DepthwiseConvPacked2DProgram = void 0;
        var e = require("@tensorflow/tfjs-core");
        class n {
            constructor(n, x = !1, t = null, $ = !1) {
                this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n.outShape;
                const C = n.inHeight,
                    s = n.inWidth,
                    f = n.padInfo.top,
                    i = n.padInfo.left,
                    c = n.strideHeight,
                    l = n.strideWidth,
                    R = n.dilationHeight,
                    r = n.dilationWidth,
                    o = n.filterHeight,
                    a = n.filterWidth,
                    v = a;
                let d = "int xR; int xC; int xCOffset;";
                for (let e = 0; e < o; e++)
                    for (let n = 0; n < a; n++) d += `\n          vec4 xTexelR${e}C${2*n} = vec4(0.);\n          vec4 wR${e}C${n} = vec4(0.);\n          vec4 xR${e}C${n} = vec4(0.);`;
                for (let T = 0; T < o; T++)
                    for (let n = 0; n < v; n++) {
                        const x = 2 * n;
                        if (d += `\n          xR = xRCorner + ${T*R};\n          xC = xCCorner + ${x*r};\n        `, 1 === l) {
                            if (x < a && (d += i % 2 == 1 ? `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${C} && xCOffset >= 0 && xCOffset < ${s}) {\n                  xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${s}) {\n                    xTexelR${T}C${x}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${T}C${x} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${C} && xCOffset >= 0 && xCOffset < ${s}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${s}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${T}C${x} = vec4(previous.zw, xTexelR${T}C${x}.xy);\n                } else {\n                  xR${T}C${x} = vec4(0, 0, xTexelR${T}C${x}.xy);\n                }\n              ` : `\n                if(xR >= 0 && xR < ${C} && xC >= 0 && xC < ${s}) {\n                  xTexelR${T}C${x} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${T}C${x} = vec4(0.);\n                }\n\n                xR${T}C${x} = xTexelR${T}C${x};\n              `, x + 1 < a)) {
                                const n = i % 2 == 0 ? e.util.nearestLargerEven(r) : r;
                                r % 2 == 0 && i % 2 == 1 || r % 2 != 0 && i % 2 != 1 ? (d += `\n                  xCOffset = xC + ${i%2} + ${n};\n\n                  if(xR >= 0 && xR < ${C} &&\n                    xCOffset >= 0 && xCOffset < ${s}) {\n                    xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `, r > 1 && (d += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${C} &&\n                      xCOffset >= 0 && xCOffset < ${s}) {\n                      xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${T}C${x} = vec4(0.);\n                    }\n                  `), d += `\n                  xR${T}C${x+1} = vec4(\n                    xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.xy);\n                `) : d += `\n                  xCOffset = xC + ${n};\n\n                  if(xR >= 0 && xR < ${C} &&\n                    xCOffset >= 0 && xCOffset < ${s}) {\n                    xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${T}C${x+1} = xTexelR${T}C${x+2};\n                `
                            }
                        } else x < a && (d += `\n              if(xR >= 0 && xR < ${C}) {\n            `, i % 2 == 1 ? (d += `\n                xCOffset = xC + 1 - ${l};\n                if(xCOffset >= 0 && xCOffset < ${s}) {\n                  xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${T}C${x} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${s}) {\n                  xTexelR${T}C${x+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${T}C${x+2} = vec4(0.);\n                }\n\n                xR${T}C${x} = vec4(\n                  xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.zw);\n              `, x + 1 < a && (d += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${l};\n                  if(xCOffset >= 0 && xCOffset < ${s}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${T}C${x+1} = vec4(xTexelR${T}C${x+2}.xy, final.xy);\n                `)) : (d += `\n                if(xC >= 0 && xC < ${s}) {\n                  xTexelR${T}C${x} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${T}C${x} = vec4(0.);\n                }\n\n                xCOffset = xC + ${l};\n                if(xCOffset >= 0 && xCOffset < ${s}) {\n                  xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${T}C${x+2} = vec4(0.);\n                }\n\n                xR${T}C${x} = vec4(\n                  xTexelR${T}C${x}.xy, xTexelR${T}C${x+2}.xy);\n              `, x + 1 < a && (d += `\n                  xR${T}C${x+1} = vec4(\n                    xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.zw);\n                `)), d += "}");
                        x < a && (d += `\n            vec4 wTexelR${T}C${x} = getW(${T}, ${x}, d1, q);\n            wR${T}C${x} = vec4(wTexelR${T}C${x}.xz, wTexelR${T}C${x}.xz);\n          `, x + 1 < a && (d += `\n              vec4 wTexelR${T}C${x+1} = getW(${T}, ${x+1}, d1, q);\n              wR${T}C${x+1} =\n                vec4(wTexelR${T}C${x+1}.xz, wTexelR${T}C${x+1}.xz);`))
                    }
                for (let e = 0; e < o; e++)
                    for (let n = 0; n < a; n++) d += `dotProd += xR${e}C${n} * wR${e}C${n};`;
                let O = "",
                    u = "";
                t && (O = $ ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }` : `vec4 activation(vec4 x) {\n          ${t}\n        }`, u = "result = activation(result);");
                const h = x ? "result += getBiasAtOutCoords();" : "";
                x && this.variableNames.push("bias"), $ && this.variableNames.push("preluActivationWeights"), this.userCode = `\n      ${O}\n\n      const ivec2 strides = ivec2(${c}, ${l});\n      const ivec2 pads = ivec2(${f}, ${i});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${d}\n\n        vec4 result = dotProd;\n        ${h}\n        ${u}\n        setOutput(result);\n      }\n    `
            }
        }
        exports.DepthwiseConvPacked2DProgram = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "nc6W": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CropAndResizeProgram = void 0;
        class e {
            constructor(e, t, o, n, r) {
                this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
                const [a, i, s, c] = e, [l] = t, [u, f] = o;
                this.outputShape = [l, u, f, c];
                const d = "bilinear" === n ? 1 : 0,
                    [x, C] = [`${i-1}.0`, `${s-1}.0`],
                    [g, R, b] = u > 1 ? [`${(i-1)/(u-1)}`, "(y2-y1) * height_ratio", `y1*${x} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${x}`],
                    [h, p, m] = f > 1 ? [`${(s-1)/(f-1)}`, "(x2-x1) * width_ratio", `x1*${C} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${C}`];
                this.userCode = `\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${h});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${R};\n        float width_scale = ${p};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${x} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${m};\n        if( in_x < 0.0 || in_x > ${C} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `
            }
        }
        exports.CropAndResizeProgram = e;
    }, {}],
    "h31s": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CumSumProgram = void 0;
        var t = require("./shader_compiler");
        class e {
            constructor(e, o, i) {
                this.variableNames = ["x"], this.outputShape = e;
                const u = e.length,
                    s = o ? "0.0" : `getX(${n(u,"coords")})`,
                    d = e[e.length - 1];
                let $ = "",
                    a = "";
                o ? ($ = i ? `end != ${d-1}` : "end != 0", a = i ? "end + 1" : "end - 1") : ($ = i ? `end + pow2 < ${d}` : "end >= pow2", a = i ? "end + pow2" : "end - pow2"), this.userCode = `\n      uniform float index;\n      void main() {\n        ${(0,t.getCoordsDataType)(u)} coords = getOutputCoords();\n        int end = ${r(u,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${$}) {\n          int idx = ${a};\n          ${r(u,"coords")} = idx;\n          val += getX(${n(u,"coords")});\n        }\n        setOutput(val);\n      }\n    `
            }
            getCustomSetupFunc(t) {
                return (e, n) => {
                    null == this.index && (this.index = e.getUniformLocation(n, "index")), e.gl.uniform1f(this.index, t)
                }
            }
        }

        function n(t, e) {
            if (1 === t) return `${e}`;
            if (2 === t) return `${e}.x, ${e}.y`;
            if (3 === t) return `${e}.x, ${e}.y, ${e}.z`;
            if (4 === t) return `${e}.x, ${e}.y, ${e}.z, ${e}.w`;
            throw Error(`Cumulative sum for rank ${t} is not yet supported`)
        }

        function r(t, e) {
            if (1 === t) return `${e}`;
            if (2 === t) return `${e}.y`;
            if (3 === t) return `${e}.z`;
            if (4 === t) return `${e}.w`;
            throw Error(`Cumulative sum for rank ${t} is not yet supported`)
        }
        exports.CumSumProgram = e;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "tZX6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DecodeMatrixProgram = void 0;
        var e = require("./glsl_version"),
            t = i(require("./shader_compiler_util")),
            r = require("./tex_util");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var c = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                    c && (c.get || c.set) ? Object.defineProperty(r, o, c) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }
        class o {
            constructor(n) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = r.PackingScheme.DENSE;
                const i = (0, r.getDenseTexShape)(n),
                    o = (0, e.getGlslDifferences)();
                this.outputShape = n, this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${t.getLogicalCoordinatesFromFlatIndex(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${i[0]}, ${i[1]}));\n        int index = 4 * (resTexRC.x * ${i[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${o.output} = result;\n      }\n    `
            }
        }
        exports.DecodeMatrixProgram = o;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ",
        "./tex_util": "hBHG"
    }],
    "kOP2": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DecodeMatrixPackedProgram = void 0;
        var e = require("./glsl_version"),
            t = i(require("./shader_compiler_util")),
            r = require("./tex_util");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function i(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var c = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                    c && (c.get || c.set) ? Object.defineProperty(r, o, c) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }
        class o {
            constructor(n) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = r.PackingScheme.DENSE;
                const i = (0, r.getDenseTexShape)(n),
                    o = (0, e.getGlslDifferences)();
                this.outputShape = n, this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${t.getLogicalCoordinatesFromFlatIndex(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${i[0]}, ${i[1]}));\n        int index = 4 * (resTexRC.x * ${i[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${o.output} = result;\n      }\n    `
            }
        }
        exports.DecodeMatrixPackedProgram = o;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ",
        "./tex_util": "hBHG"
    }],
    "KXiR": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DepthToSpaceProgram = void 0;
        class t {
            constructor(t, o, i) {
                this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = o, this.dataFormat = i, this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${o};\n      int offset_h = imod(h, ${o});\n      int in_w = w / ${o};\n      int offset_w = imod(w, ${o});\n      int offset_d = (offset_h * ${o} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `
            }
            getHeightCoordString() {
                return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
            }
            getWidthCoordString() {
                return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
            }
            getDepthCoordString() {
                return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
            }
            getOutputDepthSize() {
                return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
            }
            getInputSamplingString() {
                return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
            }
        }
        exports.DepthToSpaceProgram = t;
    }, {}],
    "V8Cn": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DiagProgram = void 0;
        class o {
            constructor(o) {
                this.variableNames = ["X"], this.outputShape = [o, o], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
            }
        }
        exports.DiagProgram = o;
    }, {}],
    "KyTh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.EncodeFloatProgram = void 0;
        var e = require("./glsl_version"),
            t = require("./shader_compiler_util"),
            o = require("./tex_util");
        class r {
            constructor(r) {
                this.variableNames = ["A"], this.outTexUsage = o.TextureUsage.DOWNLOAD;
                const s = (0, e.getGlslDifferences)();
                this.outputShape = r, this.userCode = `\n      ${t.ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${s.output} = encode_float(x);\n      }\n    `
            }
        }
        exports.EncodeFloatProgram = r;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ",
        "./tex_util": "hBHG"
    }],
    "zODu": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.EncodeFloatPackedProgram = void 0;
        var e = require("./glsl_version"),
            t = require("./shader_compiler_util"),
            o = require("./tex_util");
        class r {
            constructor(r) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = o.TextureUsage.DOWNLOAD;
                const s = (0, e.getGlslDifferences)();
                this.outputShape = r, this.userCode = `\n      ${t.ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${s.output} = encode_float(x);\n      }\n    `
            }
        }
        exports.EncodeFloatPackedProgram = r;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ",
        "./tex_util": "hBHG"
    }],
    "JBcV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.EncodeMatrixProgram = void 0;
        var e = require("./glsl_version"),
            t = r(require("./shader_compiler_util"));

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var s in e)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    var l = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                    l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s]
                } return r.default = e, t && t.set(e, r), r
        }
        class o {
            constructor(n, r, o = !1) {
                this.variableNames = ["A"];
                const s = (0, e.getGlslDifferences)(),
                    [l, u] = r;
                this.outputShape = n;
                let i = "result";
                o && (i = "floor(result * 255. + 0.5)"), this.userCode = `\n      ${t.getFlatIndexFrom3D(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${u};\n        int c = imod(flatIndex, ${u});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${u}.0, ${l}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `
            }
        }
        exports.EncodeMatrixProgram = o;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ"
    }],
    "dH5p": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.EncodeMatrixPackedProgram = void 0;
        var e = require("./glsl_version"),
            t = r(require("./shader_compiler_util"));

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var l in e)
                if (Object.prototype.hasOwnProperty.call(e, l)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, l) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, l, s) : r[l] = e[l]
                } return r.default = e, t && t.set(e, r), r
        }
        class o {
            constructor(n, r, o = !1) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
                const l = (0, e.getGlslDifferences)(),
                    [s, a] = r;
                this.outputShape = n;
                let u = "",
                    c = "result";
                o && (c = "floor(result * 255. + 0.5)");
                for (let e = 0; e <= 1; e++)
                    for (let t = 0; t <= 1; t++) {
                        const r = 2 * e + t;
                        u += `\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${n[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${e} < ${n[1]}) {\n              localCoords[1] += ${e};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n              values = ${l.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${r}] = values[0];\n              } else if(offset == 1) {\n                result[${r}] = values[1];\n              } else if(offset == 2) {\n                result[${r}] = values[2];\n              } else {\n                result[${r}] = values[3];\n              }\n            }\n          }\n        `
                    }
                this.userCode = `\n      ${t.getFlatIndexFrom3D(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${u}\n\n        ${l.output} = ${c};\n      }\n    `
            }
        }
        exports.EncodeMatrixPackedProgram = o;
    }, {
        "./glsl_version": "QbWp",
        "./shader_compiler_util": "vOsJ"
    }],
    "LwKt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FFTProgram = exports.COMPLEX_FFT = void 0;
        const t = {
            REAL: "return real * expR - imag * expI;",
            IMAG: "return real * expI + imag * expR;"
        };
        exports.COMPLEX_FFT = t;
        class e {
            constructor(t, e, n) {
                this.variableNames = ["real", "imag"];
                const o = e[1];
                this.outputShape = e;
                const a = n ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`,
                    i = n ? `${o}.0` : "1.0";
                this.userCode = `\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${o});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${o}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `
            }
        }
        exports.FFTProgram = e;
    }, {}],
    "A8rF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FillProgram = void 0;
        class t {
            constructor(t, e) {
                this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
            }
            getCustomSetupFunc(t) {
                return (e, o) => {
                    null == this.valueLoc && (this.valueLoc = e.getUniformLocationNoThrow(o, "value")), e.gl.uniform1f(this.valueLoc, t)
                }
            }
        }
        exports.FillProgram = t;
    }, {}],
    "sYl6": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.GatherProgram = void 0;
        var e = require("./shader_compiler");
        class t {
            constructor(t, s, o) {
                this.variableNames = ["A", "indices"];
                const n = t.slice();
                n[o] = s, this.outputShape = n, this.rank = n.length;
                const i = (0, e.getCoordsDataType)(this.rank),
                    a = r(t, o);
                this.userCode = `\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `
            }
        }

        function r(e, t) {
            const r = e.length;
            if (r > 4) throw Error(`Gather for rank ${r} is not yet supported`);
            if (1 === r) return "int(getIndices(resRC))";
            const s = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                o = [];
            for (let n = 0; n < e.length; n++) n === t ? o.push(`int(getIndices(${s[n]}))`) : o.push(`${s[n]}`);
            return o.join()
        }
        exports.GatherProgram = t;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "gSio": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.GatherNDProgram = void 0;
        var e = require("./shader_compiler");
        class t {
            constructor(t, s, i) {
                this.sliceDim = t, this.strides = s, this.variableNames = ["x", "indices"], this.outputShape = i;
                const r = (0, e.getCoordsDataType)(s.length),
                    n = (0, e.getCoordsDataType)(i.length),
                    o = this.sliceDim > 1 ? "strides[j]" : "strides";
                this.userCode = `\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${n} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `
            }
        }
        exports.GatherNDProgram = t;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "LB6l": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.createVertexShader = o, exports.createVertexBuffer = u, exports.createIndexBuffer = i, exports.getInternalFormatForFloat32MatrixTexture = l, exports.createFloat32MatrixTexture = x, exports.getInternalFormatForFloat16MatrixTexture = d, exports.createFloat16MatrixTexture = f, exports.getInternalFormatForUnsignedBytesMatrixTexture = T, exports.createUnsignedBytesMatrixTexture = F, exports.getInternalFormatForPackedMatrixTexture = A, exports.createPackedMatrixTexture = s, exports.getInternalFormatForFloat16PackedMatrixTexture = E, exports.createFloat16PackedMatrixTexture = p, exports.bindVertexProgramAttributeStreams = P, exports.uploadDenseMatrixToTexture = _, exports.uploadPixelDataToTexture = h, exports.createBufferFromOutputTexture = B, exports.downloadFloat32MatrixFromBuffer = R, exports.downloadByteEncodedFloatMatrixFromOutputTexture = U, exports.downloadPackedMatrixFromBuffer = g, exports.downloadMatrixFromPackedOutputTexture = k;
        var e = require("./glsl_version"),
            t = a(require("./tex_util")),
            r = a(require("./webgl_util"));

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function a(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = n();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                a = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = a ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(r, o, u) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function o(t) {
            const n = (0, e.getGlslDifferences)(),
                a = `${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;
            return r.createVertexShader(t, a)
        }

        function u(e) {
            const t = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
            return r.createStaticVertexBuffer(e, t)
        }

        function i(e) {
            const t = new Uint16Array([0, 1, 2, 2, 1, 3]);
            return r.createStaticIndexBuffer(e, t)
        }

        function c(e, t, n, a, o, u) {
            r.validateTextureSize(t, n);
            const i = r.createTexture(e),
                c = e.TEXTURE_2D;
            return r.callAndCheck(e, () => e.bindTexture(c, i)), r.callAndCheck(e, () => e.texParameteri(c, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)), r.callAndCheck(e, () => e.texParameteri(c, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), r.callAndCheck(e, () => e.texParameteri(c, e.TEXTURE_MIN_FILTER, e.NEAREST)), r.callAndCheck(e, () => e.texParameteri(c, e.TEXTURE_MAG_FILTER, e.NEAREST)), r.callAndCheck(e, () => e.texImage2D(c, 0, a, t, n, 0, o, u, null)), r.callAndCheck(e, () => e.bindTexture(e.TEXTURE_2D, null)), i
        }

        function l(e) {
            return e.internalFormatFloat
        }

        function x(e, r, n, a) {
            const [o, u] = t.getUnpackedMatrixTextureShapeWidthHeight(r, n);
            return c(e, o, u, l(a), a.textureFormatFloat, e.FLOAT)
        }

        function d(e) {
            return e.internalFormatHalfFloat
        }

        function f(e, r, n, a) {
            const [o, u] = t.getUnpackedMatrixTextureShapeWidthHeight(r, n);
            return c(e, o, u, d(a), a.textureFormatFloat, a.textureTypeHalfFloat)
        }

        function T(e) {
            return e.downloadTextureFormat
        }

        function F(e, r, n, a) {
            const [o, u] = t.getUnpackedMatrixTextureShapeWidthHeight(r, n);
            return c(e, o, u, T(a), e.RGBA, e.UNSIGNED_BYTE)
        }

        function A(e) {
            return e.internalFormatPackedFloat
        }

        function s(e, r, n, a) {
            const [o, u] = t.getPackedMatrixTextureShapeWidthHeight(r, n);
            return c(e, o, u, A(a), e.RGBA, e.FLOAT)
        }

        function E(e) {
            return e.internalFormatPackedHalfFloat
        }

        function p(e, r, n, a) {
            const [o, u] = t.getPackedMatrixTextureShapeWidthHeight(r, n);
            return c(e, o, u, E(a), e.RGBA, a.textureTypeHalfFloat)
        }

        function P(e, t, n) {
            return r.callAndCheck(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), r.bindVertexBufferToProgramAttribute(e, t, "clipSpacePos", n, 3, 20, 0) && r.bindVertexBufferToProgramAttribute(e, t, "uv", n, 2, 20, 12)
        }

        function _(e, t, n, a, o, u) {
            let i, c, l;
            r.callAndCheck(e, () => e.bindTexture(e.TEXTURE_2D, t)), o instanceof Uint8Array ? (i = new Uint8Array(n * a * 4), c = e.UNSIGNED_BYTE, l = e.RGBA) : (i = new Float32Array(n * a * 4), c = e.FLOAT, l = u.internalFormatPackedFloat), i.set(o), r.callAndCheck(e, () => e.texImage2D(e.TEXTURE_2D, 0, l, n, a, 0, e.RGBA, c, i)), r.callAndCheck(e, () => e.bindTexture(e.TEXTURE_2D, null))
        }

        function h(e, t, n) {
            r.callAndCheck(e, () => e.bindTexture(e.TEXTURE_2D, t)), n.data instanceof Uint8Array ? r.callAndCheck(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)) : r.callAndCheck(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)), r.callAndCheck(e, () => e.bindTexture(e.TEXTURE_2D, null))
        }

        function B(e, t, n, a) {
            const o = e.createBuffer();
            r.callAndCheck(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, o));
            const u = 16 * t * n;
            return r.callAndCheck(e, () => e.bufferData(e.PIXEL_PACK_BUFFER, u, e.STREAM_READ)), r.callAndCheck(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)), r.callAndCheck(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, null)), o
        }

        function R(e, t, r) {
            const n = e,
                a = new Float32Array(r);
            return n.bindBuffer(n.PIXEL_PACK_BUFFER, t), n.getBufferSubData(n.PIXEL_PACK_BUFFER, 0, a), n.bindBuffer(n.PIXEL_PACK_BUFFER, null), a
        }

        function U(e, n, a, o) {
            const [u, i] = t.getUnpackedMatrixTextureShapeWidthHeight(n, a), c = new Uint8Array(t.getUnpackedArraySizeFromMatrixSize(n * a, 4));
            return r.callAndCheck(e, () => e.readPixels(0, 0, u, i, o.downloadTextureFormat, e.UNSIGNED_BYTE, c)), new Float32Array(c.buffer)
        }

        function g(e, r, n, a, o, u, i, c) {
            const l = e,
                x = new Float32Array(t.getPackedRGBAArraySizeFromMatrixShape(u, i));
            return l.bindBuffer(l.PIXEL_PACK_BUFFER, r), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, x), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), x
        }

        function k(e, t, n) {
            const a = new Float32Array(t * n * 4);
            return r.callAndCheck(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, a)), a
        }
    }, {
        "./glsl_version": "QbWp",
        "./tex_util": "hBHG",
        "./webgl_util": "p3g2"
    }],
    "AZP2": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.linearSearchLastTrue = l, exports.GPGPUContext = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./canvas_util"),
            r = n(require("./gpgpu_util")),
            i = n(require("./tex_util")),
            o = n(require("./webgl_util"));

        function s() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return s = function() {
                return e
            }, e
        }

        function n(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = s();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var n = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                    n && (n.get || n.set) ? Object.defineProperty(r, o, n) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }
        class u {
            constructor(s) {
                this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
                const n = (0, e.env)().getNumber("WEBGL_VERSION");
                null != s ? (this.gl = s, (0, t.setWebGLContext)(n, s)) : this.gl = (0, t.getWebGLContext)(n);
                let u = "WEBGL_color_buffer_float";
                if (1 === (0, e.env)().getNumber("WEBGL_VERSION")) {
                    const t = "OES_texture_float",
                        r = "OES_texture_half_float";
                    if (this.textureFloatExtension = o.getExtensionOrThrow(this.gl, t), o.hasExtension(this.gl, r)) this.textureHalfFloatExtension = o.getExtensionOrThrow(this.gl, r);
                    else if ((0, e.env)().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
                    if (this.colorBufferFloatExtension = this.gl.getExtension(u), o.hasExtension(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = o.getExtensionOrThrow(this.gl, "EXT_color_buffer_half_float");
                    else if ((0, e.env)().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
                } else if (u = "EXT_color_buffer_float", o.hasExtension(this.gl, u)) this.colorBufferFloatExtension = this.gl.getExtension(u);
                else {
                    if (!o.hasExtension(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
                    this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float")
                }
                this.vertexBuffer = r.createVertexBuffer(this.gl), this.indexBuffer = r.createIndexBuffer(this.gl), this.framebuffer = o.createFramebuffer(this.gl), this.textureConfig = i.getTextureConfig(this.gl, this.textureHalfFloatExtension)
            }
            get debug() {
                return (0, e.env)().getBool("DEBUG")
            }
            dispose() {
                if (this.disposed) return;
                null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
                const e = this.gl;
                o.callAndCheck(e, () => e.finish()), o.callAndCheck(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), o.callAndCheck(e, () => e.deleteFramebuffer(this.framebuffer)), o.callAndCheck(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), o.callAndCheck(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), o.callAndCheck(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = !0
            }
            createFloat32MatrixTexture(e, t) {
                return this.throwIfDisposed(), r.createFloat32MatrixTexture(this.gl, e, t, this.textureConfig)
            }
            createFloat16MatrixTexture(e, t) {
                return this.throwIfDisposed(), r.createFloat16MatrixTexture(this.gl, e, t, this.textureConfig)
            }
            createUnsignedBytesMatrixTexture(e, t) {
                return this.throwIfDisposed(), r.createUnsignedBytesMatrixTexture(this.gl, e, t, this.textureConfig)
            }
            uploadPixelDataToTexture(e, t) {
                this.throwIfDisposed(), r.uploadPixelDataToTexture(this.gl, e, t)
            }
            uploadDenseMatrixToTexture(e, t, i, o) {
                this.throwIfDisposed(), r.uploadDenseMatrixToTexture(this.gl, e, t, i, o, this.textureConfig)
            }
            createFloat16PackedMatrixTexture(e, t) {
                return this.throwIfDisposed(), r.createFloat16PackedMatrixTexture(this.gl, e, t, this.textureConfig)
            }
            createPackedMatrixTexture(e, t) {
                return this.throwIfDisposed(), r.createPackedMatrixTexture(this.gl, e, t, this.textureConfig)
            }
            deleteMatrixTexture(e) {
                this.throwIfDisposed(), this.outputTexture === e && (o.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer), this.outputTexture = null), o.callAndCheck(this.gl, () => this.gl.deleteTexture(e))
            }
            downloadByteEncodedFloatMatrixFromOutputTexture(e, t, i) {
                return this.downloadMatrixDriver(e, () => r.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, t, i, this.textureConfig))
            }
            downloadPackedMatrixFromBuffer(e, t, i, o, s, n) {
                return r.downloadPackedMatrixFromBuffer(this.gl, e, t, i, o, s, n, this.textureConfig)
            }
            downloadFloat32MatrixFromBuffer(e, t) {
                return r.downloadFloat32MatrixFromBuffer(this.gl, e, t)
            }
            createBufferFromTexture(e, t, i) {
                this.bindTextureToFrameBuffer(e);
                const o = r.createBufferFromOutputTexture(this.gl, t, i, this.textureConfig);
                return this.unbindTextureToFrameBuffer(), o
            }
            createAndWaitForFence() {
                const e = this.createFence(this.gl);
                return this.pollFence(e)
            }
            createFence(t) {
                let r, i;
                if ((0, e.env)().getBool("WEBGL_FENCE_API_ENABLED")) {
                    const e = t,
                        o = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    t.flush(), i = (() => {
                        const t = e.clientWaitSync(o, 0, 0);
                        return t === e.ALREADY_SIGNALED || t === e.CONDITION_SATISFIED
                    }), r = o
                } else(0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (r = this.beginQuery(), this.endQuery(), i = (() => this.isQueryAvailable(r, (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))) : i = (() => !0);
                return {
                    query: r,
                    isFencePassed: i
                }
            }
            downloadMatrixFromPackedTexture(e, t, i) {
                return this.downloadMatrixDriver(e, () => r.downloadMatrixFromPackedOutputTexture(this.gl, t, i))
            }
            createProgram(e) {
                this.throwIfDisposed();
                const t = this.gl,
                    i = o.createFragmentShader(t, e),
                    s = r.createVertexShader(t),
                    n = o.createProgram(t);
                return o.callAndCheck(t, () => t.attachShader(n, s)), o.callAndCheck(t, () => t.attachShader(n, i)), o.linkProgram(t, n), this.debug && o.validateProgram(t, n), this.vertexAttrsAreBound || (this.setProgram(n), this.vertexAttrsAreBound = r.bindVertexProgramAttributeStreams(t, this.program, this.vertexBuffer)), n
            }
            deleteProgram(e) {
                this.throwIfDisposed(), e === this.program && (this.program = null), null != e && o.callAndCheck(this.gl, () => this.gl.deleteProgram(e))
            }
            setProgram(e) {
                this.throwIfDisposed(), this.program = e, null != this.program && this.debug && o.validateProgram(this.gl, this.program), o.callAndCheck(this.gl, () => this.gl.useProgram(e))
            }
            getUniformLocation(e, t, r = !0) {
                return this.throwIfDisposed(), r ? o.getProgramUniformLocationOrThrow(this.gl, e, t) : o.getProgramUniformLocation(this.gl, e, t)
            }
            getAttributeLocation(e, t) {
                return this.throwIfDisposed(), o.callAndCheck(this.gl, () => this.gl.getAttribLocation(e, t))
            }
            getUniformLocationNoThrow(e, t) {
                return this.throwIfDisposed(), this.gl.getUniformLocation(e, t)
            }
            setInputMatrixTexture(e, t, r) {
                this.throwIfDisposed(), this.throwIfNoProgram(), o.bindTextureToProgramUniformSampler(this.gl, e, t, r)
            }
            setOutputMatrixTexture(e, t, r) {
                this.setOutputMatrixTextureDriver(e, r, t)
            }
            setOutputPackedMatrixTexture(e, t, r) {
                this.throwIfDisposed();
                const [o, s] = i.getPackedMatrixTextureShapeWidthHeight(t, r);
                this.setOutputMatrixTextureDriver(e, o, s)
            }
            setOutputMatrixWriteRegion(e, t, r, i) {
                this.setOutputMatrixWriteRegionDriver(r, e, i, t)
            }
            setOutputPackedMatrixWriteRegion(e, t, r, i) {
                throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
            }
            debugValidate() {
                null != this.program && o.validateProgram(this.gl, this.program), o.validateFramebuffer(this.gl)
            }
            executeProgram() {
                this.throwIfDisposed(), this.throwIfNoProgram();
                const e = this.gl;
                this.debug && this.debugValidate(), o.callAndCheck(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0))
            }
            blockUntilAllProgramsCompleted() {
                this.throwIfDisposed(), o.callAndCheck(this.gl, () => this.gl.finish())
            }
            getQueryTimerExtension() {
                return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = o.getExtensionOrThrow(this.gl, 2 === (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
            }
            getQueryTimerExtensionWebGL2() {
                return this.getQueryTimerExtension()
            }
            getQueryTimerExtensionWebGL1() {
                return this.getQueryTimerExtension()
            }
            beginQuery() {
                if (2 === (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    const e = this.gl,
                        t = this.getQueryTimerExtensionWebGL2(),
                        r = e.createQuery();
                    return e.beginQuery(t.TIME_ELAPSED_EXT, r), r
                }
                const t = this.getQueryTimerExtensionWebGL1(),
                    r = t.createQueryEXT();
                return t.beginQueryEXT(t.TIME_ELAPSED_EXT, r), r
            }
            endQuery() {
                if (2 === (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    const e = this.gl,
                        t = this.getQueryTimerExtensionWebGL2();
                    return void e.endQuery(t.TIME_ELAPSED_EXT)
                }
                const t = this.getQueryTimerExtensionWebGL1();
                t.endQueryEXT(t.TIME_ELAPSED_EXT)
            }
            async waitForQueryAndGetTime(t) {
                return await e.util.repeatedTry(() => this.disposed || this.isQueryAvailable(t, (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(t, (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
            }
            getQueryTime(e, t) {
                if (0 === t) return null;
                if (2 === t) {
                    const t = this.gl;
                    return t.getQueryParameter(e, t.QUERY_RESULT) / 1e6
                } {
                    const t = this.getQueryTimerExtensionWebGL1();
                    return t.getQueryObjectEXT(e, t.QUERY_RESULT_EXT) / 1e6
                }
            }
            isQueryAvailable(e, t) {
                if (0 === t) return !0;
                if (2 === t) {
                    const t = this.gl,
                        r = this.getQueryTimerExtensionWebGL2(),
                        i = t.getQueryParameter(e, t.QUERY_RESULT_AVAILABLE);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint
                } {
                    const t = this.getQueryTimerExtensionWebGL1(),
                        r = t.getQueryObjectEXT(e, t.QUERY_RESULT_AVAILABLE_EXT);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(t.GPU_DISJOINT_EXT)), r && !this.disjoint
                }
            }
            pollFence(e) {
                return new Promise(t => {
                    this.addItemToPoll(() => e.isFencePassed(), () => t())
                })
            }
            pollItems() {
                const e = l(this.itemsToPoll.map(e => e.isDoneFn));
                for (let t = 0; t <= e; ++t) {
                    const {
                        resolveFn: e
                    } = this.itemsToPoll[t];
                    e()
                }
                this.itemsToPoll = this.itemsToPoll.slice(e + 1)
            }
            addItemToPoll(t, r) {
                this.itemsToPoll.push({
                    isDoneFn: t,
                    resolveFn: r
                }), this.itemsToPoll.length > 1 || e.util.repeatedTry(() => (this.pollItems(), 0 === this.itemsToPoll.length))
            }
            bindTextureToFrameBuffer(e) {
                this.throwIfDisposed(), o.bindColorTextureToFramebuffer(this.gl, e, this.framebuffer), this.debug && o.validateFramebuffer(this.gl)
            }
            unbindTextureToFrameBuffer() {
                null != this.outputTexture ? (o.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer), this.debug && o.validateFramebuffer(this.gl)) : o.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer)
            }
            downloadMatrixDriver(e, t) {
                this.bindTextureToFrameBuffer(e);
                const r = t();
                return this.unbindTextureToFrameBuffer(), r
            }
            setOutputMatrixTextureDriver(e, t, r) {
                this.throwIfDisposed();
                const i = this.gl;
                o.bindColorTextureToFramebuffer(i, e, this.framebuffer), this.debug && o.validateFramebuffer(i), this.outputTexture = e, o.callAndCheck(i, () => i.viewport(0, 0, t, r)), o.callAndCheck(i, () => i.scissor(0, 0, t, r))
            }
            setOutputMatrixWriteRegionDriver(e, t, r, i) {
                this.throwIfDisposed(), o.callAndCheck(this.gl, () => this.gl.scissor(e, t, r, i))
            }
            throwIfDisposed() {
                if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
            }
            throwIfNoProgram() {
                if (null == this.program) throw new Error("No GPU program is currently set.")
            }
        }

        function l(e) {
            let t = 0;
            for (; t < e.length; ++t) {
                if (!e[t]()) break
            }
            return t - 1
        }
        exports.GPGPUContext = u;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./canvas_util": "S11S",
        "./gpgpu_util": "LB6l",
        "./tex_util": "hBHG",
        "./webgl_util": "p3g2"
    }],
    "hS5V": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.compileProgram = n, exports.runProgram = i, exports.makeShaderKey = s;
        var e = require("@tensorflow/tfjs-core"),
            t = r(require("./shader_compiler"));

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function r(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(r, o, i) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function n(a, r, n, o) {
            const i = r.userCode,
                s = n.map((e, t) => {
                    const a = {
                        logicalShape: e.shape,
                        texShape: e.isUniform ? null : e.texData.texShape,
                        isUniform: e.isUniform,
                        isPacked: !e.isUniform && e.texData.isPacked,
                        flatOffset: null
                    };
                    return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (a.flatOffset = e.texData.slice.flatOffset), {
                        name: r.variableNames[t],
                        shapeInfo: a
                    }
                }),
                f = s.map(e => e.shapeInfo),
                l = {
                    logicalShape: o.shape,
                    texShape: o.texData.texShape,
                    isUniform: !1,
                    isPacked: o.texData.isPacked,
                    flatOffset: null
                },
                u = t.makeShader(s, l, i, r.packedInputs),
                c = a.createProgram(u);
            let p = null;
            const m = a.getUniformLocation(c, "NAN", !1);
            1 === (0, e.env)().getNumber("WEBGL_VERSION") && (p = a.getUniformLocation(c, "INFINITY", !1));
            const h = {};
            for (let e = 0; e < r.variableNames.length; e++) {
                const t = r.variableNames[e],
                    n = !1;
                h[t] = a.getUniformLocation(c, t, n), h[`offset${t}`] = a.getUniformLocation(c, `offset${t}`, n)
            }
            return {
                program: r,
                source: u,
                webGLProgram: c,
                uniformLocations: h,
                inShapeInfos: f,
                outShapeInfo: l,
                infLoc: p,
                nanLoc: m
            }
        }

        function o(t, a) {
            if (t.length !== a.length) throw Error(`Binary was compiled with ${t.length} inputs, but ` + `was executed with ${a.length} inputs`);
            t.forEach((t, r) => {
                const n = t.logicalShape,
                    o = a[r],
                    i = o.shape;
                if (!e.util.arraysEqual(n, i)) throw Error("Binary was compiled with different shapes than " + `the current args. Shapes ${n} and ${i} must match`);
                if (t.isUniform && o.isUniform) return;
                const s = t.texShape,
                    f = o.isUniform ? null : o.texData.texShape;
                if (!e.util.arraysEqual(s, f)) throw Error("Binary was compiled with different texture shapes than the" + ` current args. Shape ${s} and ${f} must match`)
            })
        }

        function i(t, a, r, n, i) {
            o(a.inShapeInfos, r), o([a.outShapeInfo], [n]);
            const s = n.texData.texture,
                f = n.texData.texShape;
            n.texData.isPacked ? t.setOutputPackedMatrixTexture(s, f[0], f[1]) : t.setOutputMatrixTexture(s, f[0], f[1]), t.setProgram(a.webGLProgram), 1 === (0, e.env)().getNumber("WEBGL_VERSION") && null !== a.infLoc && t.gl.uniform1f(a.infLoc, 1 / 0), null !== a.nanLoc && t.gl.uniform1f(a.nanLoc, NaN), r.forEach((r, n) => {
                const o = a.program.variableNames[n],
                    i = a.uniformLocations[o],
                    s = a.uniformLocations[`offset${o}`];
                if (null != i)
                    if (r.isUniform)
                        if (e.util.sizeFromShape(r.shape) < 2) t.gl.uniform1f(i, r.uniformValues[0]);
                        else {
                            let e = r.uniformValues;
                            e instanceof Float32Array || (e = new Float32Array(e)), t.gl.uniform1fv(i, e)
                        }
                else null != r.texData.slice && null != s && t.gl.uniform1i(s, r.texData.slice.flatOffset), t.setInputMatrixTexture(r.texData.texture, i, n)
            }), null != i && i(t, a.webGLProgram), t.executeProgram()
        }

        function s(e, t, a) {
            let r = "";
            t.concat(a).forEach(e => {
                const t = null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0,
                    a = e.isUniform ? "uniform" : e.texData.texShape;
                r += `${e.shape}_${a}_${t}`
            });
            const n = e.userCode;
            let o = e.constructor.name;
            return o += "_" + r + "_" + n
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./shader_compiler": "DIKY"
    }],
    "j6dQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Im2ColPackedProgram = void 0;
        var n = require("./glsl_version");
        class e {
            constructor(e, t, i) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
                const {
                    filterWidth: s,
                    inChannels: o,
                    strideWidth: r,
                    strideHeight: d,
                    padInfo: l,
                    outWidth: c,
                    dilationWidth: a,
                    dilationHeight: f,
                    dataFormat: $
                } = i, {
                    left: h,
                    top: p
                } = l, u = o * s, m = (0, n.getGlslDifferences)(), v = "channelsLast" === $, g = v ? 0 : 1, x = v ? 1 : 2;
                let D = "";
                for (let n = 0; n <= 1; n++)
                    for (let i = 0; i <= 1; i++) D += `\n          blockIndex = rc.y + ${i};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${c})) * ${d} - ${p};\n            d0 = offsetY + ${f} * (pos / ${u});\n\n            if(d0 < ${t[g]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${c}.) * ${r}. - ${h}.);\n              d1 = offsetX + ${a} * (int(mod(float(pos), ${u}.) / ${o}.));\n\n              if(d1 < ${t[x]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${v}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+i}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+i}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;
                this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${D}\n\n        ${m.output} = result;\n      }\n    `
            }
        }
        exports.Im2ColPackedProgram = e;
    }, {
        "./glsl_version": "QbWp"
    }],
    "DLwU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.LRNProgram = void 0;
        class t {
            constructor(t, o, n, s, e) {
                this.variableNames = ["x"], this.outputShape = [];
                const r = o,
                    i = t[3] - 1;
                let a;
                this.outputShape = t;
                const d = `float(${n}) + float(${s}) * sum`;
                a = .5 === e ? `inversesqrt(${d})` : 1 === e ? `1.0/(${d})` : `exp(log(${d}) * float(-${e}));`, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${r}; j <= ${r}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `
            }
        }
        exports.LRNProgram = t;
    }, {}],
    "xmP3": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.LRNGradProgram = void 0;
        class n {
            constructor(n, t, e, i, o) {
                this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = n, this.depth = n[3], this.depthRadius = t, this.bias = e, this.alpha = i, this.beta = o, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${e});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `
            }
        }
        exports.LRNGradProgram = n;
    }, {}],
    "sdWO": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.LRNPackedProgram = void 0;
        class e {
            constructor(e, n, t, o, a) {
                this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
                const r = n,
                    c = e[3] - 1;
                let s;
                this.outputShape = e;
                const u = `float(${t}) + float(${o}) * sum`;
                s = .5 === a ? `inversesqrt(${u})` : 1 === a ? `1.0/(${u})` : `exp(log(${u}) * float(-${a}));`, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${r};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${r}; j <= ${r}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${c}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `
            }
        }
        exports.LRNPackedProgram = e;
    }, {}],
    "trD0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.MaxPool3DBackpropProgram = exports.MaxPool2DBackpropProgram = void 0;
        class n {
            constructor(n) {
                this.variableNames = ["dy", "maxPos"], this.outputShape = n.inShape;
                const t = n.strideHeight,
                    o = n.strideWidth,
                    e = n.dilationHeight,
                    i = n.effectiveFilterHeight,
                    d = n.effectiveFilterWidth,
                    r = i - 1 - n.padInfo.top,
                    a = d - 1 - n.padInfo.left,
                    s = i * d - 1;
                this.userCode = `\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${e}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${d} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.MaxPool2DBackpropProgram = n;
        class t {
            constructor(n) {
                this.variableNames = ["dy", "maxPos"], this.outputShape = n.inShape;
                const t = n.strideDepth,
                    o = n.strideHeight,
                    e = n.strideWidth,
                    i = n.dilationDepth,
                    d = n.dilationHeight,
                    r = n.dilationWidth,
                    a = n.effectiveFilterDepth,
                    s = n.effectiveFilterHeight,
                    y = n.effectiveFilterWidth,
                    c = a - 1 - n.padInfo.front,
                    l = s - 1 - n.padInfo.top,
                    C = y - 1 - n.padInfo.left,
                    f = a * s * y - 1;
                this.userCode = `\n      const ivec3 pads = ivec3(${c}, ${l}, ${C});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${a};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${s};\n              wR += ${d}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${y};\n                wC += ${r}) {\n              float dyC = float(dyCCorner + wC) / ${e}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${f} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${s} * ${y} +\n                  wR * ${y} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        exports.MaxPool3DBackpropProgram = t;
    }, {}],
    "UauI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.MatMulPackedProgram = void 0;
        class t {
            constructor(t, e, s = !1, n = !1, r = !1, i = null, a = !1) {
                this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
                const c = s ? t[1] : t[2],
                    o = Math.ceil(c / 2),
                    u = s ? "i * 2, rc.y" : "rc.y, i * 2",
                    l = n ? "rc.z, i * 2" : "i * 2, rc.z",
                    v = s ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
                    d = n ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
                let x = "",
                    p = "";
                i && (x = a ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }` : `vec4 activation(vec4 x) {\n          ${i}\n        }`, p = "result = activation(result);");
                const h = r ? "result += getBiasAtOutCoords();" : "";
                r && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), this.userCode = `\n      ${x}\n\n      const float sharedDimension = ${o}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${o}; i++) {\n          vec4 a = getMatrixA(rc.x, ${u});\n          vec4 b = getMatrixB(rc.x, ${l});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${v[0]} * ${d[0]});\n          result += (${v[1]} * ${d[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${h}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `
            }
        }
        exports.MatMulPackedProgram = t;
    }, {}],
    "j5oG": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.MultinomialProgram = void 0;
        class t {
            constructor(t, e, n) {
                this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `
            }
            getCustomSetupFunc(t) {
                return (e, n) => {
                    null == this.seedLoc && (this.seedLoc = e.getUniformLocation(n, "seed")), e.gl.uniform1f(this.seedLoc, t)
                }
            }
        }
        exports.MultinomialProgram = t;
    }, {}],
    "Nv1m": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.OneHotProgram = void 0;
        class o {
            constructor(o, t, e, s) {
                this.variableNames = ["indices"], this.outputShape = [o, t], this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${e}),\n                      float(index == coords.y)));\n      }\n    `
            }
        }
        exports.OneHotProgram = o;
    }, {}],
    "kEpT": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.PackProgram = void 0;
        var t = require("./packing_util"),
            e = require("./shader_compiler");
        class n {
            constructor(n) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = n;
                const r = n.length;
                if (0 === r) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
                else {
                    const u = (0, t.getChannels)("rc", r),
                        i = (0, e.getCoordsDataType)(r),
                        g = c(r, n, u),
                        p = o(r, n[n.length - 1], n[n.length - 2], u),
                        l = s(n, u);
                    this.userCode = `\n        void main() {\n          ${i} rc = getOutputCoords();\n\n          if(${g}) {\n            setOutput(vec4(0));\n          } else {\n            ${p}\n\n            setOutput(vec4(${l}));\n          }\n        }\n      `
                }
            }
        }

        function r(t, e) {
            const n = [];
            for (let r = 0; r <= 1; r++)
                for (let c = 0; c <= 1; c++) {
                    let o = `${0===r?"r":"rp1"}, ${0===c?"c":"cp1"}`;
                    for (let n = 2; n < t; n++) o = `${e[e.length-1-n]},` + o;
                    n.push(o)
                }
            return n
        }

        function c(t, e, n) {
            if (1 === t) return `rc > ${e[0]}`;
            let r = "";
            for (let c = t - 2; c < t; c++) r += `${n[c]} >= ${e[c]}`, c < t - 1 && (r += "||");
            return r
        }

        function o(t, e, n, r) {
            if (1 === t) return "";
            const c = r.slice(-2);
            return `\n    int r = ${c[0]};\n    int c = ${c[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `
        }

        function s(t, e) {
            const n = t.length,
                c = r(n, e);
            return 1 === n ? `getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0` : `getA(${c[0]}),\n          cEdge ? 0. : getA(${c[1]}),\n          rEdge ? 0. : getA(${c[2]}),\n          rEdge || cEdge ? 0. : getA(${c[3]})`
        }
        exports.PackProgram = n;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "psrI": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.PadProgram = void 0;
        var t = require("./shader_compiler");
        class n {
            constructor(n, o, e) {
                this.variableNames = ["x"], this.outputShape = o.map((t, o) => t[0] + n[o] + t[1]);
                const s = n.length,
                    r = (0, t.getCoordsDataType)(s),
                    a = o.map(t => t[0]).join(","),
                    u = o.map((t, o) => t[0] + n[o]).join(","),
                    d = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s);
                this.userCode = 1 !== s ? `\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${u});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${e}));\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${d}));\n        }\n      }\n    ` : `\n        int start = ${a};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${e}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `
            }
        }
        exports.PadProgram = n;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "oRHP": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.PadPackedProgram = void 0;
        var t = require("./packing_util"),
            e = require("./shader_compiler");
        class n {
            constructor(n, r, s) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = r.map((t, e) => t[0] + n[e] + t[1]);
                const a = n.length,
                    o = (0, e.getCoordsDataType)(a),
                    u = r.map(t => t[0]).join(","),
                    c = r.map((t, e) => t[0] + n[e]).join(","),
                    i = (0, t.getChannels)("rc", a),
                    $ = (0, t.getChannels)("source", a),
                    p = `${i[a-1]} < ${this.outputShape[a-1]}`,
                    l = 1 === a ? "source" : `vec2(${$.slice(-2).join()})`,
                    d = [`${o} rc = outputLoc;`, `${i[a-1]} += 1;\n       if(${p}) {\n      `, 1 === a ? "" : `}\n       rc = outputLoc;\n       ${i[a-2]} += 1;\n       if(${i[a-2]} < ${this.outputShape[a-2]}) {`, 1 === a ? "" : `  ${i[a-1]} += 1;\n         if(${p}) {`],
                    h = 1 === a ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
                let g = "";
                for (let t = 0, e = 1 === a ? 2 : 4; t < e; t++) g += `\n        ${d[t]}\n        if (${h}) {\n          result[${t}] = float(${s});\n        } else {\n          ${o} source = rc - start;\n          result[${t}] = getChannel(getX(${$.join()}), ${l});\n        }\n      `;
                g += 1 === a ? "} " : "}}", this.userCode = `\n      const ${o} start = ${o}(${u});\n      const ${o} end = ${o}(${c});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${g}\n        setOutput(result);\n      }\n    `
            }
        }
        exports.PadPackedProgram = n;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "DAMt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Pool3DProgram = exports.Pool2DProgram = void 0;
        class n {
            constructor(n, e, t, i = !1, a = !1) {
                if (this.variableNames = ["x"], "avg" === e && t) throw new Error("Cannot compute positions for average pool.");
                const o = n.filterWidth,
                    x = n.strideHeight,
                    r = n.strideWidth,
                    c = n.dilationHeight,
                    l = n.dilationWidth,
                    u = n.effectiveFilterHeight,
                    s = n.effectiveFilterWidth,
                    C = n.padInfo.top,
                    d = n.padInfo.left;
                this.outputShape = n.outShape;
                const $ = "avg" === e,
                    h = `((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,
                    v = `(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;
                let f = "0.0";
                if ($ || (f = "-1.0 / 1e-20"), t) {
                    const e = ">=";
                    return void(this.userCode = `\n        const ivec2 strides = ivec2(${x}, ${r});\n        const ivec2 pads = ivec2(${C}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${s};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?a?h:v:`wR * ${s} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
                }
                let R = `${e}(${e}(${e}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === e && (R = "avgValue / count");
                const V = 4 * Math.floor(o / 4),
                    g = o % 4,
                    m = `\n      if (${$}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
                this.userCode = `\n      const ivec2 strides = ivec2(${x}, ${r});\n      const ivec2 pads = ivec2(${C}, ${d});\n      const float initializationValue = ${f};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${f});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${V}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${m}\n          }\n\n          int xC = xCCorner + ${V};\n          if (${1===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${m}\n          } else if (${2===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${m}\n          } else if (${3===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${m}\n          }\n        }\n        setOutput(${R});\n      }\n    `
            }
        }
        exports.Pool2DProgram = n;
        class e {
            constructor(n, e, t, i = !1, a = !1) {
                if (this.variableNames = ["x"], "avg" === e && t) throw new Error("Cannot compute positions for average pool.");
                const o = n.filterWidth,
                    x = n.strideDepth,
                    r = n.strideHeight,
                    c = n.strideWidth,
                    l = n.dilationDepth,
                    u = n.dilationHeight,
                    s = n.dilationWidth,
                    C = n.effectiveFilterDepth,
                    d = n.effectiveFilterHeight,
                    $ = n.effectiveFilterWidth,
                    h = n.padInfo.front,
                    v = n.padInfo.top,
                    f = n.padInfo.left;
                this.outputShape = n.outShape;
                const R = "avg" === e;
                let V = "0.0";
                if (R || (V = "-1.0 / 1e-20"), t) {
                    const e = ">=";
                    return void(this.userCode = `\n        const ivec3 strides =\n            ivec3(${x}, ${r}, ${c});\n        const ivec3 pads = ivec3(${h}, ${v}, ${f});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${C};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${$};\n                  wC += ${s}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?a?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${d} * ${$} +\n                      wR * ${$} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
                }
                let g = `${e}(${e}(${e}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === e && (g = "avgValue / count");
                const m = 4 * Math.floor(o / 4),
                    w = o % 4,
                    p = `\n      if (${R}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
                this.userCode = `\n      const ivec3 strides =\n        ivec3(${x}, ${r}, ${c});\n      const ivec3 pads = ivec3(${h}, ${v}, ${f});\n      const float initializationValue = ${V};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${V});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${C};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${m}; wC += 4) {\n              int xC = xCCorner + wC * ${s};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${s}, ch)\n              );\n\n              ${p}\n            }\n\n            int xC = xCCorner + ${m};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${p}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${p}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\n                initializationValue\n              );\n\n              ${p}\n            }\n          }\n          setOutput(${g});\n        }\n      }\n    `
            }
        }
        exports.Pool3DProgram = e;
    }, {}],
    "cqVi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ReduceProgram = void 0;
        class n {
            constructor(n, e) {
                this.variableNames = ["x"];
                const a = n.windowSize,
                    l = n.batchSize,
                    t = n.inSize,
                    i = Math.ceil(t / a);
                this.outputShape = [l, i];
                let u = "0.0",
                    o = "";
                "prod" === e ? u = "1.0" : "min" === e ? (u = "1.0 / 1e-20", o = "min") : "max" === e && (u = "-1.0 / 1e-20", o = "max");
                let d = `${e}(${e}(${e}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "sum" === e ? d = "sumValue" : "prod" === e ? d = "prodValue" : "all" === e ? d = "allValue" : "any" === e && (d = "anyValue");
                const s = 4 * Math.floor(a / 4),
                    c = a % 4;
                let V = `\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,
                    r = "vec4";
                "all" === e ? (u = "1.0", V = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", r = "bvec4") : "any" === e && (u = "0.0", V = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", r = "bvec4");
                let f = "";
                t % a > 0 && (f = `\n        if (inIdx < 0 || inIdx >= ${t}) {\n          return initializationValue;\n        }\n      `), this.userCode = `\n      const float initializationValue = ${u};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        vec4 minMaxValue = vec4(${u});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${V}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===c}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${V}\n        } else if (${2===c}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${V}\n        } else if (${3===c}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${V}\n        }\n        setOutput(${d});\n      }\n    `
            }
        }
        exports.ReduceProgram = n;
    }, {}],
    "K4kf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ReshapePackedProgram = void 0;
        var t = n(require("./shader_compiler_util"));

        function e() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return e = function() {
                return t
            }, t
        }

        function n(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var n = e();
            if (n && n.has(t)) return n.get(t);
            var r = {},
                i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in t)
                if (Object.prototype.hasOwnProperty.call(t, o)) {
                    var s = i ? Object.getOwnPropertyDescriptor(t, o) : null;
                    s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = t[o]
                } return r.default = t, n && n.set(t, r), r
        }
        class r {
            constructor(e, n) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
                let r = "";
                for (let t = 0; t < 4; t++) {
                    let e = "thisRC = rc;";
                    t % 2 == 1 && (e += "thisRC.z += 1;"), t > 1 && (e += "thisRC.y += 1;"), r += `\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `
                }
                this.userCode = `\n      ${i(n)}\n      ${t.getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `
            }
        }

        function i(e) {
            return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `
        }
        exports.ReshapePackedProgram = r;
    }, {
        "./shader_compiler_util": "vOsJ"
    }],
    "bHYm": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ResizeBilinearBackpropProgram = void 0;
        class t {
            constructor(t, n, e) {
                this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n.shape;
                const [, o, i] = n.shape, [, d, r] = t.shape, a = [e && d > 1 ? o - 1 : o, e && r > 1 ? i - 1 : i], f = [e && d > 1 ? d - 1 : d, e && r > 1 ? r - 1 : r], l = a[0] / f[0], s = a[1] / f[1], x = 1 / l, c = 1 / s, p = 2 * Math.ceil(x) + 2, y = 2 * Math.ceil(c) + 2;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${s});\n\n        const float invHeightScale = float(${x});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${y});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${d}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${r}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
            }
        }
        exports.ResizeBilinearBackpropProgram = t;
    }, {}],
    "BAHS": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ResizeBilinearProgram = void 0;
        class e {
            constructor(e, o, t, n) {
                this.variableNames = ["A"], this.outputShape = [];
                const [c, r, i, s] = e;
                this.outputShape = [c, o, t, s];
                const u = [n && o > 1 ? r - 1 : r, n && t > 1 ? i - 1 : i],
                    a = [n && o > 1 ? o - 1 : o, n && t > 1 ? t - 1 : t];
                this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/a[0]},\n          ${u[1]/a[1]});\n      const vec2 inputShapeRC = vec2(${r}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        exports.ResizeBilinearProgram = e;
    }, {}],
    "QNLw": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ResizeBilinearPackedProgram = void 0;
        class e {
            constructor(e, o, t, n) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
                const [c, r, s, u] = e;
                this.outputShape = [c, o, t, u];
                const l = [n && o > 1 ? r - 1 : r, n && t > 1 ? s - 1 : s],
                    C = [n && o > 1 ? o - 1 : o, n && t > 1 ? t - 1 : t];
                this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/C[0]},\n          ${l[1]/C[1]},\n          ${l[1]/C[1]});\n      const vec3 inputShapeRC = vec3(${r}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        exports.ResizeBilinearPackedProgram = e;
    }, {}],
    "hkPU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ResizeNearestNeigborBackpropProgram = void 0;
        class t {
            constructor(t, n, o) {
                this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n.shape;
                const [, e, a] = n.shape, [, r, i] = t.shape, s = [o && r > 1 ? e - 1 : e, o && i > 1 ? a - 1 : a], f = [o && r > 1 ? r - 1 : r, o && i > 1 ? i - 1 : i], l = s[0] / f[0], c = s[1] / f[1], d = 1 / l, u = 1 / c, y = 2 * Math.ceil(d) + 2, h = 2 * Math.ceil(u) + 2;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${u});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${h});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${f[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${f[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${e}) - 1),\n                ${o} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${o} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
            }
        }
        exports.ResizeNearestNeigborBackpropProgram = t;
    }, {}],
    "T9BX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ResizeNearestNeighborProgram = void 0;
        class e {
            constructor(e, t, o, n) {
                this.variableNames = ["A"], this.outputShape = [];
                const [r, s, c, i] = e;
                this.outputShape = [r, t, o, i];
                const u = [n && t > 1 ? s - 1 : s, n && o > 1 ? c - 1 : c],
                    a = [n && t > 1 ? t - 1 : t, n && o > 1 ? o - 1 : o],
                    p = n ? "0.5" : "0.0";
                this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/a[0]},\n          ${u[1]/a[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        exports.ResizeNearestNeighborProgram = e;
    }, {}],
    "dGqg": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ReverseProgram = void 0;
        var e = require("./shader_compiler");
        class o {
            constructor(o, t) {
                this.variableNames = ["x"];
                const r = o.length;
                if (r > 4) throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
                if (this.outputShape = o, 1 === r) return void(this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${o[0]} - coord - 1));\n        }\n      `);
                const s = o.map((e, r) => (e => -1 !== t.indexOf(e) && 1 !== o[e] ? `${o[e]} - coords[${e}] - 1` : `coords[${e}]`)(r)).join(","),
                    n = (0, e.getCoordsDataType)(r);
                this.userCode = `\n      void main() {\n        ${n} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `
            }
        }
        exports.ReverseProgram = o;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "b6t2": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ReversePackedProgram = void 0;
        var e = require("./packing_util"),
            t = require("./shader_compiler");
        class n {
            constructor(n, r) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
                const s = n.length;
                if (s > 4) throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
                this.outputShape = n;
                const u = (0, e.getChannels)("rc", s),
                    i = `${u[s-1]} + 1 < ${this.outputShape[s-1]}`,
                    o = `${u[s-2]} + 1 < ${this.outputShape[s-2]}`,
                    c = (0, t.getCoordsDataType)(s);

                function a(e) {
                    const t = n.map((t, s) => (function(e, t) {
                        return -1 !== r.indexOf(e) && 1 !== n[e] ? `${n[e]} - ${t[e]} - 1` : `${t[e]}`
                    })(s, e));
                    return `getChannel(getX(${t.join(",")}), vec2(${t.slice(-2).join(",")}))`
                }
                this.userCode = 1 === s ? `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ` : `\n        void main() {\n          ${c} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return a(e)}(u.slice())};\n          if(${i}){\n            result.g = ${function(e){return e[s-1]="("+e[s-1]+" + 1)",a(e)}(u.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[s-2]="("+e[s-2]+" + 1)",a(e)}(u.slice())};\n            if(${i}) {\n              result.a = ${function(e){return e[s-1]="("+e[s-1]+" + 1)",e[s-2]="("+e[s-2]+" + 1)",a(e)}(u.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `
            }
        }
        exports.ReversePackedProgram = n;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "ugST": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ScatterProgram = void 0;
        var e = require("./shader_compiler");
        class t {
            constructor(t, n, o, s, r, d, i = !0) {
                this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = d;
                const a = (0, e.getCoordsDataType)(r.length),
                    u = (0, e.getCoordsDataType)(d.length);
                let l = "";
                1 === o ? l = "i" : 2 === o && (l = "i, j");
                const c = `getIndices(${l})`;
                let f = "";
                1 === s ? f = "i" : 2 === s && (f = "i, coords[1]");
                const p = `getUpdates(${f})`,
                    $ = n > 1 ? "strides[j]" : "strides";
                this.userCode = `\n        ${a} strides = ${a}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${$};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `
            }
        }
        exports.ScatterProgram = t;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "x8Mt": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SegmentOpProgram = void 0;
        class n {
            constructor(n, e) {
                this.variableNames = ["x", "segmentIds"];
                const t = n.windowSize,
                    i = n.batchSize,
                    a = n.inSize,
                    d = n.numSegments,
                    g = d * Math.ceil(a / t);
                this.outputShape = [i, g];
                const I = 4 * Math.floor(t / 4),
                    l = t % 4,
                    u = "\n        sumValue += dot(values, segFilter);\n    ";
                let r = "";
                a % t > 0 && (r = `\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);
                let c = "";
                a % t > 0 && (c = `\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `), this.userCode = `\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${r}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${c}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${d})) * float(${t}));\n        int currentSeg = int(mod(float(outIdx), float(${d})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${I}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${I};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `
            }
        }
        exports.SegmentOpProgram = n;
    }, {}],
    "CDzy": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SelectProgram = void 0;
        var e = require("./shader_compiler");
        class t {
            constructor(t, r, s) {
                let o, n;
                if (this.variableNames = ["c", "a", "b"], this.outputShape = r, s > 4) throw Error(`Where for rank ${s} is not yet supported`);
                if (1 === s) n = "resRC", o = "resRC";
                else {
                    const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                        s = [],
                        a = [];
                    for (let o = 0; o < r.length; o++) a.push(`${e[o]}`), o < t && s.push(`${e[o]}`);
                    o = s.join(), n = a.join()
                }
                const a = (0, e.getCoordsDataType)(s);
                this.userCode = `\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${n}));\n        } else {\n          setOutput(getB(${n}));\n        }\n      }\n    `
            }
        }
        exports.SelectProgram = t;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "SBwi": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SliceProgram = void 0;
        var t = require("./shader_compiler");
        class r {
            constructor(r) {
                this.variableNames = ["source"], this.outputShape = r, this.rank = r.length;
                const s = (0, t.getCoordsDataType)(this.rank),
                    n = `uniform int start[${this.rank}];`,
                    i = e(this.rank);
                let a;
                a = `\n        ${s} sourceLoc;\n        ${s} coords = getOutputCoords();\n        ${r.map((t,r)=>`sourceLoc.${o[r]} = start[${r}] + coords.${o[r]};`).join("\n")}\n      `, this.userCode = `\n      ${n}\n      void main() {\n        ${a}\n        setOutput(getSource(${i}));\n      }\n    `
            }
            getCustomSetupFunc(t) {
                if (t.length !== this.rank) throw Error(`The rank (${this.rank}) of the program must match the ` + `length of start (${t.length})`);
                return (r, o) => {
                    null == this.startLoc && (this.startLoc = r.getUniformLocationNoThrow(o, "start"), null == this.startLoc) || r.gl.uniform1iv(this.startLoc, t)
                }
            }
        }
        exports.SliceProgram = r;
        const o = ["x", "y", "z", "w", "u", "v"];

        function e(t) {
            if (1 === t) return "sourceLoc";
            if (t <= 6) return o.slice(0, t).map(t => "sourceLoc." + t).join(",");
            throw Error(`Slicing for rank ${t} is not yet supported`)
        }
    }, {
        "./shader_compiler": "DIKY"
    }],
    "BaFQ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SlicePackedProgram = void 0;
        var t = require("./packing_util"),
            n = require("./shader_compiler");
        class r {
            constructor(r) {
                this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = r, this.rank = r.length;
                const s = (0, n.getCoordsDataType)(this.rank),
                    e = (0, t.getChannels)("coords", this.rank),
                    i = (0, t.getChannels)("sourceLoc", this.rank),
                    a = 1 === this.rank ? "sourceLoc" : `vec2(${i.slice(-2).join()})`,
                    o = `getChannel(getSource(${i.join()}), ${a})`,
                    h = `\n      result.x = ${o};\n      if (++${e[this.rank-1]} < ${r[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${o};\n        --${i[this.rank-1]};\n      }\n    `,
                    c = 1 === this.rank ? "" : `\n      --${e[this.rank-1]};\n      if (++${e[this.rank-2]} < ${r[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${o};\n        if (++${e[this.rank-1]} < ${r[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,
                    u = this.rank <= 4 ? `sourceLoc = coords +\n            ${s}(${r.map((t,n)=>`start[${n}]`).join()});` : r.map((t, n) => `${i[n]} = ${e[n]} + start[${n}];`).join("\n");
                this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${s} coords = getOutputCoords();\n        ${s} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${h}\n        ${c}\n        setOutput(result);\n      }\n    `
            }
            getCustomSetupFunc(t) {
                if (t.length !== this.rank) throw Error(`The rank (${this.rank}) of the program must match the ` + `length of start (${t.length})`);
                return (n, r) => {
                    null == this.startLoc && (this.startLoc = n.getUniformLocationNoThrow(r, "start"), null == this.startLoc) || n.gl.uniform1iv(this.startLoc, t)
                }
            }
        }
        exports.SlicePackedProgram = r;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "N1kZ": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.StridedSliceProgram = void 0;
        var e = require("./shader_compiler");
        class t {
            constructor(t, s, r) {
                this.variableNames = ["x"], this.outputShape = r;
                const o = r.length,
                    i = (0, e.getCoordsDataType)(r.length),
                    d = (0, e.getCoordsDataType)(r.length);
                let n = "";
                if (1 === o) n = "coords * strides + begin";
                else {
                    let e = 0;
                    n = r.map((t, s) => (e++, 1 === r.length ? `coords * strides[${s}] + begin[${s}]` : `coords[${e-1}] * strides[${s}] + begin[${s}]`)).join(",")
                }
                this.userCode = `\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${s});\n\n      void main() {\n        ${d} coords = getOutputCoords();\n        setOutput(getX(${n}));\n      }\n    `
            }
        }
        exports.StridedSliceProgram = t;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "herW": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.computeBytes = i, exports.TextureManager = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./gpgpu_util"),
            r = require("./tex_util");
        class s {
            constructor(e) {
                this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
            }
            acquireTexture(e, t, s) {
                const u = h(t, s),
                    n = a(e, u, s);
                n in this.freeTextures || (this.freeTextures[n] = []), n in this.usedTextures || (this.usedTextures[n] = []);
                const T = i(e, u, this.gpgpu.gl, this.gpgpu.textureConfig, s);
                if (this.freeTextures[n].length > 0) {
                    this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= T, this.log();
                    const e = this.freeTextures[n].shift();
                    return this.usedTextures[n].push(e), e
                }
                let x;
                return u === r.PhysicalTextureType.PACKED_2X2_FLOAT32 ? x = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : u === r.PhysicalTextureType.PACKED_2X2_FLOAT16 ? x = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : u === r.PhysicalTextureType.UNPACKED_FLOAT32 ? x = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : u === r.PhysicalTextureType.UNPACKED_FLOAT16 ? x = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : u === r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE && (x = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[n].push(x), this.numUsedTextures++, this._numBytesAllocated += T, this.log(), x
            }
            releaseTexture(t, r, s, u) {
                if (null == this.freeTextures) return;
                const n = h(s, u),
                    T = a(r, n, u);
                T in this.freeTextures || (this.freeTextures[T] = []);
                const x = i(r, n, this.gpgpu.gl, this.gpgpu.textureConfig, u),
                    o = (0, e.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD"); - 1 !== o && this._numBytesAllocated > o ? (this.gpgpu.deleteMatrixTexture(t), this._numBytesAllocated -= x) : (this.freeTextures[T].push(t), this.numFreeTextures++, this._numBytesFree += x), this.numUsedTextures--;
                const l = this.usedTextures[T],
                    c = l.indexOf(t);
                if (c < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
                l.splice(c, 1), this.log()
            }
            log() {
                if (!this.logEnabled) return;
                const e = this.numFreeTextures + this.numUsedTextures;
                console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
                const t = this._numBytesFree / this._numBytesAllocated;
                console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)
            }
            get numBytesAllocated() {
                return this._numBytesAllocated
            }
            get numBytesFree() {
                return this._numBytesFree
            }
            getNumUsedTextures() {
                return this.numUsedTextures
            }
            getNumFreeTextures() {
                return this.numFreeTextures
            }
            dispose() {
                if (null != this.freeTextures) {
                    for (const e in this.freeTextures) this.freeTextures[e].forEach(e => {
                        this.gpgpu.deleteMatrixTexture(e)
                    });
                    for (const e in this.usedTextures) this.usedTextures[e].forEach(e => {
                        this.gpgpu.deleteMatrixTexture(e)
                    });
                    this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0
                }
            }
        }

        function u(e, t) {
            const r = e;
            if (t === r.R32F) return 4;
            if (t === r.R16F) return 2;
            if (t === r.RGBA32F) return 16;
            if (t === e.RGBA) return 16;
            if (t === r.RGBA16F) return 8;
            throw new Error(`Unknown internal format ${t}`)
        }

        function i(e, t, s, i, T) {
            const h = n(t, i);
            let a;
            if (T) {
                const [t, s] = (0, r.getPackedMatrixTextureShapeWidthHeight)(e[0], e[1]);
                a = t * s
            } else {
                const [t, s] = (0, r.getUnpackedMatrixTextureShapeWidthHeight)(e[0], e[1]);
                a = t * s
            }
            return a * u(s, h)
        }

        function n(e, s) {
            switch (e) {
                case r.PhysicalTextureType.PACKED_2X2_FLOAT32:
                    return (0, t.getInternalFormatForPackedMatrixTexture)(s);
                case r.PhysicalTextureType.PACKED_2X2_FLOAT16:
                    return (0, t.getInternalFormatForFloat16PackedMatrixTexture)(s);
                case r.PhysicalTextureType.UNPACKED_FLOAT32:
                    return (0, t.getInternalFormatForFloat32MatrixTexture)(s);
                case r.PhysicalTextureType.UNPACKED_FLOAT16:
                    return (0, t.getInternalFormatForFloat16MatrixTexture)(s);
                case r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
                    return (0, t.getInternalFormatForUnsignedBytesMatrixTexture)(s);
                default:
                    throw new Error(`Unknown physical texture type ${e}`)
            }
        }

        function T(t) {
            return (0, e.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? r.PhysicalTextureType.PACKED_2X2_FLOAT32 : r.PhysicalTextureType.UNPACKED_FLOAT32 : t ? r.PhysicalTextureType.PACKED_2X2_FLOAT16 : r.PhysicalTextureType.UNPACKED_FLOAT16
        }

        function h(e, t) {
            if (e === r.TextureUsage.UPLOAD) return r.PhysicalTextureType.PACKED_2X2_FLOAT32;
            if (e === r.TextureUsage.RENDER || null == e) return T(t);
            if (e === r.TextureUsage.DOWNLOAD || e === r.TextureUsage.PIXELS) return r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
            throw new Error(`Unknown logical texture type ${e}`)
        }

        function a(e, t, r) {
            return `${e[0]}_${e[1]}_${t}_${r}`
        }
        exports.TextureManager = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./gpgpu_util": "LB6l",
        "./tex_util": "hBHG"
    }],
    "lZtF": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TileProgram = void 0;
        var e = require("./shader_compiler");
        class r {
            constructor(r, s) {
                this.variableNames = ["A"];
                const o = new Array(r.length);
                for (let e = 0; e < o.length; e++) o[e] = r[e] * s[e];
                this.outputShape = o, this.rank = o.length;
                const n = (0, e.getCoordsDataType)(this.rank),
                    i = t(r);
                this.userCode = `\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `
            }
        }

        function t(e) {
            const r = e.length;
            if (r > 5) throw Error(`Tile for rank ${r} is not yet supported`);
            if (1 === r) return `imod(resRC, ${e[0]})`;
            const t = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
                s = [];
            for (let o = 0; o < e.length; o++) s.push(`imod(${t[o]}, ${e[o]})`);
            return s.join()
        }
        exports.TileProgram = r;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "uzBV": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.STEP = l, exports.CLONE = exports.TO_INT = exports.LOGICAL_NOT = exports.RECIPROCAL = exports.SQUARE = exports.ERF = exports.ATANH = exports.ACOSH = exports.ASINH = exports.TANH = exports.COSH = exports.SINH = exports.ATAN = exports.ACOS = exports.ASIN = exports.TAN = exports.COS = exports.SIN = exports.SOFTPLUS = exports.SIGMOID = exports.RSQRT = exports.SQRT = exports.LOG1P = exports.LOG = exports.EXPM1 = exports.EXP = exports.ROUND = exports.IS_FINITE = exports.IS_INF = exports.IS_NAN = exports.SIGN = exports.FLOOR = exports.CEIL = exports.NEG = exports.SELU = exports.ELU = exports.RELU6 = exports.RELU = exports.ABS = exports.LINEAR = exports.UnaryOpProgram = void 0;
        var t = require("@tensorflow/tfjs-core");
        class n {
            constructor(t, n) {
                this.variableNames = ["A"], this.outputShape = t, this.userCode = `\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
            }
        }
        exports.UnaryOpProgram = n;
        const r = "if (isnan(x)) return x;",
            e = "return x;";
        exports.LINEAR = e;
        const o = "return abs(x);";
        exports.ABS = o;
        const s = r + "\n  return (x < 0.0) ? 0.0 : x;\n";
        exports.RELU = s;
        const x = r + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
        exports.RELU6 = x;
        const a = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
        exports.ELU = a;
        const p = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${t.backend_util.SELU_SCALEALPHA};\n  float scale = ${t.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;

        function l(t = 0) {
            return r + `\n    return x > 0.0 ? 1.0 : float(${t});\n  `
        }
        exports.SELU = p;
        const u = "return -x;";
        exports.NEG = u;
        const i = "return ceil(x);";
        exports.CEIL = i;
        const c = "return floor(x);";
        exports.FLOOR = c;
        const f = "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n";
        exports.SIGN = f;
        const A = "return float(isnan(x));";
        exports.IS_NAN = A;
        const N = "return float(isinf(x));";
        exports.IS_INF = N;
        const S = "return float(!isnan(x) && !isinf(x));";
        exports.IS_FINITE = S;
        const E = "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";
        exports.ROUND = E;
        const O = "return exp(x);";
        exports.EXP = O;
        const I = "return exp(x) - 1.0;";
        exports.EXPM1 = I;
        const _ = "if (x < 0.0) return NAN;\n  return log(x);";
        exports.LOG = _;
        const L = "return log(1.0 + x);";
        exports.LOG1P = L;
        const b = "return sqrt(x);";
        exports.SQRT = b;
        const R = "return inversesqrt(x);";
        exports.RSQRT = R;
        const d = "return 1.0 / (1.0 + exp(-1.0 * x));";
        exports.SIGMOID = d;
        const T = "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";
        exports.SOFTPLUS = T;
        const g = r + "\n  return sin(x);\n";
        exports.SIN = g;
        const C = r + "\n  return cos(x);\n";
        exports.COS = C;
        const h = "return tan(x);";
        exports.TAN = h;
        const F = r + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n";
        exports.ASIN = F;
        const U = r + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n";
        exports.ACOS = U;
        const P = r + "\n  return atan(x);\n";
        exports.ATAN = P;
        const m = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
        exports.SINH = m;
        const G = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
        exports.COSH = G;
        const H = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
        exports.TANH = H;
        const k = r + "return log(x + sqrt(x * x + 1.0));";
        exports.ASINH = k;
        const $ = r + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
        exports.ACOSH = $;
        const y = r + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
        exports.ATANH = y;
        const v = `\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${t.backend_util.ERF_P};\n  float a1 = ${t.backend_util.ERF_A1};\n  float a2 = ${t.backend_util.ERF_A2};\n  float a3 = ${t.backend_util.ERF_A3};\n  float a4 = ${t.backend_util.ERF_A4};\n  float a5 = ${t.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;
        exports.ERF = v;
        const M = "return x * x;";
        exports.SQUARE = M;
        const Q = "return 1.0 / x;";
        exports.RECIPROCAL = Q;
        const q = "return float(!(x >= 1.0));";
        exports.LOGICAL_NOT = q;
        const w = "return float(int(x));";
        exports.TO_INT = w;
        const D = "return x;";
        exports.CLONE = D;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "yBSN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.UnaryOpPackedProgram = exports.ELU = exports.RELU6 = exports.RELU = exports.LOG = exports.LINEAR = void 0;
        const e = "return x;";
        exports.LINEAR = e;
        const r = "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n";
        exports.LOG = r;
        const s = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
        exports.RELU = s;
        const t = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
        exports.RELU6 = t;
        const n = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
        exports.ELU = n;
        class a {
            constructor(e, r) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${r}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
            }
        }
        exports.UnaryOpPackedProgram = a;
    }, {}],
    "J76R": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.UnpackProgram = void 0;
        var e = require("./packing_util"),
            t = require("./shader_compiler");
        class r {
            constructor(r) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = r;
                const s = r.length,
                    n = (0, e.getChannels)("rc", s),
                    o = (0, t.getCoordsDataType)(s),
                    a = (0, e.getSourceCoords)(s, n),
                    c = n.slice(-2),
                    p = s <= 1 ? "rc" : `vec2(${c.join(",")})`;
                this.userCode = `\n      void main() {\n        ${o} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${p}));\n      }\n    `
            }
        }
        exports.UnpackProgram = r;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "YZpX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getBinaryCache = xe, exports.MathBackendWebGL = exports.MATMUL_SHARED_DIM_THRESHOLD = exports.EPSILON_FLOAT16 = exports.EPSILON_FLOAT32 = void 0, require("./flags_webgl");
        var e = Re(require("@tensorflow/tfjs-core")),
            t = require("./addn_gpu"),
            n = require("./addn_packed_gpu"),
            r = require("./argminmax_gpu"),
            a = require("./argminmax_packed_gpu"),
            s = require("./avg_pool_backprop_gpu"),
            i = require("./batchnorm_gpu"),
            o = require("./batchnorm_packed_gpu"),
            p = Re(require("./binaryop_complex_gpu")),
            u = Re(require("./binaryop_gpu")),
            h = Re(require("./binaryop_packed_gpu")),
            c = require("./canvas_util"),
            l = require("./clip_gpu"),
            d = require("./clip_packed_gpu"),
            m = require("./complex_abs_gpu"),
            g = require("./concat_gpu"),
            P = require("./concat_packed_gpu"),
            A = require("./conv_backprop_gpu"),
            _ = require("./conv_backprop_gpu_depthwise"),
            R = require("./conv_gpu"),
            O = require("./conv_gpu_depthwise"),
            y = require("./conv_packed_gpu_depthwise"),
            B = require("./crop_and_resize_gpu"),
            k = require("./cumsum_gpu"),
            E = require("./decode_matrix_gpu"),
            f = require("./decode_matrix_packed_gpu"),
            w = require("./depth_to_space_gpu"),
            I = require("./diag_gpu"),
            x = require("./encode_float_gpu"),
            D = require("./encode_float_packed_gpu"),
            C = require("./encode_matrix_gpu"),
            T = require("./encode_matrix_packed_gpu"),
            S = Re(require("./fft_gpu")),
            L = require("./fill_gpu"),
            v = require("./gather_gpu"),
            U = require("./gather_nd_gpu"),
            b = require("./gpgpu_context"),
            N = Re(require("./gpgpu_math")),
            M = require("./im2col_packed_gpu"),
            G = require("./lrn_gpu"),
            W = require("./lrn_grad_gpu"),
            F = require("./lrn_packed_gpu"),
            q = require("./max_pool_backprop_gpu"),
            z = require("./mulmat_packed_gpu"),
            K = require("./multinomial_gpu"),
            Y = require("./onehot_gpu"),
            H = require("./pack_gpu"),
            V = require("./pad_gpu"),
            Q = require("./pad_packed_gpu"),
            X = require("./pool_gpu"),
            j = require("./reduce_gpu"),
            $ = require("./reshape_packed_gpu"),
            Z = require("./resize_bilinear_backprop_gpu"),
            J = require("./resize_bilinear_gpu"),
            ee = require("./resize_bilinear_packed_gpu"),
            te = require("./resize_nearest_neighbor_backprop_gpu"),
            ne = require("./resize_nearest_neighbor_gpu"),
            re = require("./reverse_gpu"),
            ae = require("./reverse_packed_gpu"),
            se = require("./scatter_gpu"),
            ie = require("./segment_gpu"),
            oe = require("./select_gpu"),
            pe = require("./slice_gpu"),
            ue = require("./slice_packed_gpu"),
            he = require("./strided_slice_gpu"),
            ce = Re(require("./tex_util")),
            le = require("./texture_manager"),
            de = require("./tile_gpu"),
            me = Re(require("./unaryop_gpu")),
            ge = Re(require("./unaryop_packed_gpu")),
            Pe = require("./unpack_gpu"),
            Ae = Re(require("./webgl_util"));

        function _e() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return _e = function() {
                return e
            }, e
        }

        function Re(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = _e();
            if (t && t.has(e)) return t.get(e);
            var n = {},
                r = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var s = r ? Object.getOwnPropertyDescriptor(e, a) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = e[a]
                } return n.default = e, t && t.set(e, n), n
        }
        const {
            segment_util: Oe
        } = e.backend_util, ye = e.kernel_impls.split, Be = e.kernel_impls.tile, ke = e.kernel_impls.topkImpl, Ee = e.kernel_impls.whereImpl, fe = 1e-7;
        exports.EPSILON_FLOAT32 = fe;
        const we = 1e-4;
        exports.EPSILON_FLOAT16 = we;
        const Ie = {};

        function xe(e) {
            return e in Ie ? Ie[e] : (Ie[e] = {}, Ie[e])
        }

        function De(e, t = !1) {
            if ("linear" === e) return t ? ge.LINEAR : me.LINEAR;
            if ("relu" === e) return t ? ge.RELU : me.RELU;
            if ("elu" === e) return t ? ge.ELU : me.ELU;
            if ("relu6" === e) return t ? ge.RELU6 : me.RELU6;
            if ("prelu" === e) return t ? h.PRELU : u.PRELU;
            throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)
        }
        const Ce = 128,
            Te = 600;

        function Se() {
            return null == (0, e.env)().global.screen ? 1024 : (0, e.env)().global.screen.height * (0, e.env)().global.screen.width * window.devicePixelRatio * Te / 1024 / 1024
        }
        const Le = 1e3;
        exports.MATMUL_SHARED_DIM_THRESHOLD = Le;
        class ve extends e.KernelBackend {
            constructor(t) {
                if (super(), this.pendingRead = new WeakMap, this.pendingDisposal = new WeakSet, this.dataRefCount = new WeakMap, this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.warnedAboutMemory = !1, this.warnedAboutCPUBackend = !1, this.pendingDeletes = 0, this.disposed = !1, !(0, e.env)().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
                if (null == t) {
                    const t = (0, c.getWebGLContext)((0, e.env)().getNumber("WEBGL_VERSION"));
                    this.binaryCache = xe((0, e.env)().getNumber("WEBGL_VERSION")), this.gpgpu = new b.GPGPUContext(t), this.canvas = t.canvas, this.gpgpuCreatedLocally = !0
                } else this.gpgpu = t, this.binaryCache = {}, this.gpgpuCreatedLocally = !1, this.canvas = t.gl.canvas;
                this.textureManager = new le.TextureManager(this.gpgpu), this.numMBBeforeWarning = Se(), this.texData = new e.DataStorage(this, (0, e.engine)())
            }
            numDataIds() {
                return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
            }
            write(t, n, r) {
                if (((0, e.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || (0, e.env)().getBool("DEBUG")) && this.checkNumericalProblems(t), "complex64" === r && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                const a = {};
                return this.texData.set(a, {
                    shape: n,
                    dtype: r,
                    values: t,
                    usage: ce.TextureUsage.UPLOAD
                }), a
            }
            move(t, n, r, a) {
                if ((0, e.env)().getBool("DEBUG") && this.checkNumericalProblems(n), "complex64" === a) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                this.texData.set(t, {
                    shape: r,
                    dtype: a,
                    values: n,
                    usage: ce.TextureUsage.UPLOAD
                })
            }
            readSync(t) {
                const n = this.texData.get(t),
                    {
                        values: r,
                        dtype: a,
                        complexTensors: s,
                        slice: i,
                        shape: o,
                        isPacked: p
                    } = n;
                if (null != i) {
                    let e;
                    e = p ? new ge.UnaryOpPackedProgram(o, me.CLONE) : new me.UnaryOpProgram(o, me.CLONE);
                    const n = this.runWebGLProgram(e, [{
                            dataId: t,
                            shape: o,
                            dtype: a
                        }], a),
                        r = this.readSync(n.dataId);
                    return this.disposeData(n.dataId), r
                }
                if (null != r) return this.convertAndCacheOnCPU(t);
                if ("string" === a) return r;
                const u = null != this.activeTimers;
                let h, c;
                if (u && (h = e.util.now()), "complex64" === a) {
                    const t = s.real.dataSync(),
                        n = s.imag.dataSync();
                    c = e.backend_util.mergeRealAndImagArrays(t, n)
                } else c = this.getValuesFromTexture(t);
                return u && (this.downloadWaitMs += e.util.now() - h), this.convertAndCacheOnCPU(t, c)
            }
            async read(t) {
                if (this.pendingRead.has(t)) {
                    const e = this.pendingRead.get(t);
                    return new Promise(t => e.push(t))
                }
                const n = this.texData.get(t),
                    {
                        values: r,
                        shape: a,
                        slice: s,
                        dtype: i,
                        complexTensors: o,
                        isPacked: p
                    } = n;
                if (null != s) {
                    let e;
                    e = p ? new ge.UnaryOpPackedProgram(a, me.CLONE) : new me.UnaryOpProgram(a, me.CLONE);
                    const n = this.runWebGLProgram(e, [{
                            dataId: t,
                            shape: a,
                            dtype: i
                        }], i),
                        r = this.read(n.dataId);
                    return this.disposeData(n.dataId), r
                }
                if (null != r) return this.convertAndCacheOnCPU(t);
                if (!(0, e.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === (0, e.env)().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                let u, h, c = null;
                if ("complex64" !== i && (0, e.env)().get("WEBGL_BUFFER_SUPPORTED")) {
                    u = this.decode(t);
                    const e = this.texData.get(u.dataId);
                    c = this.gpgpu.createBufferFromTexture(e.texture, ...ce.getDenseTexShape(a))
                }
                if (this.pendingRead.set(t, []), "complex64" !== i && await this.gpgpu.createAndWaitForFence(), "complex64" === i) {
                    const t = await Promise.all([o.real.data(), o.imag.data()]),
                        n = t[0],
                        r = t[1];
                    h = e.backend_util.mergeRealAndImagArrays(n, r)
                } else if (null == c) h = this.getValuesFromTexture(t);
                else {
                    const t = e.util.sizeFromShape(a);
                    h = this.gpgpu.downloadFloat32MatrixFromBuffer(c, t)
                }
                null != u && this.disposeData(u.dataId);
                const l = this.convertAndCacheOnCPU(t, h),
                    d = this.pendingRead.get(t);
                return this.pendingRead.delete(t), d.forEach(e => e(l)), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), l
            }
            checkNumericalProblems(t) {
                if (null != t)
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        if (!Ae.canBeRepresented(r)) {
                            if ((0, e.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error(`The value ${r} cannot be represented with your ` + "current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
                            throw Error(`The value ${r} cannot be represented on this device.`)
                        }
                    }
            }
            getValuesFromTexture(t) {
                const {
                    shape: n,
                    dtype: r,
                    isPacked: a
                } = this.texData.get(t), s = e.util.sizeFromShape(n);
                if ((0, e.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
                    const e = this.decode(t),
                        r = this.texData.get(e.dataId),
                        a = this.gpgpu.downloadMatrixFromPackedTexture(r.texture, ...ce.getDenseTexShape(n)).subarray(0, s);
                    return this.disposeData(e.dataId), a
                }
                const i = (0, e.env)().getBool("WEBGL_PACK") && !0 === a,
                    o = i ? Ae.getShapeAs3D(n) : n,
                    p = i ? new D.EncodeFloatPackedProgram(o) : new x.EncodeFloatProgram(o),
                    u = this.runWebGLProgram(p, [{
                        shape: o,
                        dtype: r,
                        dataId: t
                    }], "float32"),
                    h = this.texData.get(u.dataId),
                    c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture, h.texShape[0], h.texShape[1]).subarray(0, s);
                return this.disposeData(u.dataId), c
            }
            async time(t) {
                const n = this.activeTimers,
                    r = [];
                let a = !1;
                null == this.programTimersStack ? (this.programTimersStack = r, a = !0) : this.activeTimers.push(r), this.activeTimers = r, t();
                const s = e.util.flatten(this.activeTimers.map(e => e.query)).filter(e => null != e),
                    i = e.util.flatten(this.activeTimers.map(e => e.name)).filter(e => null != e);
                this.activeTimers = n, a && (this.programTimersStack = null);
                const o = {
                    uploadWaitMs: this.uploadWaitMs,
                    downloadWaitMs: this.downloadWaitMs,
                    kernelMs: null,
                    wallMs: null
                };
                if ((0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
                    const t = await Promise.all(s);
                    o.kernelMs = e.util.sum(t), o.getExtraProfileInfo = (() => t.map((e, t) => ({
                        name: i[t],
                        ms: e
                    })).map(e => `${e.name}: ${e.ms}`).join(", "))
                } else o.kernelMs = {
                    error: "WebGL query timers are not supported in this environment."
                };
                return this.uploadWaitMs = 0, this.downloadWaitMs = 0, o
            }
            memory() {
                return {
                    unreliable: !1,
                    numBytesInGPU: this.numBytesInGPU,
                    numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
                    numBytesInGPUFree: this.textureManager.numBytesFree
                }
            }
            startTimer() {
                return (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
                    startMs: e.util.now(),
                    endMs: null
                }
            }
            endTimer(t) {
                return (0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = e.util.now(), t)
            }
            async getQueryTime(t) {
                if ((0, e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(t);
                const n = t;
                return n.endMs - n.startMs
            }
            disposeData(e) {
                if (this.pendingDisposal.has(e)) return;
                if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), void this.pendingDeletes++;
                if (!this.texData.has(e)) return;
                this.releaseGPUData(e);
                const {
                    complexTensors: t
                } = this.texData.get(e);
                null != t && (t.real.dispose(), t.imag.dispose()), this.texData.delete(e)
            }
            releaseGPUData(e) {
                const {
                    texture: t,
                    dtype: n,
                    texShape: r,
                    usage: a,
                    isPacked: s,
                    slice: i
                } = this.texData.get(e), o = i && i.origDataId || e, p = this.dataRefCount.get(o);
                p > 1 ? this.dataRefCount.set(o, p - 1) : (this.dataRefCount.delete(o), null != t && (this.numBytesInGPU -= this.computeBytes(r, n), this.textureManager.releaseTexture(t, r, a, s)));
                const u = this.texData.get(e);
                u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null
            }
            getTexture(e) {
                return this.uploadToGPU(e), this.texData.get(e).texture
            }
            getDataInfo(e) {
                return this.texData.get(e)
            }
            getCPUBackend() {
                return (0, e.env)().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = (0, e.engine)().findBackend("cpu")), this.cpuBackend) : null
            }
            shouldExecuteOnCPU(t, n = Ce) {
                const r = this.getCPUBackend();
                return this.warnedAboutCPUBackend || null != r || (0, e.env)().getBool("IS_TEST") || (console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."), this.warnedAboutCPUBackend = !0), null != r && t.every(t => null == this.texData.get(t.dataId).texture && e.util.sizeFromShape(t.shape) < n)
            }
            getGPGPUContext() {
                return this.gpgpu
            }
            complex(t, n) {
                const r = this.makeOutput(t.shape, "complex64");
                return this.texData.get(r.dataId).complexTensors = {
                    real: (0, e.engine)().keep(t.clone()),
                    imag: (0, e.engine)().keep(n.clone())
                }, r
            }
            real(e) {
                return this.texData.get(e.dataId).complexTensors.real.clone()
            }
            imag(e) {
                return this.texData.get(e.dataId).complexTensors.imag.clone()
            }
            slice(t, n, r) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, n, r);
                if (0 === e.util.sizeFromShape(r)) return (0, e.tensor)([], r, t.dtype);
                const {
                    isPacked: a
                } = this.texData.get(t.dataId), s = e.slice_util.isSliceContinous(t.shape, n, r);
                if (a || !s) {
                    const a = (0, e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ue.SlicePackedProgram(r) : new pe.SliceProgram(r),
                        s = a.getCustomSetupFunc(n);
                    return this.compileAndRun(a, [t], null, s)
                }
                return this.uploadToGPU(t.dataId), this.shallowSlice(t, n, r)
            }
            shallowSlice(t, n, r) {
                const a = this.texData.get(t.dataId),
                    s = this.makeOutput(r, t.dtype),
                    i = this.texData.get(s.dataId);
                Object.assign(i, a), i.shape = r, i.dtype = t.dtype;
                let o = e.slice_util.computeFlatOffset(n, t.strides);
                a.slice && (o += a.slice.flatOffset), i.slice = {
                    flatOffset: o,
                    origDataId: a.slice && a.slice.origDataId || t.dataId
                };
                const p = this.dataRefCount.get(i.slice.origDataId) || 1;
                return this.dataRefCount.set(i.slice.origDataId, p + 1), s
            }
            stridedSlice(t, n, r, a) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, n, r, a);
                const s = e.slice_util.computeOutShape(n, r, a);
                if (s.some(e => 0 === e)) return (0, e.tensor)([], s);
                const i = new he.StridedSliceProgram(n, a, s);
                return this.compileAndRun(i, [t])
            }
            reverse(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ae.ReversePackedProgram(t.shape, n) : new re.ReverseProgram(t.shape, n);
                return this.compileAndRun(r, [t])
            }
            concat(t, n) {
                if ("complex64" === t[0].dtype) {
                    const r = t.map(t => (0, e.real)(t)),
                        a = t.map(t => (0, e.imag)(t));
                    return (0, e.complex)(this.concat(r, n), this.concat(a, n))
                }
                if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, n);
                if (1 === t.length) return t[0];
                if (t.length > (0, e.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                    const e = Math.floor(t.length / 2),
                        r = this.concat(t.slice(0, e), n),
                        a = this.concat(t.slice(e), n);
                    return this.concat([r, a], n)
                }
                if ((0, e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
                    const e = new P.ConcatPackedProgram(t.map(e => e.shape), n);
                    return this.compileAndRun(e, t)
                }
                const r = e.backend_util.computeOutShape(t.map(e => e.shape), n),
                    a = t.map(t => t.as2D(-1, e.util.sizeFromShape(t.shape.slice(n)))),
                    s = new g.ConcatProgram(a.map(e => e.shape));
                return this.compileAndRun(s, a).reshape(r)
            }
            neg(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.NEG, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.NEG);
                return this.compileAndRun(n, [t])
            }
            batchMatMul(t, n, r, a) {
                const s = r ? t.shape[2] : t.shape[1],
                    i = a ? n.shape[1] : n.shape[2],
                    o = r ? t.shape[1] : t.shape[2],
                    [p, , ] = t.shape;
                if ((1 === s || 1 === i) && o > Le) {
                    r && (t = (0, e.transpose)(t, [0, 2, 1])), a && (n = (0, e.transpose)(n, [0, 2, 1]));
                    const s = 1 === i ? t : t.as3D(p, o, 1),
                        u = 1 === i ? 2 : 1,
                        h = 1 === i ? n.as3D(p, 1, o) : n;
                    return this.multiply(s, h).sum(u, !0)
                }
                const u = (0, e.upcastType)(t.dtype, n.dtype),
                    h = new z.MatMulPackedProgram(t.shape, [p, s, i], r, a);
                return this.compileAndRun(h, [t, n], u)
            }
            fusedBatchMatMul({
                a: t,
                b: n,
                transposeA: r,
                transposeB: a,
                bias: s,
                activation: i,
                preluActivationWeights: o
            }) {
                const p = r ? t.shape[2] : t.shape[1],
                    u = a ? n.shape[1] : n.shape[2],
                    [h, , ] = t.shape,
                    c = (0, e.upcastType)(t.dtype, n.dtype),
                    l = null != s,
                    d = null != o,
                    m = i ? De(i, !0) : null,
                    g = new z.MatMulPackedProgram(t.shape, [h, p, u], r, a, l, m, d),
                    P = [t, n];
                return s && P.push(s), o && P.push(o), this.compileAndRun(g, P, c)
            }
            multiply(t, n) {
                if ("complex64" === t.dtype) {
                    const e = this.texData.get(t.dataId),
                        r = this.texData.get(n.dataId),
                        a = new p.BinaryOpComplexProgram(p.COMPLEX_MULTIPLY.REAL, t.shape, n.shape),
                        s = new p.BinaryOpComplexProgram(p.COMPLEX_MULTIPLY.IMAG, t.shape, n.shape),
                        i = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag), this.makeComplexComponentTensorInfo(n, r.complexTensors.real), this.makeComplexComponentTensorInfo(n, r.complexTensors.imag)],
                        o = this.compileAndRun(a, i),
                        u = this.compileAndRun(s, i),
                        h = this.complex(o, u);
                    return o.dispose(), u.dispose(), h
                }
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.multiply(t, n);
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, u.MUL, t.dtype);
                const r = new u.BinaryOpProgram(u.MUL, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], t.dtype)
            }
            batchNorm(t, n, r, a, s, p) {
                const u = [t, n, r];
                let h = null;
                null != a && (h = a.shape, u.push(a));
                let c = null;
                if (null != s && (c = s.shape, u.push(s)), (0, e.env)().getBool("WEBGL_PACK_NORMALIZATION")) {
                    const e = new o.BatchNormPackedProgram(t.shape, n.shape, r.shape, h, c, p);
                    return this.compileAndRun(e, u)
                }
                const l = new i.BatchNormProgram(t.shape, n.shape, r.shape, h, c, p);
                return this.compileAndRun(l, u)
            }
            localResponseNormalization4D(t, n, r, a, s) {
                const i = (0, e.env)().getBool("WEBGL_PACK_NORMALIZATION") ? new F.LRNPackedProgram(t.shape, n, r, a, s) : new G.LRNProgram(t.shape, n, r, a, s);
                return this.compileAndRun(i, [t])
            }
            LRNGrad(e, t, n, r, a, s, i) {
                const o = new W.LRNGradProgram(t.shape, r, a, s, i);
                return this.compileAndRun(o, [t, n, e])
            }
            tile(t, n) {
                if ("string" === t.dtype) {
                    const r = this.readSync(t.dataId).map(t => e.util.decodeString(t)),
                        a = (0, e.buffer)(t.shape, t.dtype, r);
                    return Be(a, n)
                }
                const r = new de.TileProgram(t.shape, n);
                return this.compileAndRun(r, [t])
            }
            pad(t, n, r) {
                const a = (0, e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Q.PadPackedProgram(t.shape, n, r) : new V.PadProgram(t.shape, n, r);
                return this.compileAndRun(a, [t])
            }
            gather(e, t, n) {
                if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.gather(e, t, n);
                const r = new v.GatherProgram(e.shape, t.size, n);
                return this.compileAndRun(r, [e, t])
            }
            batchToSpaceND(t, n, r) {
                e.util.assert(t.rank <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
                const a = n.reduce((e, t) => e * t),
                    s = e.backend_util.getReshaped(t.shape, n, a),
                    i = e.backend_util.getPermuted(s.length, n.length),
                    o = e.backend_util.getReshapedPermuted(t.shape, n, a),
                    p = e.backend_util.getSliceBeginCoords(r, n.length),
                    u = e.backend_util.getSliceSize(o, r, n.length);
                return (0, e.transpose)(t.reshape(s), i).reshape(o).slice(p, u)
            }
            spaceToBatchND(t, n, r) {
                e.util.assert(t.rank <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
                const a = n.reduce((e, t) => e * t),
                    s = [
                        [0, 0]
                    ];
                s.push(...r);
                for (let e = 1 + n.length; e < t.shape.length; ++e) s.push([0, 0]);
                const i = t.pad(s),
                    o = e.backend_util.getReshaped(i.shape, n, a, !1),
                    p = e.backend_util.getPermuted(o.length, n.length, !1),
                    u = e.backend_util.getReshapedPermuted(i.shape, n, a, !1),
                    h = (0, e.transpose)(i.reshape(o), p);
                return (0, e.reshape)(h, u)
            }
            reduce(t, n, r) {
                const a = t.shape[0],
                    s = t.shape[1],
                    i = {
                        windowSize: e.backend_util.computeOptimalWindowSize(s),
                        inSize: s,
                        batchSize: a
                    },
                    o = new j.ReduceProgram(i, n),
                    p = this.compileAndRun(o, [t], r);
                return 1 === p.shape[1] ? p : this.reduce(p, n, r)
            }
            argReduce(t, n, a = null) {
                let s = t.shape[0],
                    i = t.shape[1];
                null != a && (s = a.shape[0], i = a.shape[1]);
                const o = {
                        windowSize: e.backend_util.computeOptimalWindowSize(i),
                        inSize: i,
                        batchSize: s
                    },
                    p = new r.ArgMinMaxProgram(o, n, null == a),
                    u = [t];
                null != a && u.push(a);
                const h = this.compileAndRun(p, u, "int32");
                return 1 === h.shape[1] ? h : this.argReduce(t, n, h)
            }
            argReducePacked(t, n, r = null) {
                const s = null != r ? r.shape : t.shape,
                    i = s[s.length - 1],
                    o = e.backend_util.computeOptimalWindowSize(i),
                    p = new a.ArgMinMaxPackedProgram(s, o, n, null == r),
                    u = null == r ? [t] : [t, r],
                    h = this.compileAndRun(p, u, "int32");
                return h.rank === t.rank ? this.argReducePacked(t, n, h) : h
            }
            sum(t, n) {
                e.backend_util.assertAxesAreInnerMostDims("sum", n, t.rank);
                const [r, a] = e.backend_util.computeOutAndReduceShapes(t.shape, n), s = e.util.sizeFromShape(a), i = t.as2D(-1, s), o = e.sumOutType(t.dtype);
                return this.reduce(i, "sum", o).reshape(r)
            }
            prod(t, n) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, n);
                const [r, a] = e.backend_util.computeOutAndReduceShapes(t.shape, n), s = e.util.sizeFromShape(a), i = t.as2D(-1, s), o = e.sumOutType(t.dtype);
                return this.reduce(i, "prod", o).reshape(r)
            }
            unsortedSegmentSum(t, n, r) {
                let a = 0;
                const s = e.backend_util.getAxesPermutation([a], t.rank);
                let i = t;
                null != s && (i = (0, e.transpose)(t, s), a = e.backend_util.getInnerMostAxes(1, t.rank)[0]);
                const o = Oe.computeOutShape(i.shape, a, r),
                    p = e.util.sizeFromShape([i.shape[a]]),
                    u = i.as2D(-1, p),
                    h = e.sumOutType(t.dtype);
                let c = this.segOpCompute(u, "unsortedSegmentSum", n, h, r).reshape(o);
                return null != s && (c = (0, e.transpose)(c, e.backend_util.getUndoAxesPermutation(s))), c
            }
            segOpCompute(t, n, r, a, s) {
                const i = t.shape[0],
                    o = t.shape[1],
                    p = Oe.segOpComputeOptimalWindowSize(o, s),
                    u = {
                        windowSize: p,
                        inSize: o,
                        batchSize: i,
                        numSegments: s
                    },
                    h = new ie.SegmentOpProgram(u, n),
                    c = this.compileAndRun(h, [t, r], a);
                return c.shape[1] === s ? c : (r = (0, e.range)(0, s).tile([o / p]), this.segOpCompute(c, n, r, a, s))
            }
            argMinMaxReduce(t, n, r) {
                const a = [n];
                if (e.backend_util.assertAxesAreInnerMostDims("arg" + r.charAt(0).toUpperCase() + r.slice(1), a, t.rank), !(0, e.env)().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
                    const [n, s] = e.backend_util.computeOutAndReduceShapes(t.shape, a), i = e.util.sizeFromShape(s), o = t.as2D(-1, i);
                    return this.argReduce(o, r).reshape(n)
                }
                return this.argReducePacked(t, r)
            }
            argMin(e, t) {
                return this.argMinMaxReduce(e, t, "min")
            }
            argMax(e, t) {
                return this.argMinMaxReduce(e, t, "max")
            }
            cumsum(e, t, n, r) {
                if (t !== e.rank - 1) throw new Error(`WebGL cumsum shader expects an inner-most axis=${e.rank-1} ` + `but got axis=${t}`);
                const a = e.shape[t];
                let s = e;
                for (let i = 0; i <= Math.ceil(Math.log2(a)) - 1; i++) {
                    const t = new k.CumSumProgram(e.shape, !1, r),
                        n = t.getCustomSetupFunc(i),
                        a = s;
                    s = this.compileAndRun(t, [s], s.dtype, n), a.dispose()
                }
                if (n) {
                    const t = new k.CumSumProgram(e.shape, n, r),
                        a = s;
                    s = this.compileAndRun(t, [s]), a.dispose()
                }
                return s
            }
            equal(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.EQUAL, "bool");
                const r = new u.BinaryOpProgram(u.EQUAL, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            notEqual(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.NOT_EQUAL, "bool");
                const r = new u.BinaryOpProgram(u.NOT_EQUAL, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            less(t, n) {
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.less(t, n);
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.LESS, "bool");
                const r = new u.BinaryOpProgram(u.LESS, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            lessEqual(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.LESS_EQUAL, "bool");
                const r = new u.BinaryOpProgram(u.LESS_EQUAL, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            greater(t, n) {
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.greater(t, n);
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.GREATER, "bool");
                const r = new u.BinaryOpProgram(u.GREATER, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            greaterEqual(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.GREATER_EQUAL, "bool");
                const r = new u.BinaryOpProgram(u.GREATER_EQUAL, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            logicalNot(e) {
                const t = new me.UnaryOpProgram(e.shape, me.LOGICAL_NOT);
                return this.compileAndRun(t, [e])
            }
            logicalAnd(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.LOGICAL_AND, "bool");
                const r = new u.BinaryOpProgram(u.LOGICAL_AND, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            logicalOr(t, n) {
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.LOGICAL_OR, "bool");
                const r = new u.BinaryOpProgram(u.LOGICAL_OR, t.shape, n.shape);
                return this.compileAndRun(r, [t, n], "bool")
            }
            select(t, n, r) {
                const a = new oe.SelectProgram(t.rank, n.shape, n.rank);
                return this.compileAndRun(a, [t, n, r], (0, e.upcastType)(n.dtype, r.dtype))
            }
            where(t) {
                e.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
                const n = t.dataSync();
                return Ee(t.shape, n)
            }
            topk(e, t, n) {
                const r = e.dataSync();
                return ke(r, e.shape, e.dtype, t, n)
            }
            min(t, n) {
                e.backend_util.assertAxesAreInnerMostDims("min", n, t.rank);
                const [r, a] = e.backend_util.computeOutAndReduceShapes(t.shape, n), s = e.util.sizeFromShape(a), i = t.as2D(-1, s);
                return this.reduce(i, "min", i.dtype).reshape(r)
            }
            minimum(t, n) {
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.minimum(t, n);
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.MIN, t.shape, n.shape) : new u.BinaryOpProgram(u.MIN, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            mod(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.MOD, t.shape, n.shape) : new u.BinaryOpProgram(u.MOD, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            maximum(t, n) {
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.maximum(t, n);
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.MAX, t.shape, n.shape) : new u.BinaryOpProgram(u.MAX, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            all(t, n) {
                e.backend_util.assertAxesAreInnerMostDims("all", n, t.rank);
                const [r, a] = e.backend_util.computeOutAndReduceShapes(t.shape, n), s = e.util.sizeFromShape(a), i = t.as2D(-1, s);
                return this.reduce(i, "all", i.dtype).reshape(r)
            }
            any(t, n) {
                e.backend_util.assertAxesAreInnerMostDims("any", n, t.rank);
                const [r, a] = e.backend_util.computeOutAndReduceShapes(t.shape, n), s = e.util.sizeFromShape(a), i = t.as2D(-1, s);
                return this.reduce(i, "any", i.dtype).reshape(r)
            }
            floorDiv(t, n) {
                const r = u.INT_DIV;
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, h.INT_DIV, "int32");
                const a = new u.BinaryOpProgram(r, t.shape, n.shape);
                return this.compileAndRun(a, [t, n], "int32")
            }
            add(t, n) {
                if ("complex64" === t.dtype && "complex64" === n.dtype) return this.complexSeparableBinaryOp(t, n, u.ADD);
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.add(t, n);
                const r = (0, e.upcastType)(t.dtype, n.dtype);
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, u.ADD, r);
                const a = new u.BinaryOpProgram(u.ADD, t.shape, n.shape);
                return this.compileAndRun(a, [t, n], r)
            }
            packedUnaryOp(e, t, n) {
                const r = new ge.UnaryOpPackedProgram(e.shape, t);
                return this.compileAndRun(r, [e], n)
            }
            packedBinaryOp(e, t, n, r, a = !1) {
                const s = new h.BinaryOpPackedProgram(n, e.shape, t.shape, a);
                return this.compileAndRun(s, [e, t], r)
            }
            complexSeparableBinaryOp(t, n, r) {
                const a = this.texData.get(t.dataId),
                    s = this.texData.get(n.dataId),
                    [i, o] = [
                        [a.complexTensors.real, s.complexTensors.real],
                        [a.complexTensors.imag, s.complexTensors.imag]
                    ].map(a => {
                        const [s, i] = a, o = this.makeComplexComponentTensorInfo(t, s), p = this.makeComplexComponentTensorInfo(n, i), h = new u.BinaryOpProgram(r, t.shape, n.shape);
                        return this.compileAndRun(h, [o, p], (0, e.upcastType)(s.dtype, i.dtype))
                    }),
                    p = this.complex(i, o);
                return i.dispose(), o.dispose(), p
            }
            makeComplexComponentTensorInfo(e, t) {
                return {
                    dataId: t.dataId,
                    dtype: t.dtype,
                    shape: e.shape
                }
            }
            addN(r) {
                if (1 === r.length) return r[0];
                if (r.length > (0, e.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                    const e = Math.floor(r.length / 2),
                        t = this.addN(r.slice(0, e)),
                        n = this.addN(r.slice(e));
                    return this.addN([t, n])
                }
                const a = r.map(e => e.dtype).reduce((t, n) => (0, e.upcastType)(t, n)),
                    s = r.map(e => e.shape),
                    i = (0, e.env)().getBool("WEBGL_PACK") ? new n.AddNPackedProgram(r[0].shape, s) : new t.AddNProgram(r[0].shape, s);
                return this.compileAndRun(i, r, a)
            }
            subtract(t, n) {
                if ("complex64" === t.dtype && "complex64" === n.dtype) return this.complexSeparableBinaryOp(t, n, u.SUB);
                if (this.shouldExecuteOnCPU([t, n])) return this.cpuBackend.subtract(t, n);
                const r = (0, e.upcastType)(t.dtype, n.dtype);
                if ((0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, n, u.SUB, t.dtype);
                const a = new u.BinaryOpProgram(u.SUB, t.shape, n.shape);
                return this.compileAndRun(a, [t, n], r)
            }
            pow(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.POW, t.shape, n.shape) : new u.BinaryOpProgram(u.POW, t.shape, n.shape),
                    a = (0, e.upcastType)(t.dtype, n.dtype);
                return this.compileAndRun(r, [t, n], a)
            }
            ceil(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.CEIL, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.CEIL);
                return this.compileAndRun(n, [t])
            }
            floor(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.FLOOR, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.FLOOR);
                return this.compileAndRun(n, [t])
            }
            sign(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SIGN);
                return this.compileAndRun(t, [e])
            }
            isNaN(e) {
                const t = new me.UnaryOpProgram(e.shape, me.IS_NAN);
                return this.compileAndRun(t, [e], "bool")
            }
            isInf(e) {
                const t = new me.UnaryOpProgram(e.shape, me.IS_INF);
                return this.compileAndRun(t, [e], "bool")
            }
            isFinite(e) {
                const t = new me.UnaryOpProgram(e.shape, me.IS_FINITE);
                return this.compileAndRun(t, [e], "bool")
            }
            round(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ROUND);
                return this.compileAndRun(t, [e])
            }
            exp(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.EXP, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.EXP);
                return this.compileAndRun(n, [t])
            }
            expm1(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.EXPM1, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.EXPM1);
                return this.compileAndRun(n, [t])
            }
            softmax(t, n) {
                const r = e.util.parseAxisParam([n], t.shape),
                    a = (0, e.max)(t, r),
                    s = e.backend_util.expandShapeToKeepDim(a.shape, r),
                    i = this.subtract(t, a.reshape(s)),
                    o = this.exp(i),
                    p = this.sum(o, r).reshape(s);
                return (0, e.div)(o, p)
            }
            log(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, ge.LOG, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.LOG);
                return this.compileAndRun(n, [t])
            }
            log1p(e) {
                const t = new me.UnaryOpProgram(e.shape, me.LOG1P);
                return this.compileAndRun(t, [e])
            }
            sqrt(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SQRT);
                return this.compileAndRun(t, [e])
            }
            rsqrt(e) {
                if (this.shouldExecuteOnCPU([e])) return this.cpuBackend.rsqrt(e);
                const t = new me.UnaryOpProgram(e.shape, me.RSQRT);
                return this.compileAndRun(t, [e])
            }
            reciprocal(e) {
                const t = new me.UnaryOpProgram(e.shape, me.RECIPROCAL);
                return this.compileAndRun(t, [e])
            }
            relu(t) {
                let n;
                return n = (0, e.env)().getBool("WEBGL_PACK") ? new ge.UnaryOpPackedProgram(t.shape, ge.RELU) : new me.UnaryOpProgram(t.shape, me.RELU), this.compileAndRun(n, [t])
            }
            relu6(t) {
                let n;
                return n = (0, e.env)().getBool("WEBGL_PACK") ? new ge.UnaryOpPackedProgram(t.shape, ge.RELU6) : new me.UnaryOpProgram(t.shape, me.RELU6), this.compileAndRun(n, [t])
            }
            prelu(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.PRELU, t.shape, n.shape) : new u.BinaryOpProgram(u.PRELU, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            elu(t) {
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, ge.ELU, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.ELU);
                return this.compileAndRun(n, [t])
            }
            eluDer(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.ELU_DER, t.shape, n.shape) : new u.BinaryOpProgram(u.ELU_DER, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            selu(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SELU);
                return this.compileAndRun(t, [e])
            }
            int(e) {
                const t = new me.UnaryOpProgram(e.shape, me.TO_INT);
                return this.compileAndRun(t, [e], "int32")
            }
            clip(t, n, r) {
                let a;
                const s = (a = (0, e.env)().getBool("WEBGL_PACK_CLIP") ? new d.ClipPackedProgram(t.shape) : new l.ClipProgram(t.shape)).getCustomSetupFunc(n, r);
                return this.compileAndRun(a, [t], null, s)
            }
            abs(t) {
                if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
                if ((0, e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, me.ABS, t.dtype);
                const n = new me.UnaryOpProgram(t.shape, me.ABS);
                return this.compileAndRun(n, [t])
            }
            complexAbs(e) {
                const t = this.texData.get(e.dataId),
                    n = new m.ComplexAbsProgram(e.shape),
                    r = [this.makeComplexComponentTensorInfo(e, t.complexTensors.real), this.makeComplexComponentTensorInfo(e, t.complexTensors.imag)];
                return this.compileAndRun(n, r)
            }
            sigmoid(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SIGMOID);
                return this.compileAndRun(t, [e])
            }
            softplus(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SOFTPLUS);
                return this.compileAndRun(t, [e])
            }
            sin(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SIN);
                return this.compileAndRun(t, [e])
            }
            cos(e) {
                const t = new me.UnaryOpProgram(e.shape, me.COS);
                return this.compileAndRun(t, [e])
            }
            tan(e) {
                const t = new me.UnaryOpProgram(e.shape, me.TAN);
                return this.compileAndRun(t, [e])
            }
            asin(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ASIN);
                return this.compileAndRun(t, [e])
            }
            acos(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ACOS);
                return this.compileAndRun(t, [e])
            }
            atan(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ATAN);
                return this.compileAndRun(t, [e])
            }
            atan2(t, n) {
                const r = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new h.BinaryOpPackedProgram(h.ATAN2, t.shape, n.shape) : new u.BinaryOpProgram(u.ATAN2, t.shape, n.shape);
                return this.compileAndRun(r, [t, n])
            }
            sinh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.SINH);
                return this.compileAndRun(t, [e])
            }
            cosh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.COSH);
                return this.compileAndRun(t, [e])
            }
            tanh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.TANH);
                return this.compileAndRun(t, [e])
            }
            asinh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ASINH);
                return this.compileAndRun(t, [e])
            }
            acosh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ACOSH);
                return this.compileAndRun(t, [e])
            }
            atanh(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ATANH);
                return this.compileAndRun(t, [e])
            }
            erf(e) {
                const t = new me.UnaryOpProgram(e.shape, me.ERF);
                return this.compileAndRun(t, [e])
            }
            step(e, t) {
                const n = new me.UnaryOpProgram(e.shape, me.STEP(t));
                return this.compileAndRun(n, [e])
            }
            conv2dByMatMul(t, n, r, a, s, i) {
                const o = t.shape,
                    p = this.texData.get(t.dataId),
                    u = r.inChannels,
                    h = o[0] * o[1] * o[2],
                    c = r.outChannels,
                    l = "channelsLast" === r.dataFormat,
                    d = (1 === h || 1 === c) && u > Le,
                    m = o[2] % 2 != 0 && !!p.isPacked;
                if (d || !(0, e.env)().getBool("WEBGL_LAZILY_UNPACK") || !(0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !m) {
                    const e = l ? o[0] * o[1] * o[2] : o[0] * o[2] * o[3],
                        p = this.reshape(t, [1, e, r.inChannels]),
                        u = this.reshape(n, [1, r.inChannels, r.outChannels]);
                    return this.reshape(this.fusedBatchMatMul({
                        a: p,
                        b: u,
                        transposeA: !1,
                        transposeB: !1,
                        bias: a,
                        activation: s,
                        preluActivationWeights: i
                    }), r.outShape)
                }
                const g = l ? o[0] * o[1] * (o[2] + 1) : o[0] * o[2] * (o[3] + 1),
                    P = {
                        dataId: t.dataId,
                        shape: [1, g, r.inChannels],
                        dtype: t.dtype
                    },
                    A = p.shape;
                p.shape = p.shape.slice(), p.shape[p.shape.length - 2]++, e.util.assert(Ae.isReshapeFree(p.shape, P.shape), () => `packed reshape ${p.shape} to ${P.shape} isn't free`);
                const _ = this.reshape(n, [1, r.inChannels, r.outChannels]),
                    R = this.fusedBatchMatMul({
                        a: P,
                        b: _,
                        transposeA: !1,
                        transposeB: !1,
                        bias: a,
                        activation: s,
                        preluActivationWeights: i
                    }),
                    O = this.texData.get(R.dataId);
                return e.util.assert(O.isPacked, () => "batchMatMul result is expected to be packed"), p.shape = A, O.shape = r.outShape, (0, e.engine)().makeTensorFromDataId(R.dataId, r.outShape, R.dtype)
            }
            conv2dWithIm2Row(e, t, n, r, a, s) {
                const {
                    filterWidth: i,
                    filterHeight: o,
                    inChannels: p,
                    outWidth: u,
                    outHeight: h,
                    dataFormat: c
                } = n, l = "channelsLast" === c, d = i * o * p, m = h * u, g = [d, m], P = e.squeeze([0]), A = t.reshape([1, d, -1]), _ = new M.Im2ColPackedProgram(g, P.shape, n), R = this.compileAndRun(_, [P]).reshape([1, g[0], g[1]]), O = null != r, y = null != s, B = a ? De(a, !0) : null, k = new z.MatMulPackedProgram(R.shape, [1, m, n.outChannels], !0, !1, O, B, y), E = [R, A];
                r && E.push(r), y && E.push(s);
                const f = this.compileAndRun(k, E);
                return l ? f.reshape([1, h, u, n.outChannels]) : f.reshape([1, n.outChannels, h, u])
            }
            fusedConv2d({
                input: t,
                filter: n,
                convInfo: r,
                bias: a,
                activation: s,
                preluActivationWeights: i
            }) {
                if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(t, n, r, a, s, i);
                if ((0, e.env)().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, n, r, a, s, i);
                const o = null != a,
                    p = null != i,
                    u = s ? De(s, !1) : null,
                    h = new R.Conv2DProgram(r, o, u, p),
                    c = [t, n];
                return a && c.push(a), i && c.push(i), this.compileAndRun(h, c)
            }
            conv2d(t, n, r) {
                if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(t, n, r);
                if ((0, e.env)().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, n, r);
                const a = new R.Conv2DProgram(r);
                return this.compileAndRun(a, [t, n])
            }
            conv2dDerInput(e, t, n) {
                const r = new A.Conv2DDerInputProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            conv2dDerFilter(e, t, n) {
                const r = new A.Conv2DDerFilterProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            fusedDepthwiseConv2D({
                input: t,
                filter: n,
                convInfo: r,
                bias: a,
                activation: s,
                preluActivationWeights: i
            }) {
                const o = (0, e.env)().getBool("WEBGL_PACK_DEPTHWISECONV") && r.strideWidth <= 2 && r.outChannels / r.inChannels == 1,
                    p = s ? De(s, o) : null,
                    u = [t, n],
                    h = null != a,
                    c = null != i;
                let l;
                return h && u.push(a), c && u.push(i), o ? (l = new y.DepthwiseConvPacked2DProgram(r, h, p, c), this.compileAndRun(l, u)) : (l = new O.DepthwiseConv2DProgram(r, h, p, c), this.compileAndRun(l, u))
            }
            depthwiseConv2D(t, n, r) {
                let a;
                return (0, e.env)().getBool("WEBGL_PACK_DEPTHWISECONV") && r.strideWidth <= 2 && r.outChannels / r.inChannels == 1 ? (a = new y.DepthwiseConvPacked2DProgram(r), this.compileAndRun(a, [t, n])) : (a = new O.DepthwiseConv2DProgram(r), this.compileAndRun(a, [t, n]))
            }
            depthwiseConv2DDerInput(e, t, n) {
                const r = new _.DepthwiseConv2DDerInputProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            depthwiseConv2DDerFilter(e, t, n) {
                const r = new _.DepthwiseConv2DDerFilterProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            conv3d(e, t, n) {
                const r = new R.Conv3DProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            conv3dDerInput(e, t, n) {
                const r = new A.Conv3DDerInputProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            conv3dDerFilter(e, t, n) {
                const r = new A.Conv3DDerFilterProgram(n);
                return this.compileAndRun(r, [e, t])
            }
            maxPool(e, t) {
                const n = new X.Pool2DProgram(t, "max", !1);
                return this.compileAndRun(n, [e])
            }
            avgPool(e, t) {
                const n = new X.Pool2DProgram(t, "avg", !1);
                return this.compileAndRun(n, [e], "float32")
            }
            maxPoolBackprop(e, t, n, r) {
                const a = new X.Pool2DProgram(r, "max", !0),
                    s = this.compileAndRun(a, [t]),
                    i = new q.MaxPool2DBackpropProgram(r),
                    o = this.compileAndRun(i, [e, s], t.dtype);
                return s.dispose(), o
            }
            avgPoolBackprop(e, t, n) {
                const r = new s.AvgPool2DBackpropProgram(n);
                return this.compileAndRun(r, [e], t.dtype)
            }
            cast(t, n) {
                return e.backend_util.castTensor(t, n, this)
            }
            unstack(e, t) {
                const n = e.shape[t],
                    r = new Array(e.rank - 1);
                let a = 0;
                for (let p = 0; p < e.rank; p++) p !== t && (r[a++] = e.shape[p]);
                const s = new Array(e.rank).fill(0),
                    i = e.shape.slice();
                i[t] = 1;
                const o = new Array(n);
                for (let p = 0; p < o.length; p++) s[t] = p, o[p] = this.slice(e, s, i).reshape(r);
                return o
            }
            avgPool3d(e, t) {
                const n = new X.Pool3DProgram(t, "avg", !1);
                return this.compileAndRun(n, [e], "float32")
            }
            avgPool3dBackprop(e, t, n) {
                const r = new s.AvgPool3DBackpropProgram(n);
                return this.compileAndRun(r, [e], t.dtype)
            }
            maxPool3d(e, t) {
                const n = new X.Pool3DProgram(t, "max", !1);
                return this.compileAndRun(n, [e], "float32")
            }
            maxPool3dBackprop(e, t, n, r) {
                const a = new X.Pool3DProgram(r, "max", !0),
                    s = this.compileAndRun(a, [t]),
                    i = new q.MaxPool3DBackpropProgram(r),
                    o = this.compileAndRun(i, [e, s], t.dtype);
                return s.dispose(), o
            }
            reshape(t, n) {
                const r = this.texData.get(t.dataId);
                if (r.isPacked && !Ae.isReshapeFree(t.shape, n) && (null === r.texture || !Ae.isReshapeFree(r.shape, n))) {
                    const r = this.packedReshape(t, n);
                    return (0, e.engine)().makeTensorFromDataId(r.dataId, r.shape, r.dtype)
                }
                return e.backend_util.reshapeTensor(t, n)
            }
            resizeBilinear(t, n, r, a) {
                const s = (0, e.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ee.ResizeBilinearPackedProgram(t.shape, n, r, a) : new J.ResizeBilinearProgram(t.shape, n, r, a);
                return this.compileAndRun(s, [t], "float32")
            }
            resizeBilinearBackprop(e, t, n) {
                const r = new Z.ResizeBilinearBackpropProgram(e, t, n);
                return this.compileAndRun(r, [e])
            }
            resizeNearestNeighbor(e, t, n, r) {
                const a = new ne.ResizeNearestNeighborProgram(e.shape, t, n, r);
                return this.compileAndRun(a, [e])
            }
            resizeNearestNeighborBackprop(e, t, n) {
                const r = new te.ResizeNearestNeigborBackpropProgram(e, t, n);
                return this.compileAndRun(r, [e])
            }
            multinomial(t, n, r, a) {
                const s = n ? t : (0, e.softmax)(t),
                    i = s.shape[0],
                    o = s.shape[1],
                    p = new K.MultinomialProgram(i, o, r),
                    u = p.getCustomSetupFunc(a);
                return this.compileAndRun(p, [s], "int32", u)
            }
            oneHot(e, t, n, r) {
                const a = new Y.OneHotProgram(e.size, t, n, r);
                return this.compileAndRun(a, [e])
            }
            diag(e) {
                const t = new I.DiagProgram(e.size);
                return this.compileAndRun(t, [e])
            }
            cropAndResize(e, t, n, r, a, s) {
                const i = new B.CropAndResizeProgram(e.shape, t.shape, r, a, s);
                return this.compileAndRun(i, [e, t, n], "float32")
            }
            depthToSpace(t, n, r) {
                e.util.assert(n > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${n}`);
                const a = t.shape[0],
                    s = "NHWC" === r ? t.shape[1] : t.shape[2],
                    i = "NHWC" === r ? t.shape[2] : t.shape[3],
                    o = "NHWC" === r ? t.shape[3] : t.shape[1],
                    p = s * n,
                    u = i * n,
                    h = o / (n * n),
                    c = "NHWC" === r ? [a, p, u, h] : [a, h, p, u],
                    l = new w.DepthToSpaceProgram(c, n, r);
                return this.compileAndRun(l, [t])
            }
            split(e, t, n) {
                return ye(e, t, n)
            }
            scatterND(t, n, r) {
                const {
                    sliceRank: a,
                    numUpdates: s,
                    sliceSize: i,
                    strides: o,
                    outputSize: p
                } = e.backend_util.calculateShapes(n, t, r), u = [p / i, i], h = t.reshape([s, a]), c = n.reshape([s, i]);
                if (0 === p) return e.backend_util.reshapeTensor((0, e.tensor)([]), r);
                const l = (0, e.scalar)(0),
                    d = new se.ScatterProgram(s, a, h.rank, c.rank, o, u);
                return this.compileAndRun(d, [c, h, l]).reshape(r)
            }
            sparseToDense(t, n, r, a) {
                const {
                    sliceRank: s,
                    numUpdates: i,
                    strides: o,
                    outputSize: p
                } = e.backend_util.calculateShapes(n, t, r), u = new se.ScatterProgram(i, s, t.rank, n.rank, o, [p, 1], !1);
                return this.compileAndRun(u, [n, t, a]).reshape(r)
            }
            fft(e) {
                return this.fftImpl(e, !1)
            }
            ifft(e) {
                return this.fftImpl(e, !0)
            }
            fftImpl(e, t) {
                const n = this.texData.get(e.dataId),
                    r = new S.FFTProgram(S.COMPLEX_FFT.REAL, e.shape, t),
                    a = new S.FFTProgram(S.COMPLEX_FFT.IMAG, e.shape, t),
                    s = [this.makeComplexComponentTensorInfo(e, n.complexTensors.real), this.makeComplexComponentTensorInfo(e, n.complexTensors.imag)],
                    i = this.compileAndRun(r, s),
                    o = this.compileAndRun(a, s),
                    p = this.complex(i, o).as2D(e.shape[0], e.shape[1]);
                return i.dispose(), o.dispose(), p
            }
            gatherND(t, n) {
                const r = n.shape,
                    a = r[r.length - 1],
                    [s, i, o, p] = e.backend_util.prepareAndValidate(t, n),
                    u = n.reshape([i, a]),
                    h = t.reshape([t.size / o, o]),
                    c = new U.GatherNDProgram(a, p, [i, o]);
                return this.compileAndRun(c, [h, u]).reshape(s)
            }
            fill(t, n, r) {
                if ("string" === (r = r || e.util.inferDtype(n))) {
                    const a = e.util.getArrayFromDType(r, e.util.sizeFromShape(t));
                    return a.fill(n), (0, e.engine)().makeTensor(a, t, r, this)
                } {
                    const e = new L.FillProgram(t, n),
                        a = e.getCustomSetupFunc(n);
                    return this.compileAndRun(e, [], r, a)
                }
            }
            onesLike(e) {
                if ("string" === e.dtype) throw new Error("onesLike is not supported under string dtype");
                return this.fill(e.shape, 1, e.dtype)
            }
            zerosLike(e) {
                return this.fill(e.shape, "string" === e.dtype ? "" : 0, e.dtype)
            }
            linspace(t, n, r) {
                return e.backend_util.linspaceImpl(t, n, r)
            }
            makeTensorInfo(e, t) {
                const n = this.write(null, e, t);
                return this.texData.get(n).usage = null, {
                    dataId: n,
                    shape: e,
                    dtype: t
                }
            }
            makeOutput(t, n) {
                const {
                    dataId: r
                } = this.makeTensorInfo(t, n);
                return (0, e.engine)().makeTensorFromDataId(r, t, n, this)
            }
            unpackTensor(e) {
                const t = new Pe.UnpackProgram(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype)
            }
            packTensor(e) {
                const t = new H.PackProgram(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype, null, !0)
            }
            packedReshape(e, t) {
                const n = [Ae.getBatchDim(e.shape), ...Ae.getRowsCols(e.shape)],
                    r = {
                        dtype: e.dtype,
                        shape: n,
                        dataId: e.dataId
                    },
                    a = [Ae.getBatchDim(t), ...Ae.getRowsCols(t)],
                    s = new $.ReshapePackedProgram(a, n),
                    i = this.runWebGLProgram(s, [r], e.dtype, null, !0);
                return {
                    dataId: i.dataId,
                    shape: t,
                    dtype: i.dtype
                }
            }
            decode(e) {
                const t = this.texData.get(e),
                    {
                        isPacked: n,
                        shape: r,
                        dtype: a
                    } = t,
                    s = Ae.getShapeAs3D(r);
                let i;
                i = n ? new f.DecodeMatrixPackedProgram(s) : new E.DecodeMatrixProgram(s);
                return {
                    dtype: a,
                    shape: r,
                    dataId: this.runWebGLProgram(i, [{
                        shape: s,
                        dtype: a,
                        dataId: e
                    }], a, null, !0).dataId
                }
            }
            runWebGLProgram(t, n, r, a, s = !1) {
                const i = this.makeTensorInfo(t.outputShape, r),
                    o = this.texData.get(i.dataId);
                if (t.packedOutput && (o.isPacked = !0), t.outPackingScheme === ce.PackingScheme.DENSE) {
                    const e = ce.getDenseTexShape(t.outputShape);
                    o.texShape = e.map(e => 2 * e)
                }
                if (null != t.outTexUsage && (o.usage = t.outTexUsage), 0 === e.util.sizeFromShape(i.shape)) return o.values = e.util.getTypedArrayFromDType(i.dtype, 0), i;
                const p = [],
                    u = n.map(n => {
                        if ("complex64" === n.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
                        let r = this.texData.get(n.dataId);
                        if (null == r.texture) {
                            if (!t.packedInputs && e.util.sizeFromShape(n.shape) <= (0, e.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                                shape: n.shape,
                                texData: null,
                                isUniform: !0,
                                uniformValues: r.values
                            };
                            t.packedInputs && (r.isPacked = !0, r.shape = n.shape)
                        } else if (!!r.isPacked != !!t.packedInputs) n = r.isPacked ? this.unpackTensor(n) : this.packTensor(n), p.push(n), r = this.texData.get(n.dataId);
                        else if (r.isPacked && !Ae.isReshapeFree(r.shape, n.shape)) {
                            const e = n,
                                t = n.shape;
                            n.shape = r.shape, n = this.packedReshape(n, t), p.push(n), r = this.texData.get(n.dataId), e.shape = t
                        }
                        return this.uploadToGPU(n.dataId), {
                            shape: n.shape,
                            texData: r,
                            isUniform: !1
                        }
                    });
                this.uploadToGPU(i.dataId);
                const h = {
                        shape: i.shape,
                        texData: o,
                        isUniform: !1
                    },
                    c = N.makeShaderKey(t, u, h),
                    l = this.getAndSaveBinary(c, () => N.compileProgram(this.gpgpu, t, u, h)),
                    d = null != this.activeTimers;
                let m;
                if (d && (m = this.startTimer()), N.runProgram(this.gpgpu, l, u, h, a), p.forEach(e => this.disposeData(e.dataId)), d && (m = this.endTimer(m), this.activeTimers.push({
                        name: t.constructor.name,
                        query: this.getQueryTime(m)
                    })), !(0, e.env)().getBool("WEBGL_LAZILY_UNPACK") && o.isPacked && !1 === s) {
                    const e = this.unpackTensor(i);
                    return this.disposeData(i.dataId), e
                }
                return i
            }
            compileAndRun(t, n, r, a, s = !1) {
                r = r || n[0].dtype;
                const i = this.runWebGLProgram(t, n, r, a, s);
                return (0, e.engine)().makeTensorFromDataId(i.dataId, i.shape, i.dtype)
            }
            getAndSaveBinary(e, t) {
                return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e]
            }
            getTextureManager() {
                return this.textureManager
            }
            dispose() {
                if (!this.disposed) {
                    if (!(0, e.env)().getBool("IS_TEST")) {
                        Object.keys(this.binaryCache).forEach(e => {
                            this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e]
                        })
                    }
                    this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0
                }
            }
            floatPrecision() {
                return null == this.floatPrecisionValue && (this.floatPrecisionValue = (0, e.tidy)(() => {
                    if (!(0, e.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                        const t = (0, e.env)().getBool("DEBUG");
                        (0, e.env)().set("DEBUG", !1);
                        const n = this.abs((0, e.scalar)(1e-8)).dataSync()[0];
                        if ((0, e.env)().set("DEBUG", t), n > 0) return 32
                    }
                    return 16
                })), this.floatPrecisionValue
            }
            epsilon() {
                return 32 === this.floatPrecision() ? fe : we
            }
            uploadToGPU(t) {
                const n = this.texData.get(t),
                    {
                        shape: r,
                        dtype: a,
                        values: s,
                        texture: i,
                        usage: o,
                        isPacked: p
                    } = n;
                if (null != i) return;
                const u = null != this.activeTimers;
                let h;
                u && (h = e.util.now());
                let c = n.texShape;
                if (null == c && (c = Ae.getTextureShapeFromLogicalShape(r, p), n.texShape = c), null != s) {
                    const t = Ae.getShapeAs3D(r);
                    let i, o = c[1],
                        l = c[0];
                    const d = s instanceof Uint8Array;
                    p ? ([o, l] = ce.getPackedMatrixTextureShapeWidthHeight(c[0], c[1]), i = new T.EncodeMatrixPackedProgram(t, [l, o], d)) : i = new C.EncodeMatrixProgram(t, [l, o], d);
                    const m = this.makeTensorInfo([l, o], a);
                    this.texData.get(m.dataId).usage = d ? ce.TextureUsage.PIXELS : ce.TextureUsage.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId), o, l, s);
                    const g = !0,
                        P = this.runWebGLProgram(i, [m], a, null, g),
                        A = this.texData.get(P.dataId);
                    n.texture = A.texture, n.texShape = A.texShape, n.isPacked = A.isPacked, n.usage = A.usage, this.disposeData(m.dataId), this.texData.delete(P.dataId), n.values = null, u && (this.uploadWaitMs += e.util.now() - h)
                } else {
                    const e = this.acquireTexture(c, o, a, p);
                    n.texture = e
                }
            }
            convertAndCacheOnCPU(e, t) {
                const n = this.texData.get(e),
                    {
                        dtype: r
                    } = n;
                return this.releaseGPUData(e), null != t && (n.values = Ue(t, r)), n.values
            }
            acquireTexture(e, t, n, r) {
                if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
                    const e = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
                    this.warnedAboutMemory = !0, console.warn(`High memory usage in GPU: ${e} MB, ` + "most likely due to a memory leak")
                }
                return this.textureManager.acquireTexture(e, t, r)
            }
            computeBytes(t, n) {
                return t[0] * t[1] * e.util.bytesPerElement(n)
            }
        }

        function Ue(e, t) {
            if ("float32" === t || "complex64" === t) return e;
            if ("int32" === t || "bool" === t) {
                const n = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length);
                for (let t = 0; t < n.length; ++t) n[t] = Math.round(e[t]);
                return n
            }
            throw new Error(`Unknown dtype ${t}`)
        }
        exports.MathBackendWebGL = ve;
    }, {
        "./flags_webgl": "YNu6",
        "@tensorflow/tfjs-core": "tc6m",
        "./addn_gpu": "DioZ",
        "./addn_packed_gpu": "BmoR",
        "./argminmax_gpu": "Pm0r",
        "./argminmax_packed_gpu": "TNMy",
        "./avg_pool_backprop_gpu": "vgTo",
        "./batchnorm_gpu": "IgN9",
        "./batchnorm_packed_gpu": "DUWz",
        "./binaryop_complex_gpu": "eCLc",
        "./binaryop_gpu": "r3Zb",
        "./binaryop_packed_gpu": "MEci",
        "./canvas_util": "S11S",
        "./clip_gpu": "rjZd",
        "./clip_packed_gpu": "QdXF",
        "./complex_abs_gpu": "w3Ul",
        "./concat_gpu": "loEe",
        "./concat_packed_gpu": "nB6G",
        "./conv_backprop_gpu": "y8Ea",
        "./conv_backprop_gpu_depthwise": "QU4a",
        "./conv_gpu": "LHRJ",
        "./conv_gpu_depthwise": "tZKH",
        "./conv_packed_gpu_depthwise": "najp",
        "./crop_and_resize_gpu": "nc6W",
        "./cumsum_gpu": "h31s",
        "./decode_matrix_gpu": "tZX6",
        "./decode_matrix_packed_gpu": "kOP2",
        "./depth_to_space_gpu": "KXiR",
        "./diag_gpu": "V8Cn",
        "./encode_float_gpu": "KyTh",
        "./encode_float_packed_gpu": "zODu",
        "./encode_matrix_gpu": "JBcV",
        "./encode_matrix_packed_gpu": "dH5p",
        "./fft_gpu": "LwKt",
        "./fill_gpu": "A8rF",
        "./gather_gpu": "sYl6",
        "./gather_nd_gpu": "gSio",
        "./gpgpu_context": "AZP2",
        "./gpgpu_math": "hS5V",
        "./im2col_packed_gpu": "j6dQ",
        "./lrn_gpu": "DLwU",
        "./lrn_grad_gpu": "xmP3",
        "./lrn_packed_gpu": "sdWO",
        "./max_pool_backprop_gpu": "trD0",
        "./mulmat_packed_gpu": "UauI",
        "./multinomial_gpu": "j5oG",
        "./onehot_gpu": "Nv1m",
        "./pack_gpu": "kEpT",
        "./pad_gpu": "psrI",
        "./pad_packed_gpu": "oRHP",
        "./pool_gpu": "DAMt",
        "./reduce_gpu": "cqVi",
        "./reshape_packed_gpu": "K4kf",
        "./resize_bilinear_backprop_gpu": "bHYm",
        "./resize_bilinear_gpu": "BAHS",
        "./resize_bilinear_packed_gpu": "QNLw",
        "./resize_nearest_neighbor_backprop_gpu": "hkPU",
        "./resize_nearest_neighbor_gpu": "T9BX",
        "./reverse_gpu": "dGqg",
        "./reverse_packed_gpu": "b6t2",
        "./scatter_gpu": "ugST",
        "./segment_gpu": "x8Mt",
        "./select_gpu": "CDzy",
        "./slice_gpu": "SBwi",
        "./slice_packed_gpu": "BaFQ",
        "./strided_slice_gpu": "N1kZ",
        "./tex_util": "hBHG",
        "./texture_manager": "herW",
        "./tile_gpu": "lZtF",
        "./unaryop_gpu": "uzBV",
        "./unaryop_packed_gpu": "yBSN",
        "./unpack_gpu": "J76R",
        "./webgl_util": "p3g2"
    }],
    "KPep": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.divImpl = a;
        var e = require("@tensorflow/tfjs-core"),
            r = o(require("../binaryop_gpu")),
            t = o(require("../binaryop_packed_gpu"));

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = n();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
                if (Object.prototype.hasOwnProperty.call(e, a)) {
                    var p = o ? Object.getOwnPropertyDescriptor(e, a) : null;
                    p && (p.get || p.set) ? Object.defineProperty(t, a, p) : t[a] = e[a]
                } return t.default = e, r && r.set(e, t), t
        }

        function a(n, o, a) {
            let p = new r.BinaryOpProgram(r.DIV, n.shape, o.shape);
            return (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") && (p = new t.BinaryOpPackedProgram(t.DIV, n.shape, o.shape, !0)), a.runWebGLProgram(p, [n, o], "float32")
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../binaryop_gpu": "r3Zb",
        "../binaryop_packed_gpu": "MEci"
    }],
    "aEZd": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.divConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            r = require("./Div_impl");
        const i = {
            kernelName: e.Div,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                backend: i
            }) => {
                const {
                    a: n,
                    b: o
                } = e, t = i;
                return (0, r.divImpl)(n, o, t)
            }
        };
        exports.divConfig = i;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./Div_impl": "KPep"
    }],
    "LnXj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FromPixelsProgram = void 0;
        var e = require("../../glsl_version");
        class t {
            constructor(t) {
                this.variableNames = ["A"];
                const s = (0, e.getGlslDifferences)(),
                    [n, o] = t;
                this.outputShape = t, this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);\n\n        vec4 values = ${s.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `
            }
        }
        exports.FromPixelsProgram = t;
    }, {
        "../../glsl_version": "QbWp"
    }],
    "ljIp": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FromPixelsPackedProgram = void 0;
        var e = require("../../glsl_version");
        class t {
            constructor(t) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
                const o = (0, e.getGlslDifferences)(),
                    [n, s] = t;
                this.outputShape = t, this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${o.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${o.output} = result;\n      }\n    `
            }
        }
        exports.FromPixelsPackedProgram = t;
    }, {
        "../../glsl_version": "QbWp"
    }],
    "MRz7": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.fromPixelsConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("../tex_util"),
            n = require("./FromPixels_utils/from_pixels_gpu"),
            o = require("./FromPixels_utils/from_pixels_packed_gpu");
        const a = {
            kernelName: e.FromPixels,
            backendName: "webgl",
            kernelFunc: i
        };
        let r;

        function i(a) {
            const {
                inputs: i,
                backend: s,
                attrs: l
            } = a;
            let {
                pixels: d
            } = i;
            const {
                numChannels: u
            } = l, m = "undefined" != typeof HTMLVideoElement && d instanceof HTMLVideoElement, c = "undefined" != typeof HTMLImageElement && d instanceof HTMLImageElement, [g, x] = m ? [d.videoWidth, d.videoHeight] : [d.width, d.height], f = [x, g], p = [x, g, u];
            (c || m) && (null == r && (r = document.createElement("canvas").getContext("2d")), r.canvas.width = g, r.canvas.height = x, r.drawImage(d, 0, 0, g, x), d = r.canvas);
            const P = s.makeTensorInfo(f, "int32");
            s.texData.get(P.dataId).usage = t.TextureUsage.PIXELS, s.gpgpu.uploadPixelDataToTexture(s.getTexture(P.dataId), d);
            const _ = (0, e.env)().getBool("WEBGL_PACK") ? new o.FromPixelsPackedProgram(p) : new n.FromPixelsProgram(p),
                v = s.runWebGLProgram(_, [P], "int32");
            return s.disposeData(P.dataId), v
        }
        exports.fromPixelsConfig = a;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../tex_util": "hBHG",
        "./FromPixels_utils/from_pixels_gpu": "LnXj",
        "./FromPixels_utils/from_pixels_packed_gpu": "ljIp"
    }],
    "tYJo": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxImpl = t;
        var e = require("@tensorflow/tfjs-core");

        function t(t, r, o, s) {
            const l = e.util.getTypedArrayFromDType(s, e.util.sizeFromShape(o));
            for (let e = 0; e < l.length; ++e) {
                const o = e * r;
                let s = t[o];
                for (let e = 0; e < r; ++e) {
                    const r = t[o + e];
                    r > s && (s = r)
                }
                l[e] = s
            }
            return l
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "HbWh": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transposeImpl = t;
        var e = require("@tensorflow/tfjs-core");

        function t(t, r, o, l, i) {
            const s = r.length,
                u = e.util.sizeFromShape(r),
                n = e.util.computeStrides(r),
                p = e.util.computeStrides(i),
                c = e.util.getTypedArrayFromDType(o, e.util.sizeFromShape(i));
            for (let a = 0; a < u; ++a) {
                const r = e.util.indexToLoc(a, s, n),
                    o = new Array(r.length);
                for (let e = 0; e < o.length; e++) o[e] = r[l[e]];
                c[e.util.locToIndex(o, s, p)] = t[a]
            }
            return c
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "X8ov": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "maxImpl", {
            enumerable: !0,
            get: function() {
                return e.maxImpl
            }
        }), Object.defineProperty(exports, "transposeImpl", {
            enumerable: !0,
            get: function() {
                return r.transposeImpl
            }
        });
        var e = require("./kernels/Max_impl"),
            r = require("./kernels/Transpose_impl");
    }, {
        "./kernels/Max_impl": "tYJo",
        "./kernels/Transpose_impl": "HbWh"
    }],
    "y22L": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.assertNotComplex = r;
        var e = require("@tensorflow/tfjs-core");

        function r(r, t) {
            Array.isArray(r) || (r = [r]), r.forEach(r => {
                null != r && e.util.assert("complex64" !== r.dtype, () => `${t} does not support complex64 tensors in the CPU backend.`)
            })
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "ZDaf": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.pool = e, exports.maxPoolPositions = i;
        var t = require("@tensorflow/tfjs-core");

        function e(e, i, o, n, r, h) {
            const a = r.strideHeight,
                f = r.strideWidth,
                l = r.dilationHeight,
                s = r.dilationWidth,
                u = r.effectiveFilterHeight,
                d = r.effectiveFilterWidth,
                c = r.padInfo.top,
                p = r.padInfo.left,
                I = "max" === h ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                g = (0, t.buffer)(r.outShape, o),
                N = g.values,
                m = r.outShape[1] * r.outShape[2] * r.outShape[3],
                W = r.outShape[2] * r.outShape[3],
                H = r.outShape[3];
            for (let t = 0; t < r.batchSize; ++t) {
                const i = t * m,
                    o = t * n[0];
                for (let t = 0; t < r.inChannels; ++t)
                    for (let g = 0; g < r.outHeight; ++g) {
                        const m = g * a - c,
                            S = Math.max(0, m),
                            b = Math.min(r.inHeight, u + m),
                            v = i + g * W;
                        for (let i = 0; i < r.outWidth; ++i) {
                            const a = i * f - p,
                                u = Math.max(0, a),
                                c = Math.min(r.inWidth, d + a);
                            let g = I,
                                m = 0,
                                W = 0;
                            for (let i = S; i < b; i += l) {
                                const r = o + i * n[1];
                                for (let i = u; i < c; i += s) {
                                    const o = e[r + i * n[2] + t];
                                    "max" === h && o > g ? g = o : "avg" === h && (m += o, W++)
                                }
                                if (isNaN(g)) break
                            }
                            N[v + i * H + t] = "avg" === h ? m / W : g
                        }
                    }
            }
            return g
        }

        function i(e, i, o, n, r = !1, h = !1) {
            const a = (0, t.buffer)(n.outShape, "int32"),
                f = n.strideHeight,
                l = n.strideWidth,
                s = n.dilationHeight,
                u = n.dilationWidth,
                d = n.effectiveFilterHeight,
                c = n.effectiveFilterWidth,
                p = n.padInfo.top,
                I = n.padInfo.left,
                g = (0, t.buffer)(i, o, e);
            for (let t = 0; t < n.batchSize; ++t)
                for (let e = 0; e < n.inChannels; ++e)
                    for (let i = 0; i < n.outHeight; ++i) {
                        const o = i * f - p;
                        let N = o;
                        for (; N < 0;) N += s;
                        const m = Math.min(n.inHeight, d + o);
                        for (let f = 0; f < n.outWidth; ++f) {
                            const d = f * l - I;
                            let p = d;
                            for (; p < 0;) p += u;
                            const W = Math.min(n.inWidth, c + d);
                            let H = Number.NEGATIVE_INFINITY,
                                S = -1;
                            for (let i = N; i < m; i += s) {
                                const a = i - o;
                                for (let o = p; o < W; o += u) {
                                    const f = o - d,
                                        l = g.get(t, i, o, e);
                                    l > H && (H = l, S = r ? h ? ((t * n.inHeight + i) * n.inWidth + o) * n.inChannels + e : (i * n.inWidth + o) * n.inChannels + e : a * c + f)
                                }
                            }
                            a.set(S, t, i, f, e)
                        }
                    }
            return a
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "cLLj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.MathBackendCPU = void 0;
        var t = o(require("@tensorflow/tfjs-core")),
            e = o(require("seedrandom")),
            a = require("./cpu_util"),
            s = require("./utils/pool_utils");

        function r() {
            if ("function" != typeof WeakMap) return null;
            var t = new WeakMap;
            return r = function() {
                return t
            }, t
        }

        function o(t) {
            if (t && t.__esModule) return t;
            if (null === t || "object" != typeof t && "function" != typeof t) return {
                default: t
            };
            var e = r();
            if (e && e.has(t)) return e.get(t);
            var a = {},
                s = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in t)
                if (Object.prototype.hasOwnProperty.call(t, o)) {
                    var n = s ? Object.getOwnPropertyDescriptor(t, o) : null;
                    n && (n.get || n.set) ? Object.defineProperty(a, o, n) : a[o] = t[o]
                } return a.default = t, e && e.set(t, a), a
        }
        const n = t.kernel_impls.nonMaxSuppressionV3Impl,
            i = t.kernel_impls.split,
            l = t.kernel_impls.tile,
            d = t.kernel_impls.topkImpl,
            h = t.kernel_impls.whereImpl;

        function c(t, e, a, s) {
            if ("linear" === a) return t.linear(e);
            if ("relu" === a) return t.relu(e);
            if ("elu" === a) return t.elu(e);
            if ("relu6" === a) return t.relu6(e);
            if ("prelu" === a) return t.prelu(e, s);
            throw new Error(`Activation ${a} has not been implemented for the CPU backend.`)
        }
        class p extends t.KernelBackend {
            constructor() {
                super(), this.blockSize = 48, this.firstUse = !0, this.data = new t.DataStorage(this, (0, t.engine)())
            }
            write(e, a, s) {
                this.firstUse && (this.firstUse = !1, (0, t.env)().get("IS_NODE") && t.backend_util.warn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
                const r = {};
                return this.data.set(r, {
                    values: e,
                    dtype: s
                }), r
            }
            move(t, e, a, s) {
                this.data.set(t, {
                    values: e,
                    dtype: s
                })
            }
            numDataIds() {
                return this.data.numDataIds()
            }
            async read(t) {
                return this.readSync(t)
            }
            readSync(e) {
                const {
                    dtype: a,
                    complexTensors: s
                } = this.data.get(e);
                if ("complex64" === a) {
                    const e = this.readSync(s.real.dataId),
                        a = this.readSync(s.imag.dataId);
                    return t.backend_util.mergeRealAndImagArrays(e, a)
                }
                return this.data.get(e).values
            }
            bufferSync(e) {
                const a = this.readSync(e.dataId);
                let s = a;
                if ("string" === e.dtype) try {
                    s = a.map(e => t.util.decodeString(e))
                } catch (r) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return t.buffer(e.shape, e.dtype, s)
            }
            makeOutput(e, a, s) {
                const r = this.write(e, a, s);
                return (0, t.engine)().makeTensorFromDataId(r, a, s, this)
            }
            disposeData(t) {
                if (this.data.has(t)) {
                    const {
                        complexTensors: e
                    } = this.data.get(t);
                    null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t)
                }
            }
            async time(e) {
                const a = t.util.now();
                return e(), {
                    kernelMs: t.util.now() - a
                }
            }
            memory() {
                return {
                    unreliable: !0,
                    reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
                }
            }
            complex(e, a) {
                const s = this.makeOutput(null, e.shape, "complex64");
                return this.data.get(s.dataId).complexTensors = {
                    real: (0, t.engine)().keep(e.clone()),
                    imag: (0, t.engine)().keep(a.clone())
                }, s
            }
            real(t) {
                return this.data.get(t.dataId).complexTensors.real.clone()
            }
            imag(t) {
                return this.data.get(t.dataId).complexTensors.imag.clone()
            }
            slice(e, s, r) {
                if ((0, a.assertNotComplex)(e, "slice"), t.slice_util.isSliceContinous(e.shape, s, r)) {
                    const a = t.slice_util.computeFlatOffset(s, e.strides),
                        o = t.util.sizeFromShape(r),
                        n = this.readSync(e.dataId);
                    return t.tensor(n.subarray(a, a + o), r, e.dtype)
                }
                const o = t.buffer(r, e.dtype),
                    n = this.bufferSync(e);
                for (let t = 0; t < o.size; ++t) {
                    const e = o.indexToLoc(t).map((t, e) => t + s[e]);
                    o.values[t] = n.get(...e)
                }
                return o.toTensor()
            }
            stridedSlice(e, s, r, o) {
                (0, a.assertNotComplex)(e, "stridedSlice");
                const n = t.slice_util.computeOutShape(s, r, o);
                if (n.some(t => 0 === t)) return t.tensor([], n);
                const i = t.buffer(n, e.dtype),
                    l = this.bufferSync(e);
                for (let t = 0; t < i.size; t++) {
                    const e = i.indexToLoc(t),
                        a = new Array(e.length);
                    for (let t = 0; t < a.length; t++) a[t] = e[t] * o[t] + s[t];
                    i.set(l.get(...a), ...e)
                }
                return i.toTensor()
            }
            diag(e) {
                const a = this.readSync(e.dataId),
                    s = t.buffer([e.size, e.size], e.dtype),
                    r = s.values;
                for (let t = 0; t < a.length; t++) r[t * e.size + t] = a[t];
                return s.toTensor()
            }
            unstack(t, e) {
                const a = t.shape[e],
                    s = new Array(t.rank - 1);
                let r = 0;
                for (let l = 0; l < t.rank; l++) l !== e && (s[r++] = t.shape[l]);
                const o = new Array(t.rank).fill(0),
                    n = t.shape.slice();
                n[e] = 1;
                const i = new Array(a);
                for (let l = 0; l < i.length; l++) o[e] = l, i[l] = this.slice(t, o, n).reshape(s);
                return i
            }
            reverse(e, s) {
                (0, a.assertNotComplex)(e, "reverse");
                const r = t.buffer(e.shape, e.dtype),
                    o = this.bufferSync(e);
                for (let t = 0; t < r.size; t++) {
                    const a = r.indexToLoc(t),
                        n = a.slice();
                    s.forEach(t => n[t] = e.shape[t] - 1 - n[t]), r.set(o.get(...n), ...a)
                }
                return r.toTensor()
            }
            concat(e, a) {
                if ("complex64" === e[0].dtype) {
                    const s = e.map(e => t.real(e)),
                        r = e.map(e => t.imag(e));
                    return t.complex(this.concat(s, a), this.concat(r, a))
                }
                const s = e.map(e => {
                        const s = t.util.sizeFromShape(e.shape.slice(a));
                        return e.as2D(-1, s)
                    }),
                    r = t.backend_util.computeOutShape(s.map(t => t.shape), 1),
                    o = t.buffer(r, e[0].dtype).values;
                if (1 === s[0].shape[0]) {
                    let t = 0;
                    s.forEach(e => {
                        o.set(this.readSync(e.dataId), t), t += e.size
                    })
                } else {
                    let t = 0;
                    s.forEach(e => {
                        const a = this.readSync(e.dataId);
                        let s = 0;
                        for (let n = 0; n < e.shape[0]; ++n) {
                            const i = n * r[1] + t;
                            for (let t = 0; t < e.shape[1]; ++t) o[i + t] = a[s++]
                        }
                        t += e.shape[1]
                    })
                }
                const n = t.backend_util.computeOutShape(e.map(t => t.shape), a);
                return t.tensor(o, n, e[0].dtype)
            }
            neg(e) {
                return (0, a.assertNotComplex)(e, "neg"), this.multiply(t.scalar(-1), e)
            }
            add(e, a) {
                return "complex64" === e.dtype || "complex64" === a.dtype ? this.broadcastedBinaryComplexOp(e.cast("complex64"), a.cast("complex64"), (t, e, a, s) => ({
                    real: t + a,
                    imag: e + s
                })) : this.broadcastedBinaryOp(e, a, (0, t.upcastType)(e.dtype, a.dtype), (t, e) => t + e)
            }
            addN(e) {
                (0, a.assertNotComplex)(e, "addN");
                const s = e.map(t => this.readSync(t.dataId)),
                    r = t.buffer(e[0].shape, e[0].dtype),
                    o = r.values;
                for (let t = 0; t < e.length; t++) {
                    const e = s[t];
                    for (let t = 0; t < o.length; t++) o[t] += e[t]
                }
                return r.toTensor()
            }
            softmax(e, a) {
                const s = t.util.parseAxisParam([a], e.shape),
                    r = (0, t.max)(e, s),
                    o = t.backend_util.expandShapeToKeepDim(r.shape, s),
                    n = this.subtract(e, r.reshape(o)),
                    i = this.exp(n),
                    l = this.sum(i, s).reshape(o);
                return t.div(i, l)
            }
            subtract(e, a) {
                return "complex64" === e.dtype || "complex64" === a.dtype ? this.broadcastedBinaryComplexOp(e.cast("complex64"), a.cast("complex64"), (t, e, a, s) => ({
                    real: t - a,
                    imag: e - s
                })) : this.broadcastedBinaryOp(e, a, (0, t.upcastType)(e.dtype, a.dtype), (t, e) => t - e)
            }
            pow(t, e) {
                return (0, a.assertNotComplex)([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.pow(t, e))
            }
            batchMatMul(e, s, r, o) {
                (0, a.assertNotComplex)([e, s], "matMul");
                const n = r ? e.shape[1] : e.shape[2],
                    i = r ? e.shape[2] : e.shape[1],
                    l = o ? s.shape[1] : s.shape[2],
                    d = e.shape[0],
                    h = this.readSync(e.dataId),
                    c = this.readSync(s.dataId),
                    [p, f, u] = r ? [e.strides[0], 1, e.strides[1]] : [e.strides[0], e.strides[1], 1],
                    [m, y, g] = o ? [1, s.strides[1], s.strides[0]] : [s.strides[1], 1, s.strides[0]],
                    x = i * l,
                    S = t.buffer([d, i, l], e.dtype),
                    I = S.values,
                    b = this.blockSize;
                for (let t = 0; t < d; t++)
                    for (let e = 0; e < i; e += b)
                        for (let a = 0; a < l; a += b)
                            for (let s = 0; s < n; s += b) {
                                const r = Math.min(e + b, i),
                                    o = Math.min(a + b, l),
                                    d = Math.min(s + b, n);
                                for (let n = e; n < r; n++)
                                    for (let e = a; e < o; e++) {
                                        let a = 0;
                                        for (let r = s; r < d; r++) a += h[t * p + n * f + r * u] * c[r * m + e * y + t * g];
                                        I[t * x + (n * l + e)] += a
                                    }
                            }
                return S.toTensor()
            }
            fusedBatchMatMul({
                a: t,
                b: e,
                transposeA: a,
                transposeB: s,
                bias: r,
                activation: o,
                preluActivationWeights: n
            }) {
                let i = this.batchMatMul(t, e, a, s);
                return r && (i = this.add(i, r)), o && (i = c(this, i, o, n)), i
            }
            multiply(e, a) {
                return "complex64" === e.dtype || "complex64" === a.dtype ? this.broadcastedBinaryComplexOp(e.cast("complex64"), a.cast("complex64"), (t, e, a, s) => ({
                    real: t * a - e * s,
                    imag: t * s + e * a
                })) : this.broadcastedBinaryOp(e, a, (0, t.upcastType)(e.dtype, a.dtype), (t, e) => t * e)
            }
            floorDiv(t, e) {
                (0, a.assertNotComplex)([t, e], "floorDiv");
                return this.broadcastedBinaryOp(t, e, "int32", (t, e) => Math.floor(t / e))
            }
            sum(e, s) {
                (0, a.assertNotComplex)(e, "sum"), t.backend_util.assertAxesAreInnerMostDims("sum", s, e.rank);
                const [r, o] = t.backend_util.computeOutAndReduceShapes(e.shape, s), n = (0, t.upcastType)(e.dtype, "int32"), i = t.zeros(r, n), l = t.util.sizeFromShape(o), d = this.readSync(i.dataId), h = this.readSync(e.dataId);
                for (let t = 0; t < d.length; ++t) {
                    const e = t * l;
                    let a = 0;
                    for (let t = 0; t < l; ++t) a += h[e + t];
                    d[t] = a
                }
                return i
            }
            prod(e, s) {
                (0, a.assertNotComplex)(e, "sum");
                const [r, o] = t.backend_util.computeOutAndReduceShapes(e.shape, s), n = (0, t.upcastType)(e.dtype, "int32"), i = t.zeros(r, n), l = t.util.sizeFromShape(o), d = this.readSync(i.dataId), h = this.readSync(e.dataId);
                for (let t = 0; t < d.length; ++t) {
                    const e = t * l;
                    let a = 1;
                    for (let t = 0; t < l; ++t) a *= h[e + t];
                    d[t] = a
                }
                return i
            }
            unsortedSegmentSum(e, s, r) {
                (0, a.assertNotComplex)(e, "unsortedSegmentSum");
                const o = [],
                    n = e.rank - s.rank;
                for (let t = 0; t < n; ++t) s = s.expandDims(t + 1);
                for (let a = 0; a < r; ++a) {
                    const r = t.scalar(a, "int32"),
                        n = t.equal(r, s).asType("float32").mul(e).sum(0);
                    o.push(n)
                }
                return t.stack(o)
            }
            argMin(e, s) {
                (0, a.assertNotComplex)(e, "argMin");
                const r = [s];
                t.backend_util.assertAxesAreInnerMostDims("argMin", r, e.rank);
                const [o, n] = t.backend_util.computeOutAndReduceShapes(e.shape, r), i = t.zeros(o, "int32"), l = t.util.sizeFromShape(n), d = this.readSync(i.dataId), h = this.readSync(e.dataId);
                for (let t = 0; t < d.length; ++t) {
                    const e = t * l;
                    let a = h[e],
                        s = 0;
                    for (let t = 0; t < l; ++t) {
                        const r = h[e + t];
                        r < a && (a = r, s = t)
                    }
                    d[t] = s
                }
                return i
            }
            argMax(e, s) {
                (0, a.assertNotComplex)(e, "argMax");
                const r = [s];
                t.backend_util.assertAxesAreInnerMostDims("argMax", r, e.rank);
                const [o, n] = t.backend_util.computeOutAndReduceShapes(e.shape, r), i = t.zeros(o, "int32"), l = t.util.sizeFromShape(n), d = this.readSync(i.dataId), h = this.readSync(e.dataId);
                for (let t = 0; t < d.length; ++t) {
                    const e = t * l;
                    let a = h[e],
                        s = 0;
                    for (let t = 0; t < l; ++t) {
                        const r = h[e + t];
                        r > a && (a = r, s = t)
                    }
                    d[t] = s
                }
                return i
            }
            cumsum(e, s, r, o) {
                if ((0, a.assertNotComplex)(e, "cumsum"), s !== e.rank - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${e.rank-1} ` + `but got axis=${s}`);
                const n = (0, t.upcastType)(e.dtype, "int32"),
                    i = t.zeros(e.shape, n),
                    l = this.readSync(i.dataId),
                    d = this.readSync(e.dataId),
                    h = e.shape[e.rank - 1],
                    c = o ? (t, e) => t + h - e - 1 : (t, e) => t + e;
                for (let t = 0; t < d.length; t += h)
                    for (let e = 0; e < h; e++) {
                        const a = c(t, e);
                        if (0 === e) l[a] = r ? 0 : d[a];
                        else {
                            const s = c(t, e - 1);
                            l[a] = r ? d[s] + l[s] : d[a] + l[s]
                        }
                    }
                return i
            }
            equal(t, e) {
                return (0, a.assertNotComplex)([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t === e ? 1 : 0)
            }
            notEqual(t, e) {
                return (0, a.assertNotComplex)([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t !== e ? 1 : 0)
            }
            less(t, e) {
                return (0, a.assertNotComplex)([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t < e ? 1 : 0)
            }
            lessEqual(t, e) {
                return (0, a.assertNotComplex)([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t <= e ? 1 : 0)
            }
            greater(t, e) {
                return (0, a.assertNotComplex)([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t > e ? 1 : 0)
            }
            greaterEqual(t, e) {
                return (0, a.assertNotComplex)([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t >= e ? 1 : 0)
            }
            logicalNot(t) {
                (0, a.assertNotComplex)(t, "logicalNot");
                const e = this.readSync(t.dataId),
                    s = new Uint8Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = e[a] ? 0 : 1;
                return this.makeOutput(s, t.shape, "bool")
            }
            logicalAnd(t, e) {
                return (0, a.assertNotComplex)([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t && e)
            }
            logicalOr(t, e) {
                return (0, a.assertNotComplex)([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", (t, e) => t || e)
            }
            select(e, s, r) {
                (0, a.assertNotComplex)([e, s, r], "select");
                const o = this.readSync(e.dataId),
                    n = this.readSync(s.dataId),
                    i = this.readSync(r.dataId),
                    l = t.zeros(s.shape, (0, t.upcastType)(s.dtype, r.dtype)),
                    d = this.readSync(l.dataId);
                let h = 0;
                const c = 0 === e.rank || e.rank > 1 || 1 === s.rank ? 1 : t.util.sizeFromShape(s.shape.slice(1));
                for (let t = 0; t < o.length; t++)
                    for (let e = 0; e < c; e++) 1 === o[t] ? d[h++] = n[t] : d[h++] = i[t];
                return l
            }
            where(t) {
                (0, a.assertNotComplex)([t], "where");
                const e = this.readSync(t.dataId);
                return h(t.shape, e)
            }
            topk(t, e, s) {
                (0, a.assertNotComplex)(t, "topk");
                const r = this.readSync(t.dataId);
                return d(r, t.shape, t.dtype, e, s)
            }
            min(e, s) {
                (0, a.assertNotComplex)(e, "min"), t.backend_util.assertAxesAreInnerMostDims("min", s, e.rank);
                const [r, o] = t.backend_util.computeOutAndReduceShapes(e.shape, s), n = t.zeros(r, e.dtype), i = t.util.sizeFromShape(o), l = this.readSync(n.dataId), d = this.readSync(e.dataId);
                for (let t = 0; t < l.length; ++t) {
                    const e = t * i;
                    let a = d[e];
                    for (let t = 0; t < i; ++t) {
                        const s = d[e + t];
                        s < a && (a = s)
                    }
                    l[t] = a
                }
                return n
            }
            minimum(t, e) {
                return (0, a.assertNotComplex)([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.min(t, e))
            }
            mod(t, e) {
                return (0, a.assertNotComplex)([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => {
                    const a = t % e;
                    return t < 0 && e < 0 || t >= 0 && e >= 0 ? a : (a + e) % e
                })
            }
            maximum(t, e) {
                return (0, a.assertNotComplex)([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.max(t, e))
            }
            all(e, s) {
                (0, a.assertNotComplex)(e, "all"), t.backend_util.assertAxesAreInnerMostDims("all", s, e.rank);
                const [r, o] = t.backend_util.computeOutAndReduceShapes(e.shape, s), n = t.zeros(r, e.dtype), i = t.util.sizeFromShape(o), l = this.readSync(n.dataId), d = this.readSync(e.dataId);
                for (let t = 0; t < l.length; ++t) {
                    const e = t * i;
                    let a = d[e];
                    for (let t = 0; t < i; ++t) {
                        const s = d[e + t];
                        a = a && s
                    }
                    l[t] = a
                }
                return n
            }
            any(e, s) {
                (0, a.assertNotComplex)(e, "any"), t.backend_util.assertAxesAreInnerMostDims("any", s, e.rank);
                const [r, o] = t.backend_util.computeOutAndReduceShapes(e.shape, s), n = t.zeros(r, e.dtype), i = t.util.sizeFromShape(o), l = this.readSync(n.dataId), d = this.readSync(e.dataId);
                for (let t = 0; t < l.length; ++t) {
                    const e = t * i;
                    let a = d[e];
                    for (let t = 0; t < i; ++t) {
                        const s = d[e + t];
                        a = a || s
                    }
                    l[t] = a
                }
                return n
            }
            squaredDifference(t, e) {
                return (0, a.assertNotComplex)([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => {
                    const a = t - e;
                    return a * a
                })
            }
            ceil(t) {
                (0, a.assertNotComplex)(t, "ceil");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = Math.ceil(e[a]);
                return this.makeOutput(s, t.shape, "float32")
            }
            floor(t) {
                (0, a.assertNotComplex)(t, "floor");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = Math.floor(e[a]);
                return this.makeOutput(s, t.shape, "float32")
            }
            sign(t) {
                (0, a.assertNotComplex)(t, "x");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) e[a] < 0 ? s[a] = -1 : e[a] > 0 ? s[a] = 1 : s[a] = 0;
                return this.makeOutput(s, t.shape, "float32")
            }
            isNaN(t) {
                (0, a.assertNotComplex)(t, "x");
                const e = this.readSync(t.dataId),
                    s = new Uint8Array(e.length);
                for (let a = 0; a < e.length; ++a) Number.isNaN(e[a]) && (s[a] = 1);
                return this.makeOutput(s, t.shape, "bool")
            }
            isInf(t) {
                (0, a.assertNotComplex)(t, "x");
                const e = this.readSync(t.dataId),
                    s = new Uint8Array(e.length);
                for (let a = 0; a < e.length; ++a) Math.abs(e[a]) === 1 / 0 && (s[a] = 1);
                return this.makeOutput(s, t.shape, "bool")
            }
            isFinite(t) {
                (0, a.assertNotComplex)(t, "x");
                const e = this.readSync(t.dataId),
                    s = new Uint8Array(e.length);
                for (let a = 0; a < e.length; ++a) Number.isFinite(e[a]) && (s[a] = 1);
                return this.makeOutput(s, t.shape, "bool")
            }
            round(t) {
                (0, a.assertNotComplex)(t, "round");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) {
                    const t = Math.floor(e[a]);
                    e[a] - t < .5 ? s[a] = Math.floor(e[a]) : e[a] - t > .5 ? s[a] = Math.ceil(e[a]) : s[a] = t % 2 == 0 ? t : t + 1
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            exp(t) {
                (0, a.assertNotComplex)(t, "exp");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = Math.exp(e[a]);
                return this.makeOutput(s, t.shape, "float32")
            }
            expm1(t) {
                (0, a.assertNotComplex)(t, "expm1");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = Math.expm1(e[a]);
                return this.makeOutput(s, t.shape, "float32")
            }
            log(t) {
                (0, a.assertNotComplex)(t, "log");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) {
                    const t = e[a];
                    s[a] = Math.log(t)
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            log1p(t) {
                (0, a.assertNotComplex)(t, "log1p");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) {
                    const t = e[a];
                    s[a] = Math.log1p(t)
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            sqrt(t) {
                (0, a.assertNotComplex)(t, "sqrt");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) {
                    const t = e[a];
                    s[a] = Math.sqrt(t)
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            rsqrt(t) {
                (0, a.assertNotComplex)(t, "rsqrt");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) {
                    const t = e[a];
                    s[a] = 1 / Math.sqrt(t)
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            reciprocal(t) {
                (0, a.assertNotComplex)(t, "reciprocal");
                const e = this.readSync(t.dataId),
                    s = new Float32Array(e.length);
                for (let a = 0; a < e.length; ++a) s[a] = 1 / e[a];
                return this.makeOutput(s, t.shape, "float32")
            }
            linear(t) {
                return t
            }
            relu(e) {
                (0, a.assertNotComplex)(e, "relu");
                const s = t.zeros(e.shape, e.dtype),
                    r = this.readSync(s.dataId),
                    o = this.readSync(e.dataId);
                for (let t = 0; t < o.length; ++t) r[t] = Math.max(0, o[t]);
                return s
            }
            relu6(e) {
                (0, a.assertNotComplex)(e, "relu");
                const s = t.zeros(e.shape, e.dtype),
                    r = this.readSync(s.dataId),
                    o = this.readSync(e.dataId);
                for (let t = 0; t < o.length; ++t) r[t] = Math.min(Math.max(0, o[t]), 6);
                return s
            }
            prelu(t, e) {
                return (0, a.assertNotComplex)([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => t < 0 ? e * t : t)
            }
            elu(t) {
                (0, a.assertNotComplex)(t, "elu");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) {
                    const t = s[a];
                    e[a] = t >= 0 ? t : Math.exp(t) - 1
                }
                return this.makeOutput(e, t.shape, "float32")
            }
            eluDer(t, e) {
                (0, a.assertNotComplex)([t, e], "eluDer");
                const s = new Float32Array(e.size),
                    r = this.readSync(e.dataId),
                    o = this.readSync(t.dataId);
                for (let a = 0; a < r.length; ++a) {
                    const t = r[a];
                    s[a] = t >= 1 ? o[a] : o[a] * (t + 1)
                }
                return this.makeOutput(s, e.shape, "float32")
            }
            selu(e) {
                (0, a.assertNotComplex)(e, "selu");
                const s = t.backend_util.SELU_SCALEALPHA,
                    r = t.backend_util.SELU_SCALE,
                    o = new Float32Array(e.size),
                    n = this.readSync(e.dataId);
                for (let t = 0; t < n.length; ++t) {
                    const e = n[t];
                    o[t] = e >= 0 ? r * e : s * (Math.exp(e) - 1)
                }
                return this.makeOutput(o, e.shape, "float32")
            }
            clip(t, e, s) {
                (0, a.assertNotComplex)(t, "clip");
                const r = new Float32Array(t.size),
                    o = this.readSync(t.dataId);
                for (let a = 0; a < o.length; ++a) {
                    const t = o[a];
                    r[a] = t > s ? s : t < e ? e : t
                }
                return this.makeOutput(r, t.shape, "float32")
            }
            abs(t) {
                const e = new Float32Array(t.size),
                    a = this.readSync(t.dataId);
                for (let s = 0; s < a.length; ++s) e[s] = Math.abs(a[s]);
                return this.makeOutput(e, t.shape, "float32")
            }
            complexAbs(t) {
                const e = new Float32Array(t.size),
                    a = this.readSync(t.dataId);
                for (let s = 0; s < t.size; ++s) {
                    const t = a[2 * s],
                        r = a[2 * s + 1];
                    e[s] = Math.hypot(t, r)
                }
                return this.makeOutput(e, t.shape, "float32")
            }
            int(t) {
                (0, a.assertNotComplex)(t, "int");
                const e = new Int32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = s[a];
                return this.makeOutput(e, t.shape, "int32")
            }
            sigmoid(t) {
                (0, a.assertNotComplex)(t, "sigmoid");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = 1 / (1 + Math.exp(-s[a]));
                return this.makeOutput(e, t.shape, "float32")
            }
            softplus(t) {
                (0, a.assertNotComplex)(t, "softplus");
                const e = Math.log(1.1920928955078125e-7) + 2,
                    s = new Float32Array(t.size),
                    r = this.readSync(t.dataId);
                for (let a = 0; a < r.length; ++a) {
                    const t = r[a] > -e,
                        o = r[a] < e,
                        n = Math.exp(r[a]);
                    let i;
                    i = o ? n : t ? r[a] : Math.log(1 + n), s[a] = i
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            sin(t) {
                (0, a.assertNotComplex)(t, "sin");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.sin(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            cos(t) {
                (0, a.assertNotComplex)(t, "cos");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.cos(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            tan(t) {
                (0, a.assertNotComplex)(t, "tan");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.tan(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            asin(t) {
                (0, a.assertNotComplex)(t, "asin");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.asin(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            acos(t) {
                (0, a.assertNotComplex)(t, "acos");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.acos(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            atan(t) {
                (0, a.assertNotComplex)(t, "atan");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.atan(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            atan2(t, e) {
                return (0, a.assertNotComplex)([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.atan2(t, e))
            }
            sinh(t) {
                (0, a.assertNotComplex)(t, "sinh");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.sinh(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            cosh(t) {
                (0, a.assertNotComplex)(t, "cosh");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.cosh(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            tanh(e) {
                (0, a.assertNotComplex)(e, "tanh");
                const s = new Float32Array(e.size),
                    r = this.readSync(e.dataId);
                for (let a = 0; a < r.length; ++a) s[a] = t.util.tanh(r[a]);
                return this.makeOutput(s, e.shape, "float32")
            }
            asinh(t) {
                (0, a.assertNotComplex)(t, "asinh");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.asinh(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            acosh(t) {
                (0, a.assertNotComplex)(t, "acosh");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.acosh(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            atanh(t) {
                (0, a.assertNotComplex)(t, "atanh");
                const e = new Float32Array(t.size),
                    s = this.readSync(t.dataId);
                for (let a = 0; a < s.length; ++a) e[a] = Math.atanh(s[a]);
                return this.makeOutput(e, t.shape, "float32")
            }
            erf(e) {
                (0, a.assertNotComplex)(e, "erf");
                const s = new Float32Array(e.size),
                    r = this.readSync(e.dataId),
                    o = t.backend_util.ERF_P,
                    n = t.backend_util.ERF_A1,
                    i = t.backend_util.ERF_A2,
                    l = t.backend_util.ERF_A3,
                    d = t.backend_util.ERF_A4,
                    h = t.backend_util.ERF_A5;
                for (let t = 0; t < r.length; ++t) {
                    const e = Math.sign(r[t]),
                        a = Math.abs(r[t]),
                        c = 1 / (1 + o * a);
                    s[t] = e * (1 - ((((h * c + d) * c + l) * c + i) * c + n) * c * Math.exp(-a * a))
                }
                return this.makeOutput(s, e.shape, "float32")
            }
            step(t, e = 0) {
                (0, a.assertNotComplex)(t, "step");
                const s = new Float32Array(t.size),
                    r = this.readSync(t.dataId);
                for (let a = 0; a < r.length; ++a) {
                    const t = r[a];
                    isNaN(t) ? s[a] = NaN : s[a] = t > 0 ? 1 : e
                }
                return this.makeOutput(s, t.shape, "float32")
            }
            fusedConv2d({
                input: t,
                filter: e,
                convInfo: a,
                bias: s,
                activation: r,
                preluActivationWeights: o
            }) {
                let n = this.conv2d(t, e, a);
                return s && (n = this.add(n, s)), r && (n = c(this, n, r, o)), n
            }
            conv2d(e, s, r) {
                (0, a.assertNotComplex)([e, s], "conv2d");
                const o = r.filterHeight,
                    n = r.filterWidth,
                    i = r.dilationHeight,
                    l = r.dilationWidth,
                    d = r.padInfo.left,
                    h = r.padInfo.top,
                    c = "channelsLast" === r.dataFormat,
                    p = t.buffer(r.outShape, e.dtype),
                    f = e.strides[0],
                    u = c ? e.strides[1] : e.strides[2],
                    m = c ? e.strides[2] : 1,
                    y = c ? 1 : e.strides[1],
                    g = p.strides[0],
                    x = c ? p.strides[1] : p.strides[2],
                    S = c ? p.strides[2] : 1,
                    I = c ? 1 : p.strides[1],
                    b = this.readSync(e.dataId),
                    M = this.readSync(s.dataId),
                    k = p.values;
                for (let t = 0; t < r.batchSize; ++t) {
                    const e = t * f,
                        a = t * g;
                    for (let t = 0; t < r.outHeight; ++t) {
                        const c = a + t * x,
                            p = t * r.strideHeight - h;
                        for (let t = 0; t < o; t++) {
                            const a = p + t * i;
                            if (a < 0 || a >= r.inHeight) continue;
                            const o = t * s.strides[0],
                                h = e + a * u;
                            for (let t = 0; t < r.outWidth; ++t) {
                                const e = c + t * S,
                                    a = t * r.strideWidth - d;
                                for (let t = 0; t < n; t++) {
                                    const n = a + t * l;
                                    if (n < 0 || n >= r.inWidth) continue;
                                    const i = h + n * m;
                                    let d = o + t * s.strides[1];
                                    for (let t = 0; t < r.inChannels; ++t) {
                                        const a = b[i + t * y];
                                        for (let t = 0; t < r.outChannels; ++t) k[e + t * I] += a * M[d + t];
                                        d += r.outChannels
                                    }
                                }
                            }
                        }
                    }
                }
                return p.toTensor()
            }
            conv3d(e, a, s) {
                const r = s.filterDepth,
                    o = s.filterHeight,
                    n = s.filterWidth,
                    i = s.dilationDepth,
                    l = s.dilationHeight,
                    d = s.dilationWidth,
                    h = s.padInfo.front,
                    c = s.padInfo.left,
                    p = s.padInfo.top,
                    f = t.buffer(s.outShape, e.dtype),
                    u = this.readSync(e.dataId),
                    m = this.readSync(a.dataId),
                    y = f.values;
                for (let t = 0; t < s.batchSize; ++t) {
                    const g = t * e.strides[0],
                        x = t * f.strides[0];
                    for (let t = 0; t < s.outDepth; ++t) {
                        const S = x + t * f.strides[1],
                            I = t * s.strideDepth - h;
                        for (let t = 0; t < r; t++) {
                            const r = I + t * i;
                            if (r < 0 || r >= s.inDepth) continue;
                            const h = t * a.strides[0],
                                x = g + r * e.strides[1];
                            for (let t = 0; t < s.outHeight; ++t) {
                                const r = S + t * f.strides[2],
                                    i = t * s.strideHeight - p;
                                for (let t = 0; t < o; t++) {
                                    const o = i + t * l;
                                    if (o < 0 || o >= s.inHeight) continue;
                                    const p = h + t * a.strides[1],
                                        f = x + o * e.strides[2];
                                    for (let t = 0; t < s.outWidth; ++t) {
                                        const e = r + t * s.outChannels,
                                            o = t * s.strideWidth - c;
                                        for (let t = 0; t < n; t++) {
                                            const r = o + t * d;
                                            if (r < 0 || r >= s.inWidth) continue;
                                            const n = p + t * a.strides[2],
                                                i = f + r * s.inChannels;
                                            let l = n;
                                            for (let t = 0; t < s.inChannels; ++t) {
                                                const a = u[i + t];
                                                for (let t = 0; t < s.outChannels; ++t) y[e + t] += a * m[l + t];
                                                l += s.outChannels
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return f.toTensor()
            }
            conv2dDerInput(e, s, r) {
                (0, a.assertNotComplex)([e, s], "conv2dDerInput");
                const o = t.buffer(r.inShape, "float32"),
                    n = o.values,
                    i = this.readSync(e.dataId),
                    l = this.readSync(s.dataId),
                    [d, h, c] = s.strides,
                    {
                        batchSize: p,
                        filterHeight: f,
                        filterWidth: u,
                        inChannels: m,
                        inHeight: y,
                        inWidth: g,
                        outChannels: x,
                        outHeight: S,
                        outWidth: I,
                        strideHeight: b,
                        strideWidth: M,
                        dataFormat: k
                    } = r,
                    C = f - 1 - r.padInfo.top,
                    N = u - 1 - r.padInfo.left,
                    v = "channelsLast" === k,
                    A = o.strides[0],
                    w = v ? o.strides[1] : o.strides[2],
                    F = v ? o.strides[2] : 1,
                    D = v ? 1 : o.strides[1],
                    z = e.strides[0],
                    O = v ? e.strides[1] : e.strides[2],
                    T = v ? e.strides[2] : 1,
                    W = v ? 1 : e.strides[1];
                for (let t = 0; t < p; ++t)
                    for (let e = 0; e < m; ++e)
                        for (let a = 0; a < y; ++a) {
                            const s = a - C,
                                r = Math.max(0, Math.ceil(s / b)),
                                o = Math.min(S, (f + s) / b);
                            for (let p = 0; p < g; ++p) {
                                const m = p - N,
                                    y = Math.max(0, Math.ceil(m / M)),
                                    g = Math.min(I, (u + m) / M);
                                let S = 0;
                                for (let a = r; a < o; ++a) {
                                    const r = a * b - s;
                                    for (let s = y; s < g; ++s) {
                                        const o = z * t + O * a + T * s,
                                            n = d * (f - 1 - r) + h * (u - 1 - (s * M - m)) + c * e;
                                        for (let t = 0; t < x; ++t) {
                                            S += i[o + W * t] * l[n + t]
                                        }
                                    }
                                }
                                n[A * t + w * a + F * p + D * e] = S
                            }
                        }
                return o.toTensor()
            }
            conv3dDerInput(e, a, s) {
                const r = t.buffer(s.inShape, "float32"),
                    o = r.values,
                    [n, i, l, d] = r.strides,
                    h = this.readSync(e.dataId),
                    [c, p, f, u] = e.strides,
                    m = this.readSync(a.dataId),
                    [y, g, x, S] = a.strides,
                    {
                        batchSize: I,
                        filterDepth: b,
                        filterHeight: M,
                        filterWidth: k,
                        inChannels: C,
                        inDepth: N,
                        inHeight: v,
                        inWidth: A,
                        outChannels: w,
                        outDepth: F,
                        outHeight: D,
                        outWidth: z,
                        strideDepth: O,
                        strideHeight: T,
                        strideWidth: W
                    } = s,
                    _ = b - 1 - s.padInfo.front,
                    H = M - 1 - s.padInfo.top,
                    B = k - 1 - s.padInfo.left;
                for (let t = 0; t < I; ++t)
                    for (let e = 0; e < C; ++e)
                        for (let a = 0; a < N; ++a) {
                            const s = a - _,
                                r = Math.max(0, Math.ceil(s / O)),
                                I = Math.min(F, (b + s) / O);
                            for (let C = 0; C < v; ++C) {
                                const N = C - H,
                                    v = Math.max(0, Math.ceil(N / T)),
                                    F = Math.min(D, (M + N) / T);
                                for (let D = 0; D < A; ++D) {
                                    const A = D - B,
                                        _ = Math.max(0, Math.ceil(A / W)),
                                        H = Math.min(z, (k + A) / W);
                                    let P = 0;
                                    for (let a = r; a < I; ++a) {
                                        const r = a * O - s;
                                        for (let s = v; s < F; ++s) {
                                            const o = s * T - N;
                                            for (let n = _; n < H; ++n) {
                                                const i = c * t + p * a + f * s + u * n,
                                                    l = y * (b - 1 - r) + g * (M - 1 - o) + x * (k - 1 - (n * W - A)) + S * e;
                                                for (let t = 0; t < w; ++t) {
                                                    P += h[i + t] * m[l + t]
                                                }
                                            }
                                        }
                                    }
                                    o[n * t + i * a + l * C + d * D + e] = P
                                }
                            }
                        }
                return r.toTensor()
            }
            conv2dDerFilter(e, s, r) {
                (0, a.assertNotComplex)([e, s], "conv2dDerFilter");
                const o = r.strideHeight,
                    n = r.strideWidth,
                    i = r.filterHeight,
                    l = r.filterWidth,
                    d = "channelsLast" === r.dataFormat,
                    h = t.buffer(r.filterShape, "float32"),
                    c = r.padInfo.left,
                    p = r.padInfo.top,
                    f = this.bufferSync(e),
                    u = this.bufferSync(s);
                for (let t = 0; t < i; ++t) {
                    const e = Math.max(0, Math.ceil((p - t) / o)),
                        a = Math.min(r.outHeight, (r.inHeight + p - t) / o);
                    for (let s = 0; s < l; ++s) {
                        const i = Math.max(0, Math.ceil((c - s) / n)),
                            l = Math.min(r.outWidth, (r.inWidth + c - s) / n);
                        for (let m = 0; m < r.inChannels; ++m)
                            for (let y = 0; y < r.outChannels; ++y) {
                                let g = 0;
                                for (let h = 0; h < r.batchSize; ++h)
                                    for (let r = e; r < a; ++r) {
                                        const e = t + r * o - p;
                                        for (let t = i; t < l; ++t) {
                                            const a = s + t * n - c;
                                            g += d ? f.get(h, e, a, m) * u.get(h, r, t, y) : f.get(h, m, e, a) * u.get(h, y, r, t)
                                        }
                                    }
                                h.set(g, t, s, m, y)
                            }
                    }
                }
                return h.toTensor()
            }
            conv3dDerFilter(e, a, s) {
                const r = s.strideDepth,
                    o = s.strideHeight,
                    n = s.strideWidth,
                    i = s.filterDepth,
                    l = s.filterHeight,
                    d = s.filterWidth,
                    h = t.buffer(s.filterShape, "float32"),
                    c = h.values,
                    [p, f, u, m] = h.strides,
                    y = this.readSync(a.dataId),
                    [g, x, S, I] = a.strides,
                    b = this.readSync(e.dataId),
                    [M, k, C, N] = e.strides,
                    v = s.padInfo.front,
                    A = s.padInfo.left,
                    w = s.padInfo.top;
                for (let t = 0; t < i; ++t) {
                    const e = Math.max(0, Math.ceil((v - t) / r)),
                        a = Math.min(s.outDepth, (s.inDepth + v - t) / r),
                        i = t * p;
                    for (let h = 0; h < l; ++h) {
                        const l = Math.max(0, Math.ceil((w - h) / o)),
                            p = Math.min(s.outHeight, (s.inHeight + w - h) / o),
                            F = h * f + i;
                        for (let i = 0; i < d; ++i) {
                            const d = Math.max(0, Math.ceil((A - i) / n)),
                                f = Math.min(s.outWidth, (s.inWidth + A - i) / n),
                                D = i * u + F;
                            for (let u = 0; u < s.inChannels; ++u) {
                                const F = u * m + D;
                                for (let m = 0; m < s.outChannels; ++m) {
                                    let D = 0;
                                    for (let c = 0; c < s.batchSize; ++c) {
                                        const s = c * M,
                                            F = c * g;
                                        for (let c = e; c < a; ++c) {
                                            const e = (t + c * r - v) * k + s,
                                                a = c * x + F;
                                            for (let t = l; t < p; ++t) {
                                                const s = (h + t * o - w) * C + e,
                                                    r = t * S + a;
                                                for (let t = d; t < f; ++t) {
                                                    const e = t * I + r;
                                                    D += b[(i + t * n - A) * N + s + u] * y[e + m]
                                                }
                                            }
                                        }
                                    }
                                    c[F + m] = D
                                }
                            }
                        }
                    }
                }
                return h.toTensor()
            }
            fusedDepthwiseConv2D({
                input: t,
                filter: e,
                convInfo: a,
                bias: s,
                activation: r,
                preluActivationWeights: o
            }) {
                let n = this.depthwiseConv2D(t, e, a);
                return s && (n = this.add(n, s)), r && (n = c(this, n, r, o)), n
            }
            depthwiseConv2D(e, s, r) {
                (0, a.assertNotComplex)([e, s], "depthwiseConv2D");
                const o = r.filterHeight,
                    n = r.filterWidth,
                    i = r.dilationHeight,
                    l = r.dilationWidth,
                    d = r.padInfo.left,
                    h = r.padInfo.top,
                    c = r.outChannels / r.inChannels,
                    p = t.buffer(r.outShape, e.dtype),
                    f = this.readSync(e.dataId),
                    u = this.readSync(s.dataId),
                    m = p.values;
                for (let t = 0; t < r.batchSize; ++t) {
                    const a = t * e.strides[0],
                        y = t * p.strides[0];
                    for (let t = 0; t < r.outHeight; ++t) {
                        const g = y + t * p.strides[1],
                            x = t * r.strideHeight - d;
                        for (let t = 0; t < o; ++t) {
                            const o = x + t * i;
                            if (o < 0 || o >= r.inHeight) continue;
                            const d = t * s.strides[0],
                                y = a + o * e.strides[1];
                            for (let t = 0; t < r.outWidth; ++t) {
                                const e = g + t * p.strides[2],
                                    a = t * r.strideWidth - h;
                                for (let t = 0; t < n; ++t) {
                                    const o = a + t * l;
                                    if (o < 0 || o >= r.inWidth) continue;
                                    const n = d + t * s.strides[1],
                                        i = y + o * r.inChannels;
                                    let h = e,
                                        p = n;
                                    for (let t = 0; t < r.inChannels; ++t) {
                                        const e = f[i + t];
                                        for (let t = 0; t < c; ++t) m[h + t] += e * u[p + t];
                                        h += c, p += c
                                    }
                                }
                            }
                        }
                    }
                }
                return p.toTensor()
            }
            depthwiseConv2DDerInput(e, s, r) {
                (0, a.assertNotComplex)([e, s], "depthwiseConv2DDerInput");
                const o = t.buffer(r.inShape, "float32"),
                    n = o.values,
                    [i, l, d] = o.strides,
                    h = this.readSync(e.dataId),
                    [c, p, f] = e.strides,
                    u = this.readSync(s.dataId),
                    [m, y, g] = s.strides,
                    {
                        batchSize: x,
                        filterHeight: S,
                        filterWidth: I,
                        inChannels: b,
                        inHeight: M,
                        inWidth: k,
                        outChannels: C,
                        outHeight: N,
                        outWidth: v,
                        strideHeight: A,
                        strideWidth: w
                    } = r,
                    F = S - 1 - r.padInfo.top,
                    D = I - 1 - r.padInfo.left,
                    z = C / b;
                for (let t = 0; t < x; ++t)
                    for (let e = 0; e < b; ++e)
                        for (let a = 0; a < M; ++a) {
                            const s = a - F,
                                r = Math.max(0, Math.ceil(s / A)),
                                o = Math.min(N, (S + s) / A);
                            for (let x = 0; x < k; ++x) {
                                const b = x - D,
                                    M = Math.max(0, Math.ceil(b / w)),
                                    k = Math.min(v, (I + b) / w);
                                let C = 0;
                                for (let a = r; a < o; ++a) {
                                    const r = a * A - s;
                                    for (let s = M; s < k; ++s) {
                                        const o = c * t + p * a + f * s,
                                            n = m * (S - 1 - r) + y * (I - 1 - (s * w - b)) + g * e;
                                        for (let t = 0; t < z; ++t) {
                                            C += h[o + (e * z + t)] * u[n + t]
                                        }
                                    }
                                }
                                n[i * t + l * a + d * x + e] = C
                            }
                        }
                return o.toTensor()
            }
            depthwiseConv2DDerFilter(e, s, r) {
                (0, a.assertNotComplex)([e, s], "depthwiseConv2DDerFilter");
                const o = r.strideHeight,
                    n = r.strideWidth,
                    i = r.filterHeight,
                    l = r.filterWidth,
                    d = t.buffer(r.filterShape, "float32"),
                    h = r.padInfo.left,
                    c = r.padInfo.top,
                    p = r.outChannels / r.inChannels,
                    f = this.bufferSync(e),
                    u = this.bufferSync(s);
                for (let t = 0; t < i; ++t) {
                    const e = Math.max(0, Math.ceil((c - t) / o)),
                        a = Math.min(r.outHeight, (r.inHeight + c - t) / o);
                    for (let s = 0; s < l; ++s) {
                        const i = Math.max(0, Math.ceil((h - s) / n)),
                            l = Math.min(r.outWidth, (r.inWidth + h - s) / n);
                        for (let m = 0; m < r.outChannels; ++m) {
                            const y = Math.trunc(m / p),
                                g = m % p;
                            let x = 0;
                            for (let d = 0; d < r.batchSize; ++d)
                                for (let r = e; r < a; ++r) {
                                    const e = t + r * o - c;
                                    for (let t = i; t < l; ++t) {
                                        const a = s + t * n - h;
                                        x += f.get(d, e, a, y) * u.get(d, r, t, m)
                                    }
                                }
                            d.set(x, t, s, y, g)
                        }
                    }
                }
                return d.toTensor()
            }
            tile(t, e) {
                return (0, a.assertNotComplex)(t, "tile"), l(this.bufferSync(t), e)
            }
            pad(e, s, r) {
                (0, a.assertNotComplex)(e, "pad");
                const o = s.map((t, a) => t[0] + e.shape[a] + t[1]),
                    n = s.map(t => t[0]),
                    i = this.bufferSync(e),
                    l = t.buffer(o, e.dtype);
                0 !== r && l.values.fill(r);
                for (let t = 0; t < e.size; t++) {
                    const e = i.indexToLoc(t),
                        a = e.map((t, e) => t + n[e]);
                    l.set(i.get(...e), ...a)
                }
                return l.toTensor()
            }
            gather(e, s, r) {
                (0, a.assertNotComplex)([e, s], "gather");
                const o = e.shape.slice(),
                    n = this.readSync(s.dataId);
                o[r] = n.length;
                const i = t.buffer(o, e.dtype),
                    l = this.bufferSync(e);
                for (let t = 0; t < i.size; ++t) {
                    const e = i.indexToLoc(t),
                        a = e.slice();
                    a[r] = n[e[r]];
                    const s = l.locToIndex(a);
                    i.values[t] = l.values[s]
                }
                return i.toTensor()
            }
            batchToSpaceND(e, s, r) {
                (0, a.assertNotComplex)([e], "batchToSpaceND");
                const o = s.reduce((t, e) => t * e),
                    n = t.backend_util.getReshaped(e.shape, s, o),
                    i = t.backend_util.getPermuted(n.length, s.length),
                    l = t.backend_util.getReshapedPermuted(e.shape, s, o),
                    d = t.backend_util.getSliceBeginCoords(r, s.length),
                    h = t.backend_util.getSliceSize(l, r, s.length);
                return t.transpose(e.reshape(n), i).reshape(l).slice(d, h)
            }
            spaceToBatchND(e, s, r) {
                (0, a.assertNotComplex)([e], "spaceToBatchND");
                const o = s.reduce((t, e) => t * e),
                    n = [
                        [0, 0]
                    ];
                n.push(...r);
                for (let t = 1 + s.length; t < e.shape.length; ++t) n.push([0, 0]);
                const i = e.pad(n),
                    l = t.backend_util.getReshaped(i.shape, s, o, !1),
                    d = t.backend_util.getPermuted(l.length, s.length, !1),
                    h = t.backend_util.getReshapedPermuted(i.shape, s, o, !1),
                    c = t.transpose(i.reshape(l), d);
                return (0, t.reshape)(c, h)
            }
            maxPool(t, e) {
                (0, a.assertNotComplex)(t, "maxPool");
                const r = this.readSync(t.dataId);
                return (0, s.pool)(r, t.shape, t.dtype, t.strides, e, "max").toTensor()
            }
            maxPoolBackprop(e, r, o, n) {
                (0, a.assertNotComplex)([r, o], "maxPoolBackprop");
                const i = this.readSync(r.dataId),
                    l = (0, t.buffer)(n.outShape, r.dtype, (0, s.maxPoolPositions)(i, r.shape, r.dtype, n).values),
                    d = n.strideHeight,
                    h = n.strideWidth,
                    c = n.dilationHeight,
                    p = n.dilationWidth,
                    f = n.effectiveFilterHeight,
                    u = n.effectiveFilterWidth,
                    m = u - 1 - n.padInfo.left,
                    y = f - 1 - n.padInfo.top,
                    g = t.buffer(r.shape, "float32"),
                    x = this.bufferSync(e);
                for (let t = 0; t < n.batchSize; ++t)
                    for (let e = 0; e < n.inChannels; ++e)
                        for (let a = 0; a < n.inHeight; ++a)
                            for (let s = 0; s < n.inWidth; ++s) {
                                const r = a - y,
                                    o = s - m;
                                let i = 0;
                                for (let a = 0; a < f; a += c) {
                                    const s = (r + a) / d;
                                    if (!(s < 0 || s >= n.outHeight || Math.floor(s) !== s))
                                        for (let r = 0; r < u; r += p) {
                                            const d = (o + r) / h;
                                            if (d < 0 || d >= n.outWidth || Math.floor(d) !== d) continue;
                                            const c = f * u - 1 - l.get(t, s, d, e) === a * u + r ? 1 : 0;
                                            0 !== c && (i += x.get(t, s, d, e) * c)
                                        }
                                }
                                g.set(i, t, a, s, e)
                            }
                return g.toTensor()
            }
            avgPoolBackprop(e, s, r) {
                (0, a.assertNotComplex)([e, s], "avgPoolBackprop");
                const o = r.strideHeight,
                    n = r.strideWidth,
                    i = r.filterHeight,
                    l = r.filterWidth,
                    d = r.dilationHeight,
                    h = r.dilationWidth,
                    c = r.effectiveFilterHeight,
                    p = r.effectiveFilterWidth,
                    f = p - 1 - r.padInfo.left,
                    u = c - 1 - r.padInfo.top,
                    m = t.buffer(s.shape, "float32"),
                    y = 1 / (i * l),
                    g = this.bufferSync(e);
                for (let t = 0; t < r.batchSize; ++t)
                    for (let e = 0; e < r.inChannels; ++e)
                        for (let a = 0; a < r.inHeight; ++a)
                            for (let s = 0; s < r.inWidth; ++s) {
                                const i = a - u,
                                    l = s - f;
                                let x = 0;
                                for (let a = 0; a < c; a += d) {
                                    const s = (i + a) / o;
                                    if (!(s < 0 || s >= r.outHeight || Math.floor(s) !== s))
                                        for (let a = 0; a < p; a += h) {
                                            const o = (l + a) / n;
                                            o < 0 || o >= r.outWidth || Math.floor(o) !== o || (x += g.get(t, s, o, e))
                                        }
                                }
                                m.set(x * y, t, a, s, e)
                            }
                return m.toTensor()
            }
            pool3d(e, s, r) {
                (0, a.assertNotComplex)(e, "pool3d");
                const o = s.strideDepth,
                    n = s.strideHeight,
                    i = s.strideWidth,
                    l = s.dilationDepth,
                    d = s.dilationHeight,
                    h = s.dilationWidth,
                    c = s.effectiveFilterDepth,
                    p = s.effectiveFilterHeight,
                    f = s.effectiveFilterWidth,
                    u = s.padInfo.front,
                    m = s.padInfo.top,
                    y = s.padInfo.left,
                    g = "max" === r ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                    x = this.readSync(e.dataId),
                    S = t.buffer(s.outShape, e.dtype),
                    I = S.values,
                    b = s.outShape[1] * s.outShape[2] * s.outShape[3] * s.outShape[4],
                    M = s.outShape[2] * s.outShape[3] * s.outShape[4],
                    k = s.outShape[3] * s.outShape[4],
                    C = s.outShape[4];
                for (let t = 0; t < s.batchSize; ++t) {
                    const a = t * b,
                        S = t * e.strides[0];
                    for (let t = 0; t < s.inChannels; ++t)
                        for (let b = 0; b < s.outDepth; ++b) {
                            const N = b * o - u;
                            let v = N;
                            for (; v < 0;) v += l;
                            const A = Math.min(s.inDepth, c + N),
                                w = a + b * M;
                            for (let a = 0; a < s.outHeight; ++a) {
                                const o = a * n - m;
                                let c = o;
                                for (; c < 0;) c += d;
                                const u = Math.min(s.inHeight, p + o),
                                    b = w + a * k;
                                for (let a = 0; a < s.outWidth; ++a) {
                                    const o = a * i - y;
                                    let n = o;
                                    for (; n < 0;) n += h;
                                    const p = Math.min(s.inWidth, f + o),
                                        m = b + a * C;
                                    let M = g,
                                        k = 0,
                                        N = 0;
                                    for (let a = v; a < A; a += l) {
                                        const s = S + a * e.strides[1];
                                        for (let a = c; a < u; a += d) {
                                            const o = s + a * e.strides[2];
                                            for (let a = n; a < p; a += h) {
                                                const s = x[o + a * e.strides[3] + t];
                                                if ("max" === r && s > M ? M = s : "avg" === r && (k += s, N++), isNaN(M)) break
                                            }
                                            if (isNaN(M)) break
                                        }
                                        if (isNaN(M)) break
                                    }
                                    I[m + t] = "avg" === r ? k / N : M
                                }
                            }
                        }
                }
                return S.toTensor()
            }
            avgPool3d(t, e) {
                return (0, a.assertNotComplex)(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat()
            }
            avgPool3dBackprop(e, s, r) {
                (0, a.assertNotComplex)([e, s], "avgPool3dBackprop");
                const o = r.strideDepth,
                    n = r.strideHeight,
                    i = r.strideWidth,
                    l = r.filterDepth,
                    d = r.filterHeight,
                    h = r.filterWidth,
                    c = r.dilationDepth,
                    p = r.dilationHeight,
                    f = r.dilationWidth,
                    u = r.effectiveFilterDepth,
                    m = r.effectiveFilterHeight,
                    y = r.effectiveFilterWidth,
                    g = u - 1 - r.padInfo.front,
                    x = y - 1 - r.padInfo.left,
                    S = m - 1 - r.padInfo.top,
                    I = t.buffer(s.shape, "float32"),
                    b = 1 / (l * d * h),
                    M = this.bufferSync(e);
                for (let t = 0; t < r.batchSize; ++t)
                    for (let e = 0; e < r.inChannels; ++e)
                        for (let a = 0; a < r.inDepth; ++a)
                            for (let s = 0; s < r.inHeight; ++s)
                                for (let l = 0; l < r.inWidth; ++l) {
                                    const d = a - g,
                                        h = s - S,
                                        k = l - x;
                                    let C = 0;
                                    for (let a = 0; a < u; a += c) {
                                        const s = (d + a) / o;
                                        if (!(s < 0 || s >= r.outDepth || Math.floor(s) !== s))
                                            for (let a = 0; a < m; a += p) {
                                                const o = (h + a) / n;
                                                if (!(o < 0 || o >= r.outHeight || Math.floor(o) !== o))
                                                    for (let a = 0; a < y; a += f) {
                                                        const n = (k + a) / i;
                                                        n < 0 || n >= r.outWidth || Math.floor(n) !== n || (C += M.get(t, s, o, n, e))
                                                    }
                                            }
                                    }
                                    I.set(C * b, t, a, s, l, e)
                                }
                return I.toTensor()
            }
            maxPool3d(t, e) {
                return (0, a.assertNotComplex)(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat()
            }
            maxPool3dPositions(e, a) {
                const s = t.buffer(a.outShape, "int32"),
                    r = a.strideDepth,
                    o = a.strideHeight,
                    n = a.strideWidth,
                    i = a.dilationDepth,
                    l = a.dilationHeight,
                    d = a.dilationWidth,
                    h = a.effectiveFilterDepth,
                    c = a.effectiveFilterHeight,
                    p = a.effectiveFilterWidth,
                    f = a.padInfo.front,
                    u = a.padInfo.top,
                    m = a.padInfo.left,
                    y = this.bufferSync(e);
                for (let t = 0; t < a.batchSize; ++t)
                    for (let e = 0; e < a.inChannels; ++e)
                        for (let g = 0; g < a.outDepth; ++g) {
                            const x = g * r - f;
                            let S = x;
                            for (; S < 0;) S += i;
                            const I = Math.min(a.inDepth, h + x);
                            for (let r = 0; r < a.outHeight; ++r) {
                                const h = r * o - u;
                                let f = h;
                                for (; f < 0;) f += l;
                                const b = Math.min(a.inHeight, c + h);
                                for (let o = 0; o < a.outWidth; ++o) {
                                    const u = o * n - m;
                                    let M = u;
                                    for (; M < 0;) M += d;
                                    const k = Math.min(a.inWidth, p + u);
                                    let C = Number.NEGATIVE_INFINITY,
                                        N = -1;
                                    for (let a = S; a < I; a += i) {
                                        const s = a - x;
                                        for (let r = f; r < b; r += l) {
                                            const o = r - h;
                                            for (let n = M; n < k; n += d) {
                                                const i = n - u,
                                                    l = y.get(t, a, r, n, e);
                                                l >= C && (C = l, N = s * c * p + o * c + i)
                                            }
                                        }
                                    }
                                    s.set(N, t, g, r, o, e)
                                }
                            }
                        }
                return s.toTensor()
            }
            maxPool3dBackprop(e, s, r, o) {
                (0, a.assertNotComplex)([s, r], "maxPool3dBackprop");
                const n = this.maxPool3dPositions(s, o),
                    i = o.strideDepth,
                    l = o.strideHeight,
                    d = o.strideWidth,
                    h = o.dilationDepth,
                    c = o.dilationHeight,
                    p = o.dilationWidth,
                    f = o.effectiveFilterDepth,
                    u = o.effectiveFilterHeight,
                    m = o.effectiveFilterWidth,
                    y = f - 1 - o.padInfo.front,
                    g = m - 1 - o.padInfo.left,
                    x = u - 1 - o.padInfo.top,
                    S = t.buffer(s.shape, "float32"),
                    I = this.bufferSync(n),
                    b = this.bufferSync(e);
                for (let t = 0; t < o.batchSize; ++t)
                    for (let e = 0; e < o.inChannels; ++e)
                        for (let a = 0; a < o.inDepth; ++a)
                            for (let s = 0; s < o.inHeight; ++s)
                                for (let r = 0; r < o.inWidth; ++r) {
                                    const n = a - y,
                                        M = s - x,
                                        k = r - g;
                                    let C = 0;
                                    for (let a = 0; a < f; a += h) {
                                        const s = (n + a) / i;
                                        if (!(s < 0 || s >= o.outDepth || Math.floor(s) !== s))
                                            for (let r = 0; r < u; r += c) {
                                                const n = (M + r) / l;
                                                if (!(n < 0 || n >= o.outHeight || Math.floor(n) !== n))
                                                    for (let i = 0; i < m; i += p) {
                                                        const l = (k + i) / d;
                                                        if (l < 0 || l >= o.outWidth || Math.floor(l) !== l) continue;
                                                        const h = f * u * m - 1 - I.get(t, s, n, l, e) === a * u * m + r * m + i ? 1 : 0;
                                                        0 !== h && (C += b.get(t, s, n, l, e) * h)
                                                    }
                                            }
                                    }
                                    S.set(C, t, a, s, r, e)
                                }
                return S.toTensor()
            }
            cast(e, a) {
                return t.backend_util.castTensor(e, a, this)
            }
            reshape(e, a) {
                return t.backend_util.reshapeTensor(e, a)
            }
            avgPool(t, e) {
                (0, a.assertNotComplex)(t, "avgPool"), (0, a.assertNotComplex)(t, "maxPool");
                const r = this.readSync(t.dataId);
                return (0, s.pool)(r, t.shape, t.dtype, t.strides, e, "avg").toTensor().toFloat()
            }
            resizeBilinear(e, s, r, o) {
                (0, a.assertNotComplex)(e, "resizeBilinear");
                const [n, i, l, d] = e.shape, h = this.readSync(e.dataId), c = new Float32Array(t.util.sizeFromShape([n, s, r, d])), p = [o && s > 1 ? i - 1 : i, o && r > 1 ? l - 1 : l], f = [o && s > 1 ? s - 1 : s, o && r > 1 ? r - 1 : r];
                let u = 0;
                const m = p[0] / f[0],
                    y = p[1] / f[1];
                for (let t = 0; t < n; t++)
                    for (let a = 0; a < s; a++) {
                        const s = m * a,
                            o = Math.floor(s),
                            n = s - o,
                            p = Math.min(i - 1, Math.ceil(s)),
                            f = t * e.strides[0] + o * e.strides[1],
                            g = t * e.strides[0] + p * e.strides[1];
                        for (let t = 0; t < r; t++) {
                            const a = y * t,
                                s = Math.floor(a),
                                r = a - s,
                                o = Math.min(l - 1, Math.ceil(a)),
                                i = f + s * e.strides[2],
                                p = g + s * e.strides[2],
                                m = f + o * e.strides[2],
                                x = g + o * e.strides[2];
                            for (let t = 0; t < d; t++) {
                                const e = h[i + t],
                                    a = h[p + t],
                                    s = e + (h[m + t] - e) * r,
                                    o = s + (a + (h[x + t] - a) * r - s) * n;
                                c[u++] = o
                            }
                        }
                    }
                return t.tensor(c, [n, s, r, d])
            }
            resizeBilinearBackprop(e, s, r) {
                (0, a.assertNotComplex)([e, s], "resizeBilinearBackprop");
                const [o, n, i, l] = s.shape, [, d, h] = e.shape, c = new Float32Array(o * n * i * l), p = [r && d > 1 ? n - 1 : n, r && h > 1 ? i - 1 : i], f = [r && d > 1 ? d - 1 : d, r && h > 1 ? h - 1 : h], u = p[0] / f[0], m = p[1] / f[1], y = this.readSync(e.dataId);
                let g = 0;
                for (let t = 0; t < o; t++) {
                    const e = t * s.strides[0];
                    for (let t = 0; t < d; t++) {
                        const a = t * u,
                            r = Math.floor(a),
                            o = Math.min(Math.ceil(a), n - 1),
                            d = e + r * s.strides[1],
                            p = e + o * s.strides[1],
                            f = a - r,
                            x = 1 - f;
                        for (let t = 0; t < h; t++) {
                            const e = t * m,
                                a = Math.floor(e),
                                r = Math.min(Math.ceil(e), i - 1),
                                o = e - a,
                                n = 1 - o,
                                h = d + a * s.strides[2],
                                u = d + r * s.strides[2],
                                S = p + a * s.strides[2],
                                I = p + r * s.strides[2],
                                b = x * n,
                                M = x * o,
                                k = f * n,
                                C = f * o;
                            for (let t = 0; t < l; t++) {
                                const e = y[g++];
                                c[h + t] += e * b, c[u + t] += e * M, c[S + t] += e * k, c[I + t] += e * C
                            }
                        }
                    }
                }
                return t.tensor4d(c, [o, i, n, l], s.dtype)
            }
            resizeNearestNeighbor(e, s, r, o) {
                (0, a.assertNotComplex)(e, "resizeNearestNeighbor");
                const [n, i, l, d] = e.shape, h = this.readSync(e.dataId), c = new Float32Array(n * s * r * d), p = [o && s > 1 ? i - 1 : i, o && r > 1 ? l - 1 : l], f = [o && s > 1 ? s - 1 : s, o && r > 1 ? r - 1 : r], u = p[0] / f[0], m = p[1] / f[1];
                let y = 0;
                for (let t = 0; t < n; t++) {
                    const a = t * e.strides[0];
                    for (let t = 0; t < s; t++) {
                        const s = u * t,
                            n = a + Math.min(i - 1, o ? Math.round(s) : Math.floor(s)) * e.strides[1];
                        for (let t = 0; t < r; t++) {
                            const a = m * t,
                                s = n + Math.min(l - 1, o ? Math.round(a) : Math.floor(a)) * e.strides[2];
                            for (let t = 0; t < d; t++) {
                                const e = h[s + t];
                                c[y++] = e
                            }
                        }
                    }
                }
                return t.tensor(c, [n, s, r, d], e.dtype)
            }
            resizeNearestNeighborBackprop(e, s, r) {
                (0, a.assertNotComplex)([e, s], "resizeNearestNeighborBackprop");
                const [o, n, i, l] = s.shape, [, d, h] = e.shape, c = new Float32Array(o * n * i * l), p = this.readSync(e.dataId), f = [r && d > 1 ? n - 1 : n, r && h > 1 ? i - 1 : i], u = [r && d > 1 ? d - 1 : d, r && h > 1 ? h - 1 : h], m = f[0] / u[0], y = f[1] / u[1], g = 1 / m, x = 1 / y, S = 2 * Math.ceil(g) + 2, I = 2 * Math.ceil(x) + 2;
                for (let t = 0; t < o; t++) {
                    const a = t * s.strides[0];
                    for (let t = 0; t < n; t++) {
                        const o = a + t * s.strides[1],
                            f = Math.floor(t * g),
                            u = Math.floor(f - S / 2);
                        for (let g = 0; g < i; g++) {
                            const f = o + g * s.strides[2],
                                b = Math.floor(g * x),
                                M = Math.floor(b - I / 2);
                            for (let s = 0; s < l; s++) {
                                let o = 0;
                                for (let l = 0; l < S; l++) {
                                    const c = l + u;
                                    if (c < 0 || c >= d) continue;
                                    const f = a + c * e.strides[1],
                                        x = c * m;
                                    if (t === Math.min(n - 1, r ? Math.round(x) : Math.floor(x)))
                                        for (let t = 0; t < I; t++) {
                                            const a = t + M;
                                            if (a < 0 || a >= h) continue;
                                            const n = f + a * e.strides[2],
                                                l = a * y;
                                            g === Math.min(i - 1, r ? Math.round(l) : Math.floor(l)) && (o += p[n + s])
                                        }
                                }
                                c[f + s] = o
                            }
                        }
                    }
                }
                return t.tensor4d(c, s.shape, s.dtype)
            }
            batchNorm(e, s, r, o, n, i) {
                (0, a.assertNotComplex)([e, s, r, n, o], "batchNorm");
                const l = this.readSync(e.dataId),
                    d = this.readSync(s.dataId),
                    h = this.readSync(r.dataId),
                    c = n ? this.readSync(n.dataId) : new Float32Array([1]),
                    p = o ? this.readSync(o.dataId) : new Float32Array([0]),
                    f = new Float32Array(l.length),
                    u = p.length,
                    m = c.length,
                    y = h.length,
                    g = d.length;
                let x = 0,
                    S = 0,
                    I = 0,
                    b = 0;
                for (let t = 0; t < l.length; ++t) f[t] = p[x++] + (l[t] - d[S++]) * c[I++] / Math.sqrt(h[b++] + i), x >= u && (x = 0), S >= g && (S = 0), I >= m && (I = 0), b >= y && (b = 0);
                return t.tensor4d(f, e.shape)
            }
            localResponseNormalization4D(e, s, r, o, n) {
                (0, a.assertNotComplex)(e, "localResponseNormalization4D");
                const i = e.shape[3],
                    l = i - 1,
                    d = this.readSync(e.dataId),
                    h = e.size,
                    c = new Float32Array(h);

                function p(t) {
                    const e = t % i;
                    let a = t - e + Math.max(0, e - s);
                    const r = t - e + Math.min(e + s, l);
                    let o = 0;
                    for (; a <= r; a++) {
                        const t = d[a];
                        o += t * t
                    }
                    return o
                }
                for (let t = 0; t < h; t++) {
                    const e = p(t),
                        a = d[t] * Math.pow(r + o * e, -n);
                    c[t] = a
                }
                return t.tensor4d(c, e.shape)
            }
            LRNGrad(e, s, r, o, n, i, l) {
                (0, a.assertNotComplex)(e, "LRNGrad");
                const d = e.shape[3],
                    h = this.readSync(e.dataId),
                    c = this.readSync(s.dataId),
                    p = this.readSync(r.dataId),
                    f = new Float32Array(e.size),
                    u = e.size;
                for (let t = 0; t < u; t++) {
                    const e = t % d,
                        a = t - e + Math.max(0, e - o),
                        s = t - e + Math.min(d, e + o + 1);
                    let r = 0;
                    for (let t = a; t < s; t++) r += Math.pow(c[t], 2);
                    r = i * r + n;
                    for (let o = a; o < s; o++) {
                        let e = -2 * i * l * c[o] * p[t] / r;
                        t === o && (e += Math.pow(r, -l)), e *= h[t], f[o] += e
                    }
                }
                return t.tensor4d(f, e.shape)
            }
            multinomial(s, r, o, n) {
                (0, a.assertNotComplex)(s, "multinomial");
                const i = r ? s : t.softmax(s),
                    l = i.shape[0],
                    d = i.shape[1],
                    h = t.zeros([l, o], "int32"),
                    c = this.readSync(h.dataId),
                    p = this.readSync(i.dataId);
                for (let t = 0; t < l; ++t) {
                    const a = t * d,
                        s = new Float32Array(d - 1);
                    s[0] = p[a];
                    for (let t = 1; t < s.length; ++t) s[t] = s[t - 1] + p[a + t];
                    const r = e.alea(n.toString()),
                        i = t * o;
                    for (let t = 0; t < o; ++t) {
                        const e = r();
                        c[i + t] = s.length;
                        for (let a = 0; a < s.length; a++)
                            if (e < s[a]) {
                                c[i + t] = a;
                                break
                            }
                    }
                }
                return h
            }
            oneHot(e, s, r, o) {
                (0, a.assertNotComplex)(e, "oneHot");
                const n = new Float32Array(e.size * s);
                n.fill(o);
                const i = this.readSync(e.dataId);
                for (let t = 0; t < e.size; ++t) i[t] >= 0 && i[t] < s && (n[t * s + i[t]] = r);
                return t.tensor2d(n, [e.size, s], "int32")
            }
            nonMaxSuppression(t, e, s, r, o) {
                (0, a.assertNotComplex)(t, "nonMaxSuppression");
                const i = this.readSync(t.dataId),
                    l = this.readSync(e.dataId);
                return n(i, l, s, r, o)
            }
            fft(t) {
                return this.fftBatch(t, !1)
            }
            ifft(t) {
                return this.fftBatch(t, !0)
            }
            fftBatch(e, a) {
                const s = e.shape[0],
                    r = e.shape[1],
                    o = t.buffer(e.shape, "float32"),
                    n = t.buffer(e.shape, "float32"),
                    i = t.real(e).as2D(s, r),
                    l = t.imag(e).as2D(s, r);
                for (let d = 0; d < s; d++) {
                    const e = i.slice([d, 0], [1, r]),
                        s = l.slice([d, 0], [1, r]),
                        h = t.complex(e, s),
                        c = this.readSync(this.fftImpl(h, a).dataId);
                    for (let a = 0; a < r; a++) {
                        const e = t.backend_util.getComplexWithIndex(c, a);
                        o.values[d * r + a] = e.real, n.values[d * r + a] = e.imag
                    }
                }
                return t.complex(o.toTensor(), n.toTensor()).as2D(s, r)
            }
            fftImpl(e, a) {
                const s = e.as1D(),
                    r = s.size;
                if (this.isExponentOf2(r)) {
                    let o = this.fftRadix2(s, r, a).as2D(e.shape[0], e.shape[1]);
                    return a && (o = t.complex(t.real(o).div(t.scalar(r)), t.imag(o).div(t.scalar(r)))), o
                } {
                    const s = this.readSync(e.dataId),
                        o = this.fourierTransformByMatmul(s, r, a),
                        n = t.backend_util.splitRealAndImagArrays(o);
                    return t.complex(n.real, n.imag).as2D(e.shape[0], e.shape[1])
                }
            }
            isExponentOf2(t) {
                return 0 == (t & t - 1)
            }
            fftRadix2(e, a, s) {
                if (1 === a) return e;
                const r = this.readSync(e.dataId),
                    o = a / 2,
                    n = t.backend_util.complexWithEvenIndex(r);
                let i = t.complex(n.real, n.imag).as1D();
                const l = t.backend_util.complexWithOddIndex(r);
                let d = t.complex(l.real, l.imag).as1D();
                i = this.fftRadix2(i, o, s), d = this.fftRadix2(d, o, s);
                const h = t.backend_util.exponents(a, s),
                    c = t.complex(h.real, h.imag).mul(d),
                    p = i.add(c),
                    f = i.sub(c),
                    u = t.real(p).concat(t.real(f)),
                    m = t.imag(p).concat(t.imag(f));
                return t.complex(u, m).as1D()
            }
            fourierTransformByMatmul(e, a, s) {
                const r = new Float32Array(2 * a);
                for (let o = 0; o < a; o++) {
                    let n = 0,
                        i = 0;
                    for (let r = 0; r < a; r++) {
                        const l = t.backend_util.exponent(o * r, a, s),
                            d = t.backend_util.getComplexWithIndex(e, r);
                        n += d.real * l.real - d.imag * l.imag, i += d.real * l.imag + d.imag * l.real
                    }
                    s && (n /= a, i /= a), t.backend_util.assignToTypedArray(r, n, i, o)
                }
                return r
            }
            depthToSpace(e, a, s) {
                t.util.assert("NHWC" === s, () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`), t.util.assert(a > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${a}`);
                const r = e.shape[0],
                    o = e.shape[1],
                    n = e.shape[2],
                    i = e.shape[3],
                    l = o * a,
                    d = n * a,
                    h = i / (a * a),
                    c = this.readSync(e.dataId),
                    p = new Float32Array(r * l * d * h);
                let f = 0;
                for (let t = 0; t < r; ++t)
                    for (let e = 0; e < l; ++e) {
                        const s = Math.floor(e / a),
                            r = e % a;
                        for (let e = 0; e < d; ++e) {
                            const l = Math.floor(e / a),
                                d = (r * a + e % a) * h;
                            for (let e = 0; e < h; ++e) {
                                const a = e + d + i * (l + n * (s + o * t));
                                p[f++] = c[a]
                            }
                        }
                    }
                return t.tensor4d(p, [r, l, d, h])
            }
            broadcastedBinaryOp(e, a, s, r) {
                const o = t.backend_util.assertAndGetBroadcastShape(e.shape, a.shape),
                    n = t.buffer(o, s),
                    i = this.readSync(e.dataId),
                    l = this.readSync(a.dataId),
                    d = t.backend_util.getBroadcastDims(e.shape, o),
                    h = t.backend_util.getBroadcastDims(a.shape, o),
                    c = n.values;
                if (d.length + h.length === 0)
                    for (let t = 0; t < c.length; ++t) c[t] = r(i[t % i.length], l[t % l.length]);
                else {
                    const t = this.bufferSync(e),
                        s = this.bufferSync(a);
                    for (let o = 0; o < c.length; ++o) {
                        const p = n.indexToLoc(o),
                            f = p.slice(-e.rank);
                        d.forEach(t => f[t] = 0);
                        const u = t.locToIndex(f),
                            m = p.slice(-a.rank);
                        h.forEach(t => m[t] = 0);
                        const y = s.locToIndex(m);
                        c[o] = r(i[u], l[y])
                    }
                }
                return n.toTensor()
            }
            broadcastedBinaryComplexOp(e, a, s) {
                const r = t.backend_util.assertAndGetBroadcastShape(e.shape, a.shape),
                    o = t.buffer(r, "float32"),
                    n = t.buffer(r, "float32"),
                    i = this.readSync(e.dataId),
                    l = this.readSync(a.dataId),
                    d = t.backend_util.getBroadcastDims(e.shape, r),
                    h = t.backend_util.getBroadcastDims(a.shape, r),
                    c = o.values,
                    p = n.values;
                if (d.length + h.length === 0)
                    for (let t = 0; t < c.length; t++) {
                        const e = t % i.length,
                            a = t % l.length,
                            r = s(i[2 * e], i[2 * e + 1], l[2 * a], l[2 * a + 1]);
                        c[t] = r.real, p[t] = r.imag
                    } else {
                        const t = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
                            r = this.bufferSync(this.data.get(a.dataId).complexTensors.real);
                        for (let n = 0; n < c.length; n++) {
                            const f = o.indexToLoc(n),
                                u = f.slice(-e.rank);
                            d.forEach(t => u[t] = 0);
                            const m = t.locToIndex(u),
                                y = f.slice(-a.rank);
                            h.forEach(t => y[t] = 0);
                            const g = r.locToIndex(y),
                                x = s(i[2 * m], i[2 * m + 1], l[2 * g], l[2 * g + 1]);
                            c[n] = x.real, p[n] = x.imag
                        }
                    }
                return this.complex(o.toTensor(), n.toTensor())
            }
            split(t, e, a) {
                return i(t, e, a)
            }
            dispose() {}
            floatPrecision() {
                return 32
            }
            epsilon() {
                return super.epsilon()
            }
            cropAndResize(e, a, s, r, o, n) {
                const [i, l, d, h] = e.shape, c = a.shape[0], [p, f] = r, u = t.buffer([c, p, f, h], "float32"), m = this.readSync(a.dataId), y = this.readSync(s.dataId), g = this.readSync(e.dataId), x = e.strides, S = u.strides;
                for (let t = 0; t < c; t++) {
                    const e = 4 * t,
                        a = m[e],
                        s = m[e + 1],
                        r = m[e + 2],
                        c = m[e + 3],
                        I = y[t];
                    if (I >= i) continue;
                    const b = p > 1 ? (r - a) * (l - 1) / (p - 1) : 0,
                        M = f > 1 ? (c - s) * (d - 1) / (f - 1) : 0;
                    for (let i = 0; i < p; i++) {
                        const e = p > 1 ? a * (l - 1) + i * b : .5 * (a + r) * (l - 1);
                        if (e < 0 || e > l - 1)
                            for (let a = 0; a < f; a++)
                                for (let e = 0; e < h; e++) {
                                    const s = e + a * S[2] + i * S[1] + t * S[0];
                                    u.values[s] = n
                                } else if ("bilinear" === o) {
                                    const a = Math.floor(e),
                                        r = Math.ceil(e),
                                        o = e - a;
                                    for (let e = 0; e < f; e++) {
                                        const l = f > 1 ? s * (d - 1) + e * M : .5 * (s + c) * (d - 1);
                                        if (l < 0 || l > d - 1) {
                                            for (let a = 0; a < h; a++) {
                                                const s = a + e * S[2] + i * S[1] + t * S[0];
                                                u.values[s] = n
                                            }
                                            continue
                                        }
                                        const p = Math.floor(l),
                                            m = Math.ceil(l),
                                            y = l - p;
                                        for (let s = 0; s < h; s++) {
                                            let n = s + p * x[2] + a * x[1] + I * x[0];
                                            const l = g[n],
                                                d = g[n = s + m * x[2] + a * x[1] + I * x[0]],
                                                h = g[n = s + p * x[2] + r * x[1] + I * x[0]],
                                                c = l + (d - l) * y,
                                                f = h + (g[n = s + m * x[2] + r * x[1] + I * x[0]] - h) * y;
                                            n = s + e * S[2] + i * S[1] + t * S[0], u.values[n] = c + (f - c) * o
                                        }
                                    }
                                } else
                                    for (let a = 0; a < f; ++a) {
                                        const r = f > 1 ? s * (d - 1) + a * M : .5 * (s + c) * (d - 1);
                                        if (r < 0 || r > d - 1) {
                                            for (let e = 0; e < h; e++) {
                                                const s = e + a * S[2] + i * S[1] + t * S[0];
                                                u.values[s] = n
                                            }
                                            continue
                                        }
                                        const o = Math.round(r),
                                            l = Math.round(e);
                                        for (let e = 0; e < h; e++) {
                                            const s = e + o * x[2] + l * x[1] + I * x[0],
                                                r = e + a * S[2] + i * S[1] + t * S[0];
                                            u.values[r] = g[s]
                                        }
                                    }
                    }
                }
                return u.toTensor()
            }
            sparseToDense(e, a, s, r) {
                const {
                    sliceRank: o,
                    numUpdates: n,
                    sliceSize: i,
                    strides: l,
                    outputSize: d
                } = t.backend_util.calculateShapes(a, e, s);
                return this.scatter(e, a, s, d, i, n, o, l, r, !1)
            }
            gatherND(e, a) {
                const s = a.shape,
                    r = s[s.length - 1],
                    [o, n, i, l] = t.backend_util.prepareAndValidate(e, a);
                if (0 === n) return t.tensor([], o, e.dtype);
                const d = new t.TensorBuffer([n, i], e.dtype),
                    h = this.readSync(a.dataId),
                    c = this.readSync(e.dataId);
                for (let t = 0; t < n; t++) {
                    const a = [];
                    let s = 0;
                    for (let e = 0; e < r; e++) {
                        const o = h[t * r + e];
                        s += o * l[e], a.push(o)
                    }
                    if (s < 0 || s >= e.size / i) throw new Error(`Invalid indices: ${a} does not index into ${e.shape}`);
                    for (let e = 0; e < i; e++) d.values[t * i + e] = c[s * i + e]
                }
                return d.toTensor().reshape(o)
            }
            scatterND(e, a, s) {
                const {
                    sliceRank: r,
                    numUpdates: o,
                    sliceSize: n,
                    strides: i,
                    outputSize: l
                } = t.backend_util.calculateShapes(a, e, s), d = t.scalar(0);
                return this.scatter(e, a, s, l, n, o, r, i, d, !0)
            }
            fill(e, a, s) {
                s = s || t.util.inferDtype(a);
                const r = t.util.getArrayFromDType(s, t.util.sizeFromShape(e));
                return r.fill(a), (0, t.engine)().makeTensor(r, e, s, this)
            }
            onesLike(t) {
                if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
                return this.fill(t.shape, 1, t.dtype)
            }
            zerosLike(e) {
                const a = t.util.getArrayFromDType(e.dtype, t.util.sizeFromShape(e.shape));
                return this.makeOutput(a, e.shape, e.dtype)
            }
            linspace(e, a, s) {
                return t.backend_util.linspaceImpl(e, a, s)
            }
            scatter(e, a, s, r, o, n, i, l, d, h) {
                const c = [r / o, o],
                    p = this.readSync(e.dataId),
                    f = this.readSync(a.dataId);
                if (0 === r) return t.tensor([], s, a.dtype);
                const u = new t.TensorBuffer(c, a.dtype);
                u.values.fill(this.readSync(d.dataId)[0]);
                for (let t = 0; t < n; t++) {
                    const e = [];
                    let n = 0;
                    for (let a = 0; a < i; a++) {
                        const s = p[t * i + a];
                        e.push(s), n += s * l[a]
                    }
                    if (n < 0 || n >= r / o) throw new Error(`Invalid indices: ${e} does not index into ${s}`);
                    for (let s = 0; s < o; s++) h ? u.values[n * o + s] += f[t * o + s] : u.values[n * o + s] = 0 === a.rank ? f[0] : f[t * o + s]
                }
                return u.toTensor().reshape(s)
            }
        }
        exports.MathBackendCPU = p;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "seedrandom": "Kwju",
        "./cpu_util": "y22L",
        "./utils/pool_utils": "ZDaf"
    }],
    "W0Bm": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "MathBackendCPU", {
            enumerable: !0,
            get: function() {
                return r.MathBackendCPU
            }
        }), Object.defineProperty(exports, "version_cpu", {
            enumerable: !0,
            get: function() {
                return t.version
            }
        }), exports.shared = void 0;
        var e = o(require("./shared"));
        exports.shared = e;
        var r = require("./backend_cpu"),
            t = require("./version");

        function n() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return n = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var r = n();
            if (r && r.has(e)) return r.get(e);
            var t = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var u in e)
                if (Object.prototype.hasOwnProperty.call(e, u)) {
                    var i = o ? Object.getOwnPropertyDescriptor(e, u) : null;
                    i && (i.get || i.set) ? Object.defineProperty(t, u, i) : t[u] = e[u]
                } return t.default = e, r && r.set(e, t), t
        }
    }, {
        "./shared": "X8ov",
        "./backend_cpu": "cLLj",
        "./version": "SdA6"
    }],
    "tfp0": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transposeImplCPU = exports.maxImplCPU = void 0;
        var e = require("@tensorflow/tfjs-backend-cpu/dist/base");
        const {
            maxImpl: s,
            transposeImpl: p
        } = e.shared;
        exports.transposeImplCPU = p, exports.maxImplCPU = s;
    }, {
        "@tensorflow/tfjs-backend-cpu/dist/base": "W0Bm"
    }],
    "rKxH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reduce = t;
        var e = require("@tensorflow/tfjs-core"),
            r = require("../reduce_gpu");

        function t(i, o, u, n) {
            const [c, s] = i.shape, a = {
                windowSize: e.backend_util.computeOptimalWindowSize(s),
                inSize: s,
                batchSize: c
            }, d = new r.ReduceProgram(a, u), p = n.runWebGLProgram(d, [i], o);
            return 1 === p.shape[1] ? p : t(p, o, u, n)
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../reduce_gpu": "cqVi"
    }],
    "hfnj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reshape = d;
        var e = require("../reshape_packed_gpu"),
            t = require("../webgl_util");

        function a(a, d, s) {
            const p = [(0, t.getBatchDim)(a.shape), ...(0, t.getRowsCols)(a.shape)],
                r = {
                    dtype: a.dtype,
                    shape: p,
                    dataId: a.dataId
                },
                u = [(0, t.getBatchDim)(d), ...(0, t.getRowsCols)(d)],
                h = new e.ReshapePackedProgram(u, p),
                o = s.runWebGLProgram(h, [r], a.dtype, null, !0);
            return {
                dataId: o.dataId,
                shape: d,
                dtype: o.dtype
            }
        }

        function d(e, d, s) {
            const p = s.texData.get(e.dataId);
            return !p.isPacked || (0, t.isReshapeFree)(e.shape, d) || null !== p.texture && (0, t.isReshapeFree)(p.shape, d) ? {
                dataId: e.dataId,
                shape: d,
                dtype: e.dtype
            } : a(e, d, s)
        }
    }, {
        "../reshape_packed_gpu": "K4kf",
        "../webgl_util": "p3g2"
    }],
    "mDKU": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxImpl = a;
        var e = require("@tensorflow/tfjs-core"),
            r = require("../kernel_utils/reduce"),
            t = require("../kernel_utils/reshape");

        function a(a, s, u, i) {
            const d = e.util.sizeFromShape(s),
                o = e.util.sizeFromShape(a.shape) / d,
                p = (0, t.reshape)(a, [o, d], i),
                l = (0, r.reduce)(p, a.dtype, "max", i);
            return p.dataId !== a.dataId && i.disposeData(p.dataId), (0, t.reshape)(l, u, i)
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../kernel_utils/reduce": "rKxH",
        "../kernel_utils/reshape": "hfnj"
    }],
    "JPQj": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TransposeProgram = void 0;
        var r = require("./shader_compiler");
        class e {
            constructor(e, s) {
                this.variableNames = ["A"];
                const o = new Array(e.length);
                for (let r = 0; r < o.length; r++) o[r] = e[s[r]];
                this.outputShape = o, this.rank = o.length;
                const n = (0, r.getCoordsDataType)(this.rank),
                    a = t(s);
                this.userCode = `\n    void main() {\n      ${n} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `
            }
        }

        function t(r) {
            const e = r.length;
            if (e > 6) throw Error(`Transpose for rank ${e} is not yet supported`);
            const t = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
                s = new Array(e);
            for (let o = 0; o < r.length; o++) s[r[o]] = t[o];
            return s.join()
        }
        exports.TransposeProgram = e;
    }, {
        "./shader_compiler": "DIKY"
    }],
    "TCui": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TransposePackedProgram = void 0;
        var t = require("./packing_util"),
            e = require("./shader_compiler");
        class r {
            constructor(r, n) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
                const s = new Array(r.length);
                for (let t = 0; t < s.length; t++) s[t] = r[n[t]];
                if (this.outputShape = s, this.rank = s.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
                const a = (0, e.getCoordsDataType)(this.rank),
                    i = (0, t.getVecChannels)("rc", this.rank),
                    o = new Array(this.rank);
                for (let t = 0; t < n.length; t++) o[n[t]] = i[t];
                const h = `vec2(${o.slice(-2).join()})`,
                    u = `++${i[this.rank-1]} < ${s[this.rank-1]}`,
                    c = `getChannel(getA(${o.join()}), ${h})`;
                this.userCode = `\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `
            }
        }
        exports.TransposePackedProgram = r;
    }, {
        "./packing_util": "Axn8",
        "./shader_compiler": "DIKY"
    }],
    "nCXe": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transposeImpl = o, Object.defineProperty(exports, "transposeImplCPU", {
            enumerable: !0,
            get: function() {
                return r.transposeImplCPU
            }
        });
        var e = require("@tensorflow/tfjs-core"),
            r = require("../kernel_utils/shared"),
            s = require("../transpose_gpu"),
            t = require("../transpose_packed_gpu");

        function o(r, o, n) {
            const p = (0, e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new t.TransposePackedProgram(r.shape, o) : new s.TransposeProgram(r.shape, o);
            return n.runWebGLProgram(p, [r], r.dtype)
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../kernel_utils/shared": "tfp0",
        "../transpose_gpu": "JPQj",
        "../transpose_packed_gpu": "TCui"
    }],
    "SOPS": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("../kernel_utils/shared"),
            a = require("./Max_impl"),
            s = require("./Transpose_impl");
        const n = {
            kernelName: e.Max,
            backendName: "webgl",
            kernelFunc: ({
                inputs: n,
                attrs: r,
                backend: l
            }) => {
                const {
                    x: o
                } = n, {
                    reductionIndices: d,
                    keepDims: i
                } = r, p = l, u = o.shape.length, c = e.util.parseAxisParam(d, o.shape);
                let m = c;
                const x = e.backend_util.getAxesPermutation(m, u),
                    I = null != x,
                    h = p.shouldExecuteOnCPU([o]);
                let k = o;
                if (I) {
                    if (h) {
                        const e = p.texData.get(k.dataId).values,
                            t = new Array(u);
                        for (let s = 0; s < t.length; s++) t[s] = o.shape[x[s]];
                        const a = (0, s.transposeImplCPU)(e, o.shape, o.dtype, x, t);
                        k = p.makeTensorInfo(t, o.dtype), p.texData.get(k.dataId).values = a
                    } else k = (0, s.transposeImpl)(o, x, p);
                    m = e.backend_util.getInnerMostAxes(m.length, u)
                }
                e.backend_util.assertAxesAreInnerMostDims("max", m, u);
                const [g, f] = e.backend_util.computeOutAndReduceShapes(k.shape, m);
                let _, b = g;
                if (i && (b = e.backend_util.expandShapeToKeepDim(g, c)), h) {
                    const a = p.texData.get(k.dataId).values,
                        s = (0, t.maxImplCPU)(a, e.util.sizeFromShape(f), b, o.dtype);
                    _ = p.makeTensorInfo(b, o.dtype), p.texData.get(_.dataId).values = s
                } else _ = (0, a.maxImpl)(k, f, b, p);
                return I && p.disposeData(k.dataId), _
            }
        };
        exports.maxConfig = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../kernel_utils/shared": "tfp0",
        "./Max_impl": "mDKU",
        "./Transpose_impl": "nCXe"
    }],
    "ujBb": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPoolWithArgmaxImpl = o;
        var r = require("../pool_gpu");

        function o(o, e, t, a) {
            let l = new r.Pool2DProgram(t, "max", !1);
            const m = a.runWebGLProgram(l, [o], "float32");
            return l = new r.Pool2DProgram(t, "max", !0, !0, e), [m, a.runWebGLProgram(l, [o], "float32")]
        }
    }, {
        "../pool_gpu": "DAMt"
    }],
    "yFKv": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.maxPoolWithArgmaxConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./MaxPoolWithArgmax_impl");
        const r = {
            kernelName: e.MaxPoolWithArgmax,
            backendName: "webgl",
            kernelFunc: ({
                inputs: r,
                attrs: o,
                backend: i
            }) => {
                const {
                    x: a
                } = r, {
                    filterSize: n,
                    strides: s,
                    pad: l,
                    includeBatchInIndex: u
                } = o, d = i;
                e.util.assert(4 === a.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);
                const m = [1, 1];
                e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(s, m), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${s} and dilations '${m}'`);
                const x = e.backend_util.computePool2DInfo(a.shape, n, s, m, l),
                    [c, h] = (0, t.maxPoolWithArgmaxImpl)(a, u, x, d);
                return [c, h]
            }
        };
        exports.maxPoolWithArgmaxConfig = r;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./MaxPoolWithArgmax_impl": "ujBb"
    }],
    "GVyX": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionV3Config = void 0;
        var e = require("@tensorflow/tfjs-core");
        const n = {
            kernelName: e.NonMaxSuppressionV3,
            backendName: "webgl",
            kernelFunc: ({
                inputs: n,
                backend: s,
                attrs: o
            }) => {
                e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                const {
                    boxes: r,
                    scores: a
                } = n, {
                    maxOutputSize: t,
                    iouThreshold: p,
                    scoreThreshold: i
                } = o, u = s, d = u.readSync(r.dataId), l = u.readSync(a.dataId), c = t, x = p, S = i;
                return e.kernel_impls.nonMaxSuppressionV3Impl(d, l, c, x, S)
            }
        };
        exports.nonMaxSuppressionV3Config = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "DAkH": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionV4Config = void 0;
        var e = require("@tensorflow/tfjs-core");
        const n = e.kernel_impls.nonMaxSuppressionV4Impl,
            s = {
                kernelName: e.NonMaxSuppressionV4,
                backendName: "webgl",
                kernelFunc: ({
                    inputs: s,
                    backend: o,
                    attrs: r
                }) => {
                    e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                    const {
                        boxes: t,
                        scores: a
                    } = s, {
                        maxOutputSize: p,
                        iouThreshold: i,
                        scoreThreshold: u,
                        padToMaxOutputSize: d
                    } = r, l = o, c = l.readSync(t.dataId), x = l.readSync(a.dataId), {
                        selectedIndices: S,
                        validOutputs: M
                    } = n(c, x, p, i, u, d);
                    return [S, M]
                }
            };
        exports.nonMaxSuppressionV4Config = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "VwrN": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.nonMaxSuppressionV5Config = void 0;
        var e = require("@tensorflow/tfjs-core");
        const s = e.kernel_impls.nonMaxSuppressionV5Impl,
            n = {
                kernelName: e.NonMaxSuppressionV5,
                backendName: "webgl",
                kernelFunc: ({
                    inputs: n,
                    backend: o,
                    attrs: r
                }) => {
                    e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                    const {
                        boxes: t,
                        scores: a
                    } = n, {
                        maxOutputSize: i,
                        iouThreshold: p,
                        scoreThreshold: c,
                        softNmsSigma: d
                    } = r, l = o, u = l.readSync(t.dataId), x = l.readSync(a.dataId), S = i, f = p, b = c, k = d, {
                        selectedIndices: m,
                        selectedScores: M
                    } = s(u, x, S, f, b, k);
                    return [m, M]
                }
            };
        exports.nonMaxSuppressionV5Config = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "MkU1": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.RotateProgram = void 0;
        var o = require("@tensorflow/tfjs-core");
        class t {
            constructor(t, e, r, n) {
                this.variableNames = ["Image"], this.outputShape = [];
                const a = t[1],
                    d = t[2],
                    c = Math.sin(e).toFixed(3),
                    u = Math.cos(e).toFixed(3);
                this.outputShape = t;
                const [i, s] = o.backend_util.getImageCenter(n, a, d), l = i.toFixed(3), f = s.toFixed(3);
                let p = "";
                p = "number" == typeof r ? `float outputValue = ${r.toFixed(2)};` : `\n        vec3 fill = vec3(${r.join(",")});\n        float outputValue = fill[coords[3]];`, this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${l}) * ${u} - (float(y) - ${f}) * ${c};\n          float coordYFloat = (float(x) - ${l}) * ${c} + (float(y) - ${f}) * ${u};\n          int coordX = int(round(coordXFloat + ${l}));\n          int coordY = int(round(coordYFloat + ${f}));\n          ${p}\n          if(coordX >= 0 && coordX < ${d} && coordY >= 0 && coordY < ${a}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `
            }
        }
        exports.RotateProgram = t;
    }, {
        "@tensorflow/tfjs-core": "tc6m"
    }],
    "RJ8j": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rotateWithOffsetConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("../rotate_gpu");
        const r = {
            kernelName: e.RotateWithOffset,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                attrs: r,
                backend: o
            }) => {
                const {
                    image: a
                } = e, {
                    radians: n,
                    fillValue: s,
                    center: i
                } = r, f = o, u = new t.RotateProgram(a.shape, n, s, i);
                return f.runWebGLProgram(u, [a], a.dtype)
            }
        };
        exports.rotateWithOffsetConfig = r;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../rotate_gpu": "MkU1"
    }],
    "aHQY": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squareConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            r = require("../unaryop_gpu");
        const n = {
            kernelName: e.Square,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                backend: n
            }) => {
                const {
                    x: o
                } = e, a = n, s = new r.UnaryOpProgram(o.shape, r.SQUARE);
                return a.runWebGLProgram(s, [o], o.dtype)
            }
        };
        exports.squareConfig = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../unaryop_gpu": "uzBV"
    }],
    "OSij": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.squaredDifferenceConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            r = require("../binaryop_gpu"),
            n = require("../binaryop_packed_gpu");
        const a = {
            kernelName: e.SquaredDifference,
            backendName: "webgl",
            kernelFunc: ({
                inputs: a,
                backend: o
            }) => {
                const {
                    a: i,
                    b: p
                } = a, s = o, u = (0, e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new n.BinaryOpPackedProgram("return (a - b) * (a - b);", i.shape, p.shape) : new r.BinaryOpProgram("return (a - b) * (a - b);", i.shape, p.shape);
                return s.compileAndRun(u, [i, p])
            }
        };
        exports.squaredDifferenceConfig = a;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "../binaryop_gpu": "r3Zb",
        "../binaryop_packed_gpu": "MEci"
    }],
    "hS8R": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.transposeConfig = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = require("./Transpose_impl");
        const s = {
            kernelName: e.Transpose,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                attrs: s,
                backend: r
            }) => {
                const {
                    x: a
                } = e, {
                    perm: n
                } = s, o = r, p = a.shape.length, l = new Array(p);
                for (let t = 0; t < l.length; t++) l[t] = a.shape[n[t]];
                let d;
                if (o.shouldExecuteOnCPU([a])) {
                    const e = o.texData.get(a.dataId).values,
                        s = (0, t.transposeImplCPU)(e, a.shape, a.dtype, n, l);
                    d = o.makeTensorInfo(l, a.dtype), o.texData.get(d.dataId).values = s
                } else d = (0, t.transposeImpl)(a, n, o);
                return d
            }
        };
        exports.transposeConfig = s;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./Transpose_impl": "nCXe"
    }],
    "FAdT": [function(require, module, exports) {
        "use strict";
        var e = require("@tensorflow/tfjs-core"),
            r = require("./kernels/Div"),
            n = require("./kernels/FromPixels"),
            i = require("./kernels/Max"),
            o = require("./kernels/MaxPoolWithArgmax"),
            s = require("./kernels/NonMaxSuppressionV3"),
            f = require("./kernels/NonMaxSuppressionV4"),
            u = require("./kernels/NonMaxSuppressionV5"),
            a = require("./kernels/RotateWithOffset"),
            t = require("./kernels/Square"),
            l = require("./kernels/SquaredDifference"),
            q = require("./kernels/Transpose");
        const g = [i.maxConfig, n.fromPixelsConfig, r.divConfig, o.maxPoolWithArgmaxConfig, s.nonMaxSuppressionV3Config, f.nonMaxSuppressionV4Config, u.nonMaxSuppressionV5Config, a.rotateWithOffsetConfig, t.squareConfig, l.squaredDifferenceConfig, q.transposeConfig];
        for (const p of g)(0, e.registerKernel)(p);
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./kernels/Div": "aEZd",
        "./kernels/FromPixels": "MRz7",
        "./kernels/Max": "SOPS",
        "./kernels/MaxPoolWithArgmax": "yFKv",
        "./kernels/NonMaxSuppressionV3": "GVyX",
        "./kernels/NonMaxSuppressionV4": "DAkH",
        "./kernels/NonMaxSuppressionV5": "VwrN",
        "./kernels/RotateWithOffset": "RJ8j",
        "./kernels/Square": "aHQY",
        "./kernels/SquaredDifference": "OSij",
        "./kernels/Transpose": "hS8R"
    }],
    "BRLE": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.forceHalfFloat = a, Object.defineProperty(exports, "MathBackendWebGL", {
            enumerable: !0,
            get: function() {
                return n.MathBackendWebGL
            }
        }), Object.defineProperty(exports, "setWebGLContext", {
            enumerable: !0,
            get: function() {
                return o.setWebGLContext
            }
        }), Object.defineProperty(exports, "GPGPUContext", {
            enumerable: !0,
            get: function() {
                return u.GPGPUContext
            }
        }), exports.webgl_util = exports.gpgpu_util = void 0;
        var e = require("@tensorflow/tfjs-core"),
            t = p(require("./gpgpu_util"));
        exports.gpgpu_util = t;
        var r = p(require("./webgl_util"));
        exports.webgl_util = r;
        var n = require("./backend_webgl"),
            o = require("./canvas_util"),
            u = require("./gpgpu_context");

        function i() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return i = function() {
                return e
            }, e
        }

        function p(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = i();
            if (t && t.has(e)) return t.get(e);
            var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var u = n ? Object.getOwnPropertyDescriptor(e, o) : null;
                    u && (u.get || u.set) ? Object.defineProperty(r, o, u) : r[o] = e[o]
                } return r.default = e, t && t.set(e, r), r
        }

        function a() {
            (0, e.env)().set("WEBGL_FORCE_F16_TEXTURES", !0)
        }
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./gpgpu_util": "LB6l",
        "./webgl_util": "p3g2",
        "./backend_webgl": "YZpX",
        "./canvas_util": "S11S",
        "./gpgpu_context": "AZP2"
    }],
    "kg9U": [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var e = {
            webgl: !0,
            version_webgl: !0
        };
        Object.defineProperty(exports, "version_webgl", {
            enumerable: !0,
            get: function() {
                return o.version
            }
        }), exports.webgl = void 0;
        var r = require("@tensorflow/tfjs-core"),
            t = require("./backend_webgl"),
            o = require("./version");
        require("./register_all_kernels");
        var l = require("./webgl");
        Object.keys(l).forEach(function(r) {
            "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, {
                enumerable: !0,
                get: function() {
                    return l[r]
                }
            }))
        }), r.device_util.isBrowser() && (0, r.registerBackend)("webgl", () => new t.MathBackendWebGL, 2);
        const n = {
            forceHalfFloat: l.forceHalfFloat
        };
        exports.webgl = n;
    }, {
        "@tensorflow/tfjs-core": "tc6m",
        "./backend_webgl": "YZpX",
        "./version": "SdA6",
        "./register_all_kernels": "FAdT",
        "./webgl": "BRLE"
    }],
    "Focm": [function(require, module, exports) {
        "use strict";
        var e = o(require("@tensorflow-models/handpose")),
            t = o(require("@tensorflow/tfjs-core")),
            n = o(require("@tensorflow/tfjs-backend-wasm"));

        function a() {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap;
            return a = function() {
                return e
            }, e
        }

        function o(e) {
            if (e && e.__esModule) return e;
            if (null === e || "object" != typeof e && "function" != typeof e) return {
                default: e
            };
            var t = a();
            if (t && t.has(e)) return t.get(e);
            var n = {},
                o = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var r = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    r && (r.get || r.set) ? Object.defineProperty(n, i, r) : n[i] = e[i]
                } return n.default = e, t && t.set(e, n), n
        }

        function i() {
            const e = /Android/i.test(navigator.userAgent),
                t = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            return e || t
        }
        require("@tensorflow/tfjs-backend-webgl"), n.setWasmPath(`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${n.version_wasm}/dist/tfjs-backend-wasm.wasm`);
        let r, s, c, d, l, u, g, f = !1,
            w = {
                thumb: [0, 1, 2, 3, 4],
                indexFinger: [0, 5, 6, 7, 8],
                middleFinger: [0, 9, 10, 11, 12],
                ringFinger: [0, 13, 14, 15, 16],
                pinky: [0, 17, 18, 19, 20]
            };
        const h = handposeConfig.width,
            m = handposeConfig.height,
            y = i(),
            v = !1 === y,
            p = {
                backend: "webgl"
            },
            b = new Stats;

        function k() {
//            const e = new dat.GUI;
//            e.add(p, "backend", ["webgl", "wasm"]).onChange(async e => {
//                window.cancelAnimationFrame(c), await t.setBackend(e), U(video)
//            }), v && e.add(p, "renderPointcloud").onChange(e => {
//                document.querySelector("#scatter-gl-container").style.display = e ? "inline-block" : "none"
//            })
        }

        function P(e, t, n) {
            d.beginPath(), d.arc(t, e, n, 0, 2 * Math.PI), d.fill()
        }

        function j(e) {
            const t = e;
            for (let a = 0; a < t.length; a++) {
                const e = t[a][0];
                P(t[a][1] - 2, e - 2, 3)
            }
            const n = Object.keys(w);
            for (let a = 0; a < n.length; a++) {
                const t = n[a];
                M(w[t].map(t => e[t]), !1)
            }
        }

        function M(e, t) {
            const n = new Path2D;
            n.moveTo(e[0][0], e[0][1]);
            for (let a = 1; a < e.length; a++) {
                const t = e[a];
                n.lineTo(t[0], t[1])
            }
            t && n.closePath(), d.stroke(n)
        }
        let O;
        async function S() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");
            const e = document.getElementById("videoElement"),
                t = await navigator.mediaDevices.getUserMedia({
                    audio: !1,
                    video: {
                        facingMode: "user",
                        width: y ? void 0 : h,
                        height: y ? void 0 : m,
//                        scale: true,
                    }
                });
            return e.srcObject = t, new Promise(t => {
                e.onloadedmetadata = (() => {
                    t(e)
                })
            })
        }
        async function q() {
            const e = await S();
            return e.play(), e
        }
        async function D() {
            let n;
            await t.setBackend(p.backend), O = await e.load();
            try {
                n = await q()
            } catch (a) {
                let e = document.getElementById("info");
                throw e.textContent = a.message, e.style.display = "block", a
            }
            k(), r = n.videoWidth, s = n.videoHeight, (l = document.getElementById("canvasHands")).width = r, l.height = s, n.width = r, n.height = s, (d = l.getContext("2d")).clearRect(0, 0, r, s);
            // hand colors
            d.strokeStyle = "red", d.fillStyle = "red";

            // this mirrors the hand boxes
            //d.translate(l.width, 0);
            //d.scale(-1, 1);

            u = [
                [0, 0, 0],
                [0, -m, 0],
                [-h, 0, 0],
                [-h, -m, 0]
            ], /*v && (document.querySelector("#scatter-gl-container").style = `width: ${h}px; height: ${m}px;`, g = new ScatterGL(document.querySelector("#scatter-gl-container"), {
                rotateOnStart: !1,
                selectEnabled: !1
            })),*/ U(n)
        }
        var U = function(n){};
        if(hadouken.handsDetectionEngine == 2){
            b.showPanel(0), document.body.appendChild(b.dom), v && (p.renderPointcloud = !0);
            var videoInit = false;
            U = async e => {
                !async function t() {
                    var flipVideo = hadouken.handDetectionModelParams.flipHorizontal;
                    b.begin();
                    if(flipVideo){
                        // mirror image
                        d.translate(l.width, 0);
                        d.scale(-1, 1);
                    }
                    if(!videoInit) {
                        videoInit = true;
                        hadouken.onVideoInitialized(l.width, l.height);
                    }
                    d.drawImage(e, 0, 0, r, s, 0, 0, l.width, l.height);
                    if(flipVideo){
                          // rollback mirror
                        d.translate(-l.width, 0);
                        d.scale(1, 1);
                     }
                    const n = await O.estimateHands(e, flipVideo);
                    if (n.length > 0) {
                        try{ hadouken.handsDetectorCallback(n[0]); } catch(e) {}
                        const e = n[0].landmarks;
                        if(hadouken.drawHandBox) {
                            if (j(e, n[0].annotations), !0 === v && null != g) {
    //                            const t = e.map(e => [-e[0], -e[1], -e[2]]),
    //                                n = new ScatterGL.Dataset([...t, ...u]);
    //                            if (f) g.updateDataset(n);
    //                            else {
    //                                g.render(n);
    //                                const e = Object.keys(w);
    //                                g.setSequences(e.map(e => ({
    //                                    indices: w[e]
    //                                }))), g.setPointColorer(e => e < t.length ? "steelblue" : "white")
    //                            }
    //                            f = !0
                            }
                        }
                    }
                    b.end(), c = requestAnimationFrame(t)
                }()
            };
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia, D();
        } else {

        }
    }, {
        "@tensorflow-models/handpose": "dGni",
        "@tensorflow/tfjs-core": "tc6m",
        "@tensorflow/tfjs-backend-wasm": "M1oU",
        "@tensorflow/tfjs-backend-webgl": "kg9U"
    }]
}, {}, ["Focm"], null)
//# sourceMappingURL=demo.5a7766e5.js.map
